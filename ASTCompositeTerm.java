import java.util.Vector; 
import java.io.*; 

import javax.swing.*;


/******************************
* Copyright (c) 2003--2025 Kevin Lano
* This program and the accompanying materials are made available under the
* terms of the Eclipse Public License 2.0 which is available at
* http://www.eclipse.org/legal/epl-2.0
*
* SPDX-License-Identifier: EPL-2.0
* *****************************/


public class ASTCompositeTerm extends ASTTerm
{ String tag = ""; 
  Vector terms = new Vector(); // of ASTTerm

  public static BasicExpression zeroExpression = 
                             new BasicExpression(0); 
  public static BasicExpression zeroDoubleExpression = 
                             new BasicExpression(0.0); 
  public static BasicExpression unitExpression = 
                             new BasicExpression(1); 
  public static BasicExpression oneExpression = 
                             new BasicExpression(1); 
  public static BasicExpression twoExpression = 
                             new BasicExpression(2); 
  public static BasicExpression minusOne = 
                             new BasicExpression(-1); 
  public static BasicExpression minusOneExpr = 
                             new BasicExpression(-1); 
  public static BasicExpression emptyStringExpression = 
         BasicExpression.newValueBasicExpression("\"\""); 
  public static BasicExpression nullExpression = 
         BasicExpression.newValueBasicExpression("null"); 

  public static BasicExpression trueExpression = 
                             new BasicExpression(true); 
  public static BasicExpression falseExpression = 
                             new BasicExpression(false); 

  public static BasicExpression emptyString = 
         BasicExpression.newValueBasicExpression("\"\""); 
  public static BasicExpression forwardSlash = 
         BasicExpression.newValueBasicExpression("\"\\\""); 
  public static BasicExpression backwardSlash = 
         BasicExpression.newValueBasicExpression("\"/\""); 
  public static Expression emptySet = 
         new SetExpression(false);  
  public static Expression emptySequence = 
         new SetExpression(true);  

  public static Type intType = new Type("int", null); 
  public static Type longType = new Type("long", null); 
  public static Type doubleType = new Type("double", null); 
  public static Type voidType = new Type("void", null); 
  public static Type booleanType = new Type("boolean", null); 
  public static Type stringType = new Type("String", null); 
  public static Type sequenceType = new Type("Sequence", null); 
  public static Type setType = new Type("Set", null); 
  public static Type mapType = new Type("Map", null); 

  public static Expression booleanTypeExpression = 
                         new BasicExpression(booleanType); 
  public static Expression intTypeExpression = 
                         new BasicExpression(intType); 
  public static Expression longTypeExpression = 
                         new BasicExpression(longType); 
  public static Expression doubleTypeExpression = 
                         new BasicExpression(doubleType); 
  public static Expression stringTypeExpression = 
                         new BasicExpression(stringType); 
  public static Expression sequenceTypeExpression = 
                         new BasicExpression(sequenceType); 
  public static Expression setTypeExpression = 
                         new BasicExpression(setType); 
  public static Expression mapTypeExpression = 
                         new BasicExpression(mapType); 

  public static Statement skipStatement = 
                     new InvocationStatement("skip"); 

  public ASTCompositeTerm(String t)
  { tag = t; 
    terms = new Vector(); 
  } 

  public ASTCompositeTerm(String t, Vector subtrees)
  { tag = t; 
    terms = subtrees; 
  } 

  public ASTCompositeTerm(String t, ASTTerm trm)
  { tag = t; 
    terms = new Vector();
    terms.add(trm);  
  } 

  public boolean hasTag(String tagx)
  { return (tagx.equals(tag)); } 

  public String getTag()
  { return tag; }

  public boolean hasSingleTerm() 
  { return terms.size() == 1; } 

  public boolean isNestedSymbolTerm() 
  { if (terms.size() == 1)
    { ASTTerm t0 = (ASTTerm) terms.get(0); 
      return t0.isNestedSymbolTerm(); 
    }
    return false; 
  }  

  public Vector allNestedSubterms() 
  { Vector res = new Vector(); 
    if (terms.size() == 1)
    { ASTTerm t0 = (ASTTerm) terms.get(0);
      res.add(t0);  
      res.addAll(t0.allNestedSubterms()); 
    }

    return res; 
  }  

  public Vector allIdentifiers(Vector tags)
  { Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm trm = (ASTTerm) terms.get(i); 
      Vector idens = trm.allIdentifiers(tags); 
      res.addAll(idens); 
    } 
    return res; 
  } 

  public int arity()
  { return terms.size(); } 

  public String tagFunction()
  { String res = ""; 
    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i); 
      if (trm instanceof ASTSymbolTerm) 
      { if ("".equals(res))
        { res = tag + "~"; }
        else 
        { res = res + "$" + tag + "~"; }
      }  
      else 
      { String tstring = tag + "_" + trm.tagFunction(); 
        if ("".equals(res))
        { res = tstring; }
        else 
        { res = res + "$" + tstring; } 
      } 
    } 
    return res; 
  }  
 
  public int nonSymbolArity()
  { int res = 0; 
    for (int i = 0; i < terms.size(); i++)
    { if (terms.get(i) instanceof ASTSymbolTerm) { } 
      else 
      { res++; }
    } 
    return res; 
  }  

  public Vector symbolTerms()
  { Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++)
    { if (terms.get(i) instanceof ASTSymbolTerm) 
      { res.add(terms.get(i)); } 
    } 
    return res; 
  }  

  public Vector nonSymbolTerms()
  { Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++)
    { if (terms.get(i) instanceof ASTSymbolTerm) { } 
      else  
      { res.add(terms.get(i)); } 
    } 
    return res;
  } 
 
  public ASTTerm removeOuterTag()
  { if (terms.size() > 0)
    { return (ASTTerm) terms.get(0); } 
    return null; 
  }  

  public ASTTerm removeWhitespaceTerms()
  { ASTTerm res = null;
    Vector newterms = new Vector();  
    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i);
      ASTTerm ntrm = trm.removeWhitespaceTerms(); 
      if (ntrm == null) 
      { continue; }  
      if (trm instanceof ASTSymbolTerm)
      { String str = ntrm.literalForm();
        String strim = str.trim(); 
        // System.out.println(">--- old term: " + str);  
        if ("\\r\\n".equals(strim) ||
            "\\r\\n\\r\\n".equals(strim) ||
            "\\r\\n\\r\\n\\r\\n".equals(strim) ||
            "\\n\\r".equals(strim)) 
        { // System.out.println(">--- removing whitesace: " + strim); 
        } 
        else if (strim.endsWith("\\r\\n\\r\\n"))
        { // System.out.println(">--- old term: " + strim);
          str = strim.substring(0,strim.length()-8); 
          ntrm = new ASTSymbolTerm(str); 
          // System.out.println(">--- new term: " + str);  
          newterms.add(ntrm); 
        } 
        else if (strim.endsWith("\\r\\n") ||
                 strim.endsWith("\\n\\r"))
        { // System.out.println(">--- old term: " + strim);  
          str = strim.substring(0,strim.length()-4); 
          ntrm = new ASTSymbolTerm(str); 
          // System.out.println(">--- new term: " + str);  
          newterms.add(ntrm); 
        } 
        else 
        { newterms.add(ntrm); } 
      } 
      else
      { newterms.add(ntrm); }
    } 

    if (newterms.size() > 1)
    { res = new ASTCompositeTerm(tag,newterms); } 
    else if (newterms.size() == 1)
    { ASTTerm tt = (ASTTerm) newterms.get(0); 
      if (tt instanceof ASTSymbolTerm)
      { res = new ASTBasicTerm(tag,tt.literalForm()); } 
      else 
      { res = new ASTCompositeTerm(tag,newterms); } 
    } 
    return res; 
  }  

  public ASTTerm removeExtraNewlines()
  { ASTTerm res = null;

    Vector newterms = new Vector();  
    String prevterm = ""; 

    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i);
      ASTTerm ntrm = trm.removeExtraNewlines(); 
      if (ntrm == null) 
      { continue; }  
      if (trm instanceof ASTSymbolTerm)
      { String str = ntrm.literalForm();
        String strim = str.trim(); 
        // System.out.println(">--- old term: " + str);  
        if ("\\r\\n".equals(strim) && 
            "\\r\\n".equals(prevterm))
        { continue; } 
        newterms.add(ntrm); 
        prevterm = strim; 
      } 
      else 
      { newterms.add(ntrm); 
        prevterm = ""; 
      } 
    }

    if (newterms.size() > 1)
    { res = new ASTCompositeTerm(tag,newterms); } 
    else if (newterms.size() == 1)
    { ASTTerm tt = (ASTTerm) newterms.get(0); 
      if (tt instanceof ASTSymbolTerm)
      { res = new ASTBasicTerm(tag,tt.literalForm()); } 
      else 
      { res = new ASTCompositeTerm(tag,newterms); } 
    } 

    return res; 
  }  

  public ASTTerm replaceCobolIdentifiers()
  { // Each (cobolName sss) updated to be valid sss
    // FILLER becomes FILLER$n 
    // Identify ambiguous field names

    if ("dataName".equals(tag) && terms.size() == 1)
    { ASTTerm nameTerm = (ASTTerm) terms.get(0); 
      ASTTerm ntrm = nameTerm.replaceCobolIdentifiers(); 
      return new ASTCompositeTerm("dataName", ntrm); 
    } 

    if ("dataRedefinesClause".equals(tag))
    { Vector newterms = new Vector();  
      for (int i = 0; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i);
        ASTTerm ntrm = trm.replaceCobolIdentifiers(); 
        if (ntrm != null) 
        { newterms.add(ntrm); }
        // JOptionPane.showMessageDialog(null, this + 
        //       " replaced redefines term " + trm + " by " +
        //       ntrm, 
        //       " ", JOptionPane.INFORMATION_MESSAGE);
      }  
      return new ASTCompositeTerm(tag,newterms); 
    } 

    


    if ("dataDescriptionEntryFormat1".equals(tag) && 
        ((ASTTerm) terms.get(1)).getTag().equals("dataPictureClause"))
    { // anonymous data field
      Vector nterms = new Vector(); 
      nterms.add(terms.get(0)); 
      ASTTerm.cobolFillerCount++; 
      nterms.add(new ASTSymbolTerm("FILLER_F" + 
                    ASTTerm.cobolFillerCount));
      /* JOptionPane.showMessageDialog(null, this + 
              " added filler " + ASTTerm.cobolFillerCount, 
              " ", JOptionPane.INFORMATION_MESSAGE); */ 
      for (int i = 1; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i);
        nterms.add(trm); 
      } 
      return new ASTCompositeTerm(tag,nterms); 
    } 
    else if ("dataDescriptionEntryFormat1".equals(tag) && 
       ((ASTTerm) terms.get(1)).getTag().equals("dataName"))
    { // non-anonymous field
      ASTTerm nameTerm = (ASTTerm) terms.get(1); 
      ASTTerm ntrm = nameTerm.replaceCobolIdentifiers(); 

      String fld = ntrm.literalForm(); 
      if (ASTTerm.cobolDataDescriptionDataNames.contains(fld))
      { /* JOptionPane.showMessageDialog(null, this + 
              " Ambiguous field name: " + fld, 
              " ", JOptionPane.INFORMATION_MESSAGE); */ 
        ASTTerm.setTaggedValue(fld, "ambiguousName", 
                               "true");  
        ASTTerm.cobolAmbiguousDataNames.add(fld);
      } 
      else 
      { ASTTerm.cobolDataDescriptionDataNames.add(fld); }


      if (terms.size() > 2 && 
          ((ASTTerm) terms.get(2)).getTag().equals("dataRedefinesClause"))
      { ASTTerm redefTerm = (ASTTerm) terms.get(2); 
        ASTTerm nredef = redefTerm.replaceCobolIdentifiers(); 
        Vector nterms = new Vector(); 
        nterms.add(terms.get(0)); 
        nterms.add(ntrm); 
        nterms.add(nredef); 
        for (int i = 3; i < terms.size(); i++)
        { ASTTerm trm = (ASTTerm) terms.get(i);
          nterms.add(trm); 
        } 
        return new ASTCompositeTerm(tag,nterms); 
      } 
        
      Vector nterms = new Vector(); 
      nterms.add(terms.get(0)); 
      nterms.add(ntrm); 
      for (int i = 2; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i);
        nterms.add(trm); 
      } 
      return new ASTCompositeTerm(tag,nterms); 
    } 
 
    Vector newterms = new Vector();  
    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i);
      if ("FILLER".equals(trm.literalForm()))
      { ASTTerm.cobolFillerCount++; 
        newterms.add(new ASTSymbolTerm("FILLER_F" + 
                           ASTTerm.cobolFillerCount));
    /*    JOptionPane.showMessageDialog(null, this + 
              " replaced filler " + ASTTerm.cobolFillerCount, 
              " ", JOptionPane.INFORMATION_MESSAGE);
     */ 
      }        
      else 
      { ASTTerm ntrm = trm.replaceCobolIdentifiers(); 
        if (ntrm != null) 
        { newterms.add(ntrm); }
      }  
    } 

    return new ASTCompositeTerm(tag,newterms); 
  } 

  public ASTTerm replaceAmbiguousCobolNames(Vector rnames)
  { // Each ambiguous field name fld becomes rname$fld

    if ("dataDescriptionEntryFormat1".equals(tag) &&
        rnames.size() > 0 && 
        ASTTerm.hasTag(terms,"dataPictureClause"))
    { // It is a basic data item, not an entity

        
      Vector nterms = new Vector(); 
      nterms.add(terms.get(0)); 
      ASTTerm nameTerm = (ASTTerm) terms.get(1); 
      String fld = nameTerm.literalForm(); 

      String rname = (String) rnames.get(0); 

     /* JOptionPane.showMessageDialog(null, this + 
              " Basic data item: " + fld + " in " + rname, 
              " ", JOptionPane.INFORMATION_MESSAGE); */ 

      if (ASTTerm.cobolAmbiguousDataNames.contains(fld))
      { ASTTerm newname = 
          new ASTBasicTerm("dataName", rname + "$" + fld); 
        nterms.add(newname); 
      } 
      else 
      { nterms.add(nameTerm); }
      
      for (int i = 2; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i);
        nterms.add(trm); 
      } 
      return new ASTCompositeTerm(tag,nterms); 
    } 
    else if ("dataDescriptionEntryFormat1".equals(tag) &&
        ((ASTTerm) terms.get(1)).getTag().equals("dataName") &&
        !ASTTerm.hasTag(terms,"dataPictureClause"))
    { // It is an entity
 
      ASTTerm rec = (ASTTerm) terms.get(1); 
      String ename = rec.literalForm(); 

      /* JOptionPane.showMessageDialog(null, this + 
              " Record data: " + ename, 
              " ", JOptionPane.INFORMATION_MESSAGE); */ 

      Vector newterms = new Vector();
      newterms.add(terms.get(0)); 
      newterms.add(rec); 
  
      rnames.add(0,ename); 

      for (int i = 2; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i);
        ASTTerm ntrm = trm.replaceAmbiguousCobolNames(rnames); 
        if (ntrm != null) 
        { newterms.add(ntrm); }
      }  
      return new ASTCompositeTerm(tag,newterms); 
    } 

    Vector newtms = new Vector();
     
    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i);
      ASTTerm ntrm = trm.replaceAmbiguousCobolNames(rnames); 
      if (ntrm != null) 
      { newtms.add(ntrm); }
    }  
    return new ASTCompositeTerm(tag,newtms); 
  } 


  public ASTTerm substituteEq(String str, ASTTerm newtrm)
  { // Replace any term that has literalform str by newtrm

    Vector newterms = new Vector();  

    for (int i = 0; i < terms.size(); i++)
    { ASTTerm trm = (ASTTerm) terms.get(i);
      String lit = trm.literalForm(); 
      if (lit.equals(str))
      { newterms.add(newtrm); }
      else 
      { ASTTerm subtrm = trm.substituteEq(str,newtrm); 
        newterms.add(subtrm); 
      }  
    } 

    return new ASTCompositeTerm(tag,newterms); 
  } 
  

  public ASTTerm getTerm(int i) 
  { if (i < terms.size())
    { return (ASTTerm) terms.get(i); } 
    return null; 
  }

  public Vector allNestedTagsArities()
  { Vector res = new Vector(); 
    Vector pair = new Vector(); 
    pair.add(tag); pair.add(terms.size()); 
    res.add(pair); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i); 
      res.addAll(tt.allNestedTagsArities()); 
    } 
    return res; 
  } 

  public Vector allTagsArities()
  { Vector res = new Vector(); 
    Vector pair = new Vector(); 
    pair.add(tag); pair.add(terms.size()); 
    res.add(pair); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i); 
      res.addAll(tt.allTagsArities()); 
    } 
    return res; 
  } 

  public java.util.Set allTagsIn()
  { java.util.Set res = new java.util.HashSet(); 
    res.add(tag);  
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i); 
      res.addAll(tt.allTagsIn()); 
    } 
    return res; 
  } 

  public Vector getTerms()
  { return terms; }  

  public void addTerm(ASTTerm t) 
  { terms.add(t); } 

  public String toString()
  { String res = "(" + tag; 
    for (int i = 0; i < terms.size(); i++) 
    { res = res + " " + terms.get(i); } 
    res = res + ")"; 
    return res; 
  } 

  public boolean equals(Object obj)
  { if (obj instanceof ASTCompositeTerm) 
    { ASTCompositeTerm other = (ASTCompositeTerm) obj; 
      if (other.tag.equals(tag))
      { Vector trms = other.getTerms(); 
        if (trms.size() != terms.size())
        { return false; } 
        for (int i = 0; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          if (tt.equals(trms.get(i))) { } 
          else 
          { return false; } 
        }
        return true;  
      } 
    } 
    return false; 
  } 
  

  public String toJSON()
  { String res = "{ \"root\" : \"" + tag + "\", \"children\" : ["; 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm trm = (ASTTerm) terms.get(i); 
      res = res + trm.toJSON(); 
      if (i < terms.size()-1)
      res = res + ", "; 
    }  
    res = res + "] }"; 
    return res; 
  } 


  public String literalForm()
  { String res = ""; 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i); 
      if (t == null) { continue; } 
      res = res + t.literalForm(); 
    } 
    return res; 
  } 

  public String literalFormSpaces()
  { String res = ""; 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i);
      if (t == null) { continue; }  
      res = res + t.literalFormSpaces();
      if (i < terms.size() - 1)
      { res = res + " "; }  
    } 
    return res; 
  } 

  public String evaluationLiteralForm()
  { String res = ""; 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i);
      if (t == null) { continue; }  
      res = res + ASTTerm.symbolicEvaluation(t);
      // if (i < terms.size() - 1)
      // { res = res + " "; }  
    } 
    return res; 
  } 

  public Vector tokenSequence()
  { Vector res = new Vector();  
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i); 
      res.addAll(t.tokenSequence()); 
    } 
    return res; 
  } 

  public int size()
  { return terms.size(); } 

  public int termSize()
  { int res = 0;  
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i); 
      res = res + t.termSize(); 
    } 
    return res; 
  } 

  public String asTextModel(PrintWriter out)
  { String id = Identifier.nextIdentifier(tag);
 
    out.println(id + " : " + tag); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i); 
      String ttid = tt.asTextModel(out); 
      out.println(id + ".term" + i + " = " + ttid); 
    }
    out.println();  
    return id;  
  } 

  public String cg(CGSpec cgs)
  { // Find the cgs rules r for tag, match the terms to 
    // the r LHS, then apply first rule to the cg results of 
    // the LHS matchings. 

    // if already cached, return that value: 
    String cachedValue = ASTTerm.getCg_cache(cgs,this); 
    if (cachedValue != null) 
    { return cachedValue; } 

    Vector rules = cgs.getRulesForCategory(tag);
    String res = cgRules(cgs,rules); 
    ASTTerm.putCg_cache(cgs,this,res); 
    return res; 
  } 

  public String cgRules(CGSpec cgs, Vector rules)
  { if (rules == null) 
    { return this + ""; }
 
    // Try to find a matching rule r

    for (int i = 0; i < rules.size(); i++) 
    { CGRule r = (CGRule) rules.get(i);
      Vector tokens = r.lhsTokens; 
      Vector vars = r.getVariables(); 

      java.util.HashMap matches = new java.util.HashMap(); 
      // vars --> String

      Vector matchedTerms = new Vector(); 
      Vector matchedTokens = new Vector(); 

      if (tokens.size() > terms.size())
      { // System.out.println("> " + tag + " rule " + r + " does not match " + this);  
        // System.out.println("!! Too many elements on rule LHS (" + tokens.size() + ") to match subterms: (" + terms.size() + ")"); 
        continue; 
      } // _* and _+ must match at least one term. 
      else if (vars.contains("_*") && terms.size() >= tokens.size())
      { } // ok 
      else if (vars.contains("_+") && terms.size() >= tokens.size())
      { } // ok 
      else if (tokens.size() == terms.size())
      { } // ok
      else 
      { continue; } // this term can't match r's LHS

      // System.out.println("> Trying to match tokens of rule " + r + " for " + this);  
        
      Vector args = new Vector(); 
        // Strings resulting from the terms[k].cg(cgs)
      Vector eargs = new Vector(); 
        // the actual terms[k]

      int k = 0; // terms position. 
      boolean failed = false; 

      for (int j = 0; j < tokens.size() && 
                      k < terms.size() && !failed; j++) 
      { String tok = (String) tokens.get(j); 
        ASTTerm tm = (ASTTerm) terms.get(k); 
        String tmliteral = tm.literalForm(); 

        // System.out.println("$$$ matching token " + tok + " and term " + tm); 

        if ("_*".equals(tok) && vars.contains(tok))
        { // remainder of terms is processed as a list
          // _* should be the last token, or terminated by 
          // nextTok

          String nextTok = null; 
          if (tokens.size() > j+1)
          { nextTok = (String) tokens.get(j+1); } 

          // System.out.println(">> Terminator token for _* is: " + nextTok); 
          int remainingTokens = tokens.size() - (j+1); 

          boolean finished = false; 

          Vector rem = new Vector(); 
          for (int p = k ; p < terms.size() && !finished; p++)
          { ASTTerm pterm = (ASTTerm) terms.get(p);
            int remainingTerms = terms.size() - (k+1); 
 
            if (nextTok != null && 
                pterm.literalForm().equals(nextTok))
            { // System.out.println("$$$ Matched terminator token " + 
              //         nextTok + 
              //         " for _* and term " + pterm); 
              finished = true;
              matchedTokens.add("_*");  
              // k++; // next term after terminator
              // j++; // Next lhs token after _*
              // j++; // Next lhs token after terminator
            } 
            else if (remainingTokens > remainingTerms)
            { matchedTokens.add("_*");  
              finished = true; 
            } 
            else 
            { rem.add(pterm); 
              matchedTerms.add(pterm); 
              k++;
            }  
            // System.out.println(">>> Terms for _* are: " + rem); 
          } 
          eargs.add(rem); // corresponds to _* variable
        } 
        else if ("_+".equals(tok) && vars.contains(tok))
        { // remainder of terms is processed as a list
          // _+ should be the last token, or terminated by 
          // nextTok

          String nextTok = null; 
          if (tokens.size() > j+1)
          { nextTok = (String) tokens.get(j+1); } 

          // System.out.println(">> Terminator token for _+ is: " + nextTok); 
          int remainingTokens = tokens.size() - (j+1); 

          boolean finished = false; 

          Vector rem = new Vector(); 
          for (int p = k ; p < terms.size() && !finished; p++)
          { ASTTerm pterm = (ASTTerm) terms.get(p);
            int remainingTerms = terms.size() - (k+1); 
 
            if (nextTok != null && 
                pterm.literalForm().equals(nextTok))
            { finished = true;
              matchedTokens.add("_*");  
            } 
            else if (remainingTokens > remainingTerms)
            { matchedTokens.add("_*");  
              finished = true; 
            } 
            else 
            { rem.add(pterm);
              matchedTerms.add(pterm);  
              k++;
            }  
            // System.out.println(">>> Terms for _+ are: " + rem); 
          } 
          eargs.add(rem); // corresponds to _+ variable
        } 
        else if (vars.contains(tok))
        { // allocate terms(j) to tok

          // System.out.println(">> Matched variable " + tok + 
          //                     " and term " + tm);

          matchedTokens.add(tok); 
          matchedTerms.add(tm); 

          String oldterm = (String) matches.get(tok); 
          if (oldterm == null)
          { matches.put(tok,tmliteral); 

            eargs.add(tm); 
            k++; 
          } 
          else if (oldterm.equals(tmliteral)) 
          { 
            eargs.add(tm); 
            k++; 
          } 
          else 
          { // System.err.println("!! Same variable " + tok + 
            //                    " assigned different terms: " + 
            //                   oldterm + " " + tm); 
            failed = true; 
          } 
        } 
        else if (tok.equals(tmliteral))
        { // System.out.println(">> Matched token " + tok + 
          //                     " and term " + tm); 
          matchedTerms.add(tm); 
          matchedTokens.add(tok); 
          k++; 
        } 
        else 
        { // System.out.println("> " + tag + " rule " + r + " does not match " + this); 
          // System.out.println(tok + " /= " + tmliteral); 
          k++; 
          failed = true; // try next rule 
        } 
      } 

      if (matchedTokens.containsAll(tokens) && 
          tokens.containsAll(matchedTokens))
      { // System.out.println("&&& All tokens matched: " + tokens); 
      } 
      // else 
      // { failed = true; } 

      if (matchedTerms.containsAll(terms) && 
          terms.containsAll(matchedTerms))
      { // System.out.println("&&& All terms matched: " + terms); 
      } 
      else 
      { failed = true; } 


      if (failed == false) 
      { // System.out.println(">> Matched " + tag + " rule " + r + " for " + this);  

        // Repeated evaluation of term.cg(cgs). Must be cached

        for (int p = 0; p < eargs.size(); p++)
        { Object obj = eargs.get(p);
          if (obj instanceof ASTTerm) 
          { ASTTerm term = (ASTTerm) obj;  
            String textp = term.cg(cgs); 
            args.add(textp);
          } 
          else if (obj instanceof Vector) 
          { Vector vterms = (Vector) obj; 
            String textp = ""; 
            for (int q = 0; q < vterms.size(); q++) 
            { ASTTerm vterm = (ASTTerm) vterms.get(q); 
              textp = textp + vterm.cg(cgs); 
            } 
            args.add(textp); 
          }     
        } 

        Vector ents = new Vector(); 

        if (r.satisfiesAllConditions(args,eargs,ents,cgs))
        { System.out.println(">>>> Applying " + tag + 
                             " rule " + r + " for " + this); 
          return r.applyRule(args,eargs,cgs); 
        }  
        else 
        { System.out.println(">!!> Conditions failed of rule " + r + " for " + this); 
        } 
      }
    }  

    // No rule in the given ruleset explicitly matches this term, 
    // instead if there is a rule _0 |-->RHS[_0] 
    // try the ruleset named by the tag of this term 
    // and substitute the result for _0 in the RHS. 

    System.out.println(); 
    if (CGRule.hasDefaultRule(rules))
    { Vector tagrules = cgs.getRulesForCategory(tag);
      if (tagrules.equals(rules)) 
      { return literalFormSpaces(); }

      System.out.println(">> Applying default rule _0 |-->_0 to " + this);  
      String res = this.cgRules(cgs,tagrules);
      return CGRule.applyDefaultRule(rules,res); 
    } 

    return toString(); // failed to process it
  }

  public ASTTerm instantiate( 
                             java.util.HashMap res)

  { // replace any _i by res.get(_i)

    int n = terms.size(); 
    Vector newterms = new Vector(); 

    for (int i = 0; i < n; i++) 
    { ASTTerm trmi = (ASTTerm) terms.get(i); 
 
      ASTTerm newterm = trmi.instantiate(res); 
      newterms.add(newterm); 
    }   

    return new ASTCompositeTerm(tag, newterms); 
  } // May not conform exactly to same grammar as this. 


  public java.util.HashMap hasMatch(ASTTerm rterm, 
                                    java.util.HashMap res) 
  { // This term or a subterm matches to schematic term rterm

    java.util.Set vars = rterm.allMathMetavariables(); 

    java.util.HashMap resx = this.fullMatch(rterm,res); 
    if (resx != null && vars.equals(resx.keySet())) 
    { return resx; } 

    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm trm = (ASTTerm) terms.get(i); 
      resx = trm.hasMatch(rterm,res);

      /* JOptionPane.showMessageDialog(null, 
       "### Bindings: " + resx + 
       " Math vars: " + vars,   "",
       JOptionPane.INFORMATION_MESSAGE);  */ 
 
      if (resx != null && vars.equals(resx.keySet())) 
      { return resx; } 
    } 

    return res; 
  } 

  public java.util.HashMap fullMatch(ASTTerm rterm, 
                                     java.util.HashMap res) 
  { // This term matches to a schematic term rterm
    // Same structure, but terms can correspond to 
    // metavariables _V, _W in rterm. 

    int n = terms.size(); 
    int m = rterm.arity(); 
    Vector rterms = rterm.getTerms(); 

    String thislit = literalForm(); 
    String rlit = rterm.literalForm(); 

    System.out.println("#### attempting full match of " + 
                       thislit + " with " + rlit); 
    
    if (thislit.equals(rlit))
    { return res; } // match with no new binding

    if (CSTL.isMathMetavariable(rlit))
      //  CSTL.isCSTLVariable(rlit))
    { res.put(rlit, this); 
        /* JOptionPane.showMessageDialog(null, 
            "### Binding: " + rlit + " bound to " + 
            this,   "",
          JOptionPane.INFORMATION_MESSAGE); */ 
      return res; 
    } 
    else if (m == 1 && n == 1) 
    { ASTTerm rtermi = (ASTTerm) rterms.get(0);
      ASTTerm trmi = (ASTTerm) terms.get(0); 
      return trmi.fullMatch(rtermi,res); 
    } 
    else if (m == 1 && n > 1)
    { ASTTerm rtermi = (ASTTerm) rterms.get(0);
      return this.fullMatch(rtermi,res); 
    } 
    else if (n == 1 && m > 1)
    { ASTTerm trmi = (ASTTerm) terms.get(0); 
      return trmi.fullMatch(rterm,res); 
    } 
    else if (m == 1 || m == 0) 
    { return null; } 

    if (n != m) 
    { return null; } 

    for (int i = 0; i < m; i++) 
    { ASTTerm rtermi = (ASTTerm) rterms.get(i);
      ASTTerm trmi = (ASTTerm) terms.get(i); 
 
      String rilit = rtermi.literalForm(); 
      String liti = trmi.literalForm(); 

      // if (CSTL.isCSTLVariable(rilit))
      if (CSTL.isMathMetavariable(rilit))
      { ASTTerm oldterm = (ASTTerm) res.get(rilit);    
        if (oldterm == null) 
        { res.put(rilit, trmi);
          /* JOptionPane.showMessageDialog(null, 
            "### Binding: " + rilit + " bound to " + 
            trmi,   "",
          JOptionPane.INFORMATION_MESSAGE); */ 
        } 
        else if (liti.equals(oldterm.literalForm())) 
        { } // must be the same as terms.get(i)
        else 
        { return null; } // clash of different terms
      } 
      else if (rtermi instanceof ASTSymbolTerm)
      { if (liti.equals(rilit))
        { } 
        else 
        { return null; } 
      } 
      else 
      { java.util.HashMap mp = trmi.fullMatch(rtermi,res); 
        if (mp == null) 
        { return null; } 
      }     
    } 

    return res; 
  } 

  public java.util.Set allMathMetavariables()
  { java.util.Set res = new java.util.HashSet(); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm trm = (ASTTerm) terms.get(i); 
      java.util.Set mvs = trm.allMathMetavariables(); 
      res.addAll(mvs); 
    } 
    return res; 
  } 

  public Type deduceType()
  { if (terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.deduceType(); 
    } 

    if ("expression".equals(tag) && terms.size() >= 2 &&  
        "new".equals(terms.get(0) + "") && 
        ((ASTTerm) terms.get(1)).hasTag("creator"))
    { return deduceCreatorType(); } 

    return new Type("OclAny", null); 
  } 

  public Type deduceElementType()
  { if (terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.deduceElementType(); 
    } 

    if ("expression".equals(tag) && terms.size() >= 2 &&  
        "new".equals(terms.get(0) + "") && 
        ((ASTTerm) terms.get(1)).hasTag("creator"))
    { return deduceCreatorElementType(); } 

    return new Type("OclAny", null); 
  } 

  public Vector elementList()
  { Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm t = (ASTTerm) terms.get(i); 
      String ss = t.literalForm();
      if (",".equals(ss)) { } 
      else 
      { res.add(ss); }  
    } 
    return res; 
  } 

  private Type deduceCreatorType()
  { ASTTerm cre = (ASTTerm) terms.get(1); 
    // (createdName ...) (arrayCreatorRest ...)

    if (cre.getTerms().size() > 1 && 
        ((ASTTerm) cre.getTerm(1)).hasTag("arrayCreatorRest"))
    { Type res = new Type("Sequence", null); 
      return res; 
    } 

    // or an entity

    return new Type("OclAny", null); 
  } 

  private Type deduceCreatorElementType()
  { ASTTerm cre = (ASTTerm) terms.get(1); 
    // (createdName ...) (arrayCreatorRest ...)

    if (cre.getTerms().size() > 1 && 
        ((ASTTerm) cre.getTerm(1)).hasTag("arrayCreatorRest"))
    { ASTTerm arrayCreat = (ASTTerm) cre.getTerm(1); 
      if (arrayCreat.getTerms().size() == 3)
      { ASTTerm baseType = (ASTTerm) terms.get(0); 
        String actualType = baseType.toKM3type();
        return new Type(actualType, null); 
      }  
      Type res = new Type("Sequence", null); 
      return res; 
    } 

    // or an entity

    return new Type("OclAny", null); 
  } 

  public Vector identifyCFunctions(Entity sys, java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Processing program tag " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("compilationUnit".equals(tag))
    { ASTCompositeTerm rr = (ASTCompositeTerm) terms.get(0); 
      return rr.identifyCFunctions(
         sys, vartypes, varelemtypes, types, entities);
    } 

    if ("translationUnit".equals(tag))
    { Entity ent = new Entity("FromC");
      entities.add(ent); 
      ent.addStereotype("unsafe"); 

      for (int k = 0; k < terms.size(); k++) 
      { ASTCompositeTerm t = (ASTCompositeTerm) terms.get(k); 
        Vector mes = 
          t.identifyCFunctions(ent, vartypes, 
                           varelemtypes, types, entities); 
        if (mes == null) 
        { continue; } 

        for (int j = 0; j < mes.size(); j++) 
        { ModelElement me = (ModelElement) mes.get(j); 

          if (me instanceof BehaviouralFeature)
          { BehaviouralFeature bf = (BehaviouralFeature) me; 
            ent.refineOperation(bf);
            if (ent.hasAttribute(me.getName()))
            { ent.removeAttribute(me.getName()); }

            BehaviouralFeature actualop = 
                      ent.getOperation(me.getName()); 
            System.out.println(">> New operation: " + actualop.display()); 
 
            bf.setOwner(ent); 
          }
          else if (me instanceof Attribute)
          { Attribute att = (Attribute) me; 
            ent.addAttribute(att); 
            att.setStatic(true); 
            att.setEntity(ent);

            Expression init = att.getInitialExpression(); 
            if (att.isRef() && "0".equals(init + ""))
            { att.setInitialExpression(nullExpression); } 

            System.out.println(">> New global attribute: " + att.getKM3() + " " + att.getInitialExpression()); 

            vartypes.put(att.getName(), att.getType()); 
            varelemtypes.put(att.getName(), 
                             att.getElementType());  
          } 
        }
      } 
      Vector res = new Vector(); 
      res.add(ent);  
      return res;  
    } 

    if ("externalDeclaration".equals(tag))
    { ASTCompositeTerm term = (ASTCompositeTerm) terms.get(0); 
      return term.identifyCFunctions(sys, vartypes, 
                               varelemtypes, types, entities);
    } 
 
    if ("functionDefinition".equals(tag) && 
        terms.size() == 3)
    { // (functionDefinition dectype declarator code)
      ASTTerm typeTerm = (ASTTerm) terms.get(0); 
      ASTTerm declaratorTerm = 
                (ASTTerm) terms.get(1); 
      ASTCompositeTerm code = (ASTCompositeTerm) terms.get(2);
  
      Type typ = typeTerm.cdeclarationToType(
             vartypes, varelemtypes, types, entities);

      System.out.println(">> Function type = " + typ); 
      ModelElement bf = 
         typeTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities); 

      if (bf == null) 
      { bf =  
          declaratorTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities); 
      } 
      else 
      { ModelElement par = 
          declaratorTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities);
 
        if (par != null && par instanceof Attribute) 
        { bf.addParameter((Attribute) par); }  
      } 

      
      System.out.println(">> Function model element = " + bf + " " + bf.getParameters()); 

      // The function parameters are added to vartypes: 

      java.util.Map vtypes = new java.util.HashMap(); 
      java.util.Map vetypes = new java.util.HashMap(); 
      vtypes.putAll(vartypes); 
      vetypes.putAll(varelemtypes); 

      Vector prs = bf.getParameters(); 

      for (int p = 0; p < prs.size(); p++)
      { Attribute pr = (Attribute) prs.get(p); 
        String prnme = pr.getName(); 
        Type prtyp = pr.getType();

        System.out.println("*** Function model element par: " + 
              prnme + " : " + prtyp + " " + pr.getElementType()); 
 
        if (prtyp != null) 
        { vtypes.put(prnme, prtyp); 
          if (pr.getElementType() == null) 
          { pr.setElementType(prtyp.getElementType()); } 
          vetypes.put(prnme, prtyp.getElementType()); 
        } 
      } 

      Vector labelfunctions = 
               code.labelFunctions(vtypes,
                              vetypes,types,entities);


      Vector res = new Vector(); 
      if (bf instanceof BehaviouralFeature) 
      { BehaviouralFeature bfx = (BehaviouralFeature) bf; 
        bfx.setType(typ); 
        bfx.setPre(new BasicExpression(true)); 
        bfx.setPost(new BasicExpression(true)); 
        bfx.addStereotype("unsafe"); 
        bfx.setStatic(true); 
        bfx.setVarArgStereotype(bfx.getParameters()); 

        System.out.println(">>> Operation " + bfx.display()); 
        res.add(bfx);
      }   
      else if (bf instanceof Attribute)
      { BehaviouralFeature bfx = 
          BehaviouralFeature.fromAttribute((Attribute) bf); 
        bfx.setType(typ); 
        bfx.setPre(new BasicExpression(true)); 
        bfx.setPost(new BasicExpression(true)); 
        bfx.addStereotype("unsafe"); 
        bfx.setStatic(true); 
        bfx.setVarArgStereotype(bfx.getParameters()); 

        System.out.println(">>> Operation " + bfx.display()); 
        res.add(bfx);
      }   
      return res; 

    } 

    if ("declaration".equals(tag))
    { if (literalForm().startsWith("typedef"))
      { ASTCompositeTerm decspecifiers = 
          (ASTCompositeTerm) terms.get(0); 
        Vector decterms = decspecifiers.terms; 
        ASTTerm tdef = (ASTTerm) decterms.get(1); 
        ASTTerm tname = 
           (ASTTerm) decterms.get(decterms.size()-1); 
        String tnme = tname.literalForm(); 

        Type newt = tdef.cdeclarationToType(
          vartypes,varelemtypes,types,entities);
        Type mtt = new Type(tnme, null); 
        mtt.setAlias(newt);  
        System.out.println(">> New alias type: " + mtt + " " + newt);
        Vector res = new Vector(); 
        if (newt != null && newt.isEntity())
        { Entity ent = newt.getEntity(); 
          ent.setName(tnme); 
          Entity ex = 
            (Entity) ModelElement.lookupByName(tnme, entities); 
          if (ex == null) 
          { entities.add(entities.size()-1,ent); }
          res.add(newt);  
        }
        else 
        { Type tx = (Type) 
            ModelElement.lookupByName(tnme,types); 
          if (tx == null) 
          { types.add(mtt); } 
          res.add(mtt);
        } 
        return res;  
      } 

      if (terms.size() == 3)
      { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
        ASTTerm varSpec = (ASTTerm) terms.get(1); 
        Type t = typeSpec.cdeclarationToType(
                     vartypes,varelemtypes,types,entities);
        Vector mes = 
          varSpec.cdeclaratorToModelElements(
                  vartypes, varelemtypes, types, entities);

        System.out.println(">> Model elements: " + mes); 

        Vector res = new Vector(); 
        if (mes != null && mes.size() > 0) 
        { 
          for (int j = 0; j < mes.size(); j++) 
          { ModelElement me = (ModelElement) mes.get(j); 

            System.out.println(">>> Model element: " + me); 

            if (me != null && me instanceof Attribute) 
            { System.out.println(">> Global feature: " + me + " " + t + " " + me.getType());
              Type mttype = me.getType(); 
              Attribute att = (Attribute) me;
              Expression init = att.getInitialExpression(); 
 
              System.out.println(">> Initial value: " + init); 
              System.out.println(); 

              if (mttype != null && 
                  (mttype.isCollection() || 
                   mttype.isReference() ||
                   mttype.isFunctionType()))
              { mttype.setInnerElementType(t); 
                att.setElementType(mttype.getElementType()); 
              } 
              else 
              { att.setType(t); } 

              Type atttype = att.getType(); 

              vartypes.put(att.getName(), atttype); 
              varelemtypes.put(att.getName(), 
                               att.getElementType());  
        // System.out.println(mttype); 

              if ("null".equals(init + "") && 
                  att.isCollection())
              { att.setInitialExpression(
                        new SetExpression(true)); 
              } 
              else if (att.isEntityType())
              { Entity attent = atttype.getEntity(); 
                init = Entity.makeInitialisation(attent, init); 
                init.setType(atttype); 
                att.setInitialExpression(init);  
              } 
              else if (att.isEntityCollection())
              { Type attelemtype = atttype.getElementType(); 
                Entity attelement = attelemtype.getEntity(); 
                init = 
                  Entity.makeCollectionInitialisation(
                                         attelement,init); 
                init.setType(atttype); 
                att.setInitialExpression(init);  
              } 
              else if (att.isFunctionRef() ||
                       att.isRefRef() ||  
                       att.isCollectionRef())
              { init = new BasicExpression("null"); 
                init.setType(atttype); 
              } 
              // if a Ref and init is 0, change to null

              System.out.println(">>> Initialisation " + init);
              res.add(me);
            } 
          } 
          return res; 
        } 

        Vector results = new Vector(); 

        if (t != null && t.isEntity())
        { Entity newent = t.getEntity();
          if (ModelElement.lookupByName(newent.getName(), entities) == null) 
          { entities.add(entities.size()-1,newent); } 
          results.add(t); 
        } 
        else if (t != null && t.isEnumeration())
        { if (ModelElement.lookupByName(t.getName(), types) == null) 
          { types.add(t); }
          results.add(t); 
        } 
        return results; 
      } 
      
      System.out.println(">>> declaration with " + terms.size() + " terms: " + this); 

      Type t = cdeclarationToType(
          vartypes,varelemtypes,types,entities); 
      Vector mts = 
        cdeclaratorToModelElements(
            vartypes, varelemtypes, types, entities);

      Vector ures = new Vector(); 
      if (mts != null && mts.size() > 0) 
      { 
        for (int p = 0; p < mts.size(); p++) 
        { ModelElement mt = (ModelElement) mts.get(p); 

          if (mt != null && mt instanceof Attribute) 
          { System.out.println(">> Global feature: " + mt + " " + t + " " + mt.getType());
            Type mttype = mt.getType(); 
            Attribute att = (Attribute) mt; 
            System.out.println(">> Initial value: " + att.getInitialExpression()); 
            System.out.println(); 

            if (mttype != null && 
                (mttype.isCollection() || 
                 mttype.isReference() ||
                 mttype.isFunctionType()))
            { mttype.setInnerElementType(t); 
              att.setElementType(mttype.getElementType()); 
            } 

            vartypes.put(att.getName(), att.getType()); 
            varelemtypes.put(att.getName(), 
                             att.getElementType());  
        // System.out.println(mttype); 
            ures.add(mt);
          }
          return ures;  
        } 
      } 

      Vector xres = new Vector(); 

      if (t != null && t.isEntity())
      { Entity newent = t.getEntity();
        if (ModelElement.lookupByName(
                 newent.getName(), entities) == null) 
        { entities.add(entities.size()-1,newent); } 
        xres.add(t); 
      } 
      else if (t != null && t.isEnumeration())
      { if (ModelElement.lookupByName(t.getName(), types) == null) 
        { types.add(t); } 
        xres.add(t); 
      } 

      return xres; 
    } 
      

    return null; 
  } 

  public Vector cprogramToKM3(Entity sys, java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Processing program tag " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("compilationUnit".equals(tag))
    { ASTCompositeTerm rr = (ASTCompositeTerm) terms.get(0); 
      return rr.cprogramToKM3(
         sys, vartypes, varelemtypes, types, entities);
    } 

    if ("translationUnit".equals(tag))
    { Entity ent = (Entity) 
        ModelElement.lookupByName("FromC", entities); 
      if (ent == null) 
      { ent = new Entity("FromC"); 
        ent.addStereotype("unsafe"); 

        entities.add(ent); 
      }  

      for (int k = 0; k < terms.size(); k++) 
      { ASTCompositeTerm t = (ASTCompositeTerm) terms.get(k); 
        Vector mes = 
          t.cprogramToKM3(ent, vartypes, varelemtypes, types, entities); 
        if (mes == null) 
        { continue; } 

        for (int j = 0; j < mes.size(); j++) 
        { ModelElement me = (ModelElement) mes.get(j); 

          if (me instanceof BehaviouralFeature)
          { BehaviouralFeature bf = (BehaviouralFeature) me; 
            ent.refineOperation(bf);
            bf.setStatic(true); 

            if (ent.hasAttribute(me.getName()))
            { ent.removeAttribute(me.getName()); }

            BehaviouralFeature actualop = 
                      ent.getOperation(me.getName()); 
            System.out.println(">> New operation: " + actualop.display()); 
  
            bf.setOwner(ent); 
          }
          else if (me instanceof Attribute)
          { Attribute att = (Attribute) me; 
            ent.addAttribute(att); 
            att.setEntity(ent);
            att.setStatic(true); 

            Expression initexpr = 
              att.getInitialExpression(); 
            if (att.isRef() && "0".equals(initexpr + ""))
            { att.setInitialExpression(nullExpression); } 

            System.out.println(">> New global attribute: " + att.getKM3() + " " + att.getInitialExpression()); 

            vartypes.put(att.getName(), att.getType()); 
            varelemtypes.put(att.getName(), 
                             att.getElementType());  
          } 
        }
      } 
      Vector res = new Vector(); 
      res.add(ent);  
      return res;  
    } 

    if ("externalDeclaration".equals(tag))
    { ASTCompositeTerm term = (ASTCompositeTerm) terms.get(0); 
      return term.cprogramToKM3(sys, vartypes, 
                               varelemtypes, types, entities);
    } 
 
    if ("functionDefinition".equals(tag) && 
        terms.size() == 3)
    { // (functionDefinition dectype declarator code)
      ASTTerm typeTerm = (ASTTerm) terms.get(0); 
      ASTTerm declaratorTerm = 
                (ASTTerm) terms.get(1); 
      ASTCompositeTerm code = (ASTCompositeTerm) terms.get(2);
  
      Type typ = typeTerm.cdeclarationToType(
             vartypes, varelemtypes, types, entities);

      System.out.println(">> Function type = " + typ); 
      ModelElement bf = 
         typeTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities); 

      if (bf == null) 
      { bf =  
          declaratorTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities); 
      } 
      else 
      { ModelElement par = 
          declaratorTerm.cdeclaratorToModelElement(
             vartypes, varelemtypes, types, entities);
 
        if (par != null && par instanceof Attribute) 
        { bf.addParameter((Attribute) par); }  
      } 

      System.out.println(">> Function model element = " + bf + " " + bf.getParameters()); 

      // The function parameters are added to vartypes: 

      java.util.Map vtypes = new java.util.HashMap(); 
      java.util.Map vetypes = new java.util.HashMap(); 
      vtypes.putAll(vartypes); 
      vetypes.putAll(varelemtypes); 

      Vector prs = bf.getParameters(); 

      for (int p = 0; p < prs.size(); p++)
      { Attribute pr = (Attribute) prs.get(p); 
        String prnme = pr.getName(); 
        Type prtyp = pr.getType(); 

        System.out.println("*** Function model element par: " + 
              prnme + " : " + prtyp + " " + pr.getElementType()); 
 

        if (prtyp != null) 
        { vtypes.put(prnme, prtyp); 

          if (pr.getElementType() == null) 
          { pr.setElementType(prtyp.getElementType()); } 

          vetypes.put(prnme, prtyp.getElementType()); 
        } 
      } 

      Vector labelfunctions = 
               code.labelFunctions(vtypes,
                              vetypes,types,entities);


      Statement stat = code.cstatementToKM3(vtypes,
                              vetypes,types,entities); 

      System.out.println(">> Function code = " + stat); 

      Vector res = new Vector(); 
      if (bf instanceof BehaviouralFeature) 
      { BehaviouralFeature bfx = (BehaviouralFeature) bf; 
        bfx.setType(typ); 
        bfx.setActivity(stat); 
        bfx.setPre(new BasicExpression(true)); 
        bfx.setPost(new BasicExpression(true)); 
        bfx.addStereotype("unsafe"); 
        bfx.setVarArgStereotype(bfx.getParameters()); 
        bfx.setStatic(true); 

        System.out.println(">>> Operation from C function: " + bfx.display()); 
        res.add(bfx);
      }   
      else if (bf instanceof Attribute)
      { BehaviouralFeature bfx = 
          BehaviouralFeature.fromAttribute((Attribute) bf); 
        bfx.setType(typ); 
        bfx.setActivity(stat); 
        bfx.setPre(new BasicExpression(true)); 
        bfx.setPost(new BasicExpression(true)); 
        bfx.addStereotype("unsafe"); 
        bfx.setVarArgStereotype(bfx.getParameters()); 
        bfx.setStatic(true); 

        System.out.println(">>> Operation from attribute: " + bfx.display()); 
        res.add(bfx);
      }   

      return res; 
    } 

    if ("declaration".equals(tag))
    { if (literalForm().startsWith("typedef"))
      { ASTCompositeTerm decspecifiers = 
          (ASTCompositeTerm) terms.get(0); 
        Vector decterms = decspecifiers.terms; 
        ASTTerm tdef = (ASTTerm) decterms.get(1); 
        ASTTerm tname = 
           (ASTTerm) decterms.get(decterms.size()-1); 
        String tnme = tname.literalForm(); 

        Type newt = tdef.cdeclarationToType(
          vartypes,varelemtypes,types,entities);
        Type mtt = new Type(tnme, null); 
        mtt.setAlias(newt);  
        System.out.println(">> New alias type: " + mtt + " " + newt);
        Vector res = new Vector(); 
        if (newt != null && newt.isEntity())
        { Entity ent = newt.getEntity(); 
          ent.setName(tnme); 
          Entity ex = (Entity) ModelElement.lookupByName(tnme,
                                                  entities);
          if (ex == null) 
          { entities.add(entities.size()-1,ent); } 
          res.add(newt);  
        }
        else 
        { Type tx = (Type) ModelElement.lookupByName(tnme,
                                                  types);
          if (tx == null) 
          { types.add(mtt); } 
          res.add(mtt);
        } 
        return res;  
      } 

      if (terms.size() == 3)
      { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
        ASTTerm varSpec = (ASTTerm) terms.get(1); 
        Type t = typeSpec.cdeclarationToType(
                     vartypes,varelemtypes,types,entities);
        Vector mes = 
          varSpec.cdeclaratorToModelElements(
                  vartypes, varelemtypes, types, entities);

        System.out.println(">> Model elements: " + mes); 

        Vector res = new Vector(); 
        if (mes != null && mes.size() > 0) 
        { 
          for (int j = 0; j < mes.size(); j++) 
          { ModelElement me = (ModelElement) mes.get(j); 

            System.out.println(">>> Model element: " + me); 

            if (me != null && me instanceof Attribute) 
            { System.out.println(">> Global feature: " + me + " " + t + " " + me.getType());
              Type mttype = me.getType(); 
              Attribute att = (Attribute) me;
              Expression init = att.getInitialExpression(); 
 
              System.out.println(">> Initial value: " + init); 
              System.out.println(); 

              if (mttype != null && 
                  (mttype.isCollection() || 
                   mttype.isReference() ||
                   mttype.isFunctionType()))
              { mttype.setInnerElementType(t); 
                att.setElementType(mttype.getElementType()); 
              } 
              else 
              { att.setType(t); } 

              Type atttype = att.getType(); 

              vartypes.put(att.getName(), atttype); 
              varelemtypes.put(att.getName(), 
                               att.getElementType());  
        // System.out.println(mttype); 

              if ("null".equals(init + "") && 
                  att.isCollection())
              { att.setInitialExpression(
                        new SetExpression(true)); 
              } 
              else if (att.isEntityType())
              { Entity attent = atttype.getEntity(); 
                init = Entity.makeInitialisation(attent, init); 
                init.setType(atttype); 
                att.setInitialExpression(init);  
              } 
              else if (att.isEntityCollection())
              { Type attelemtype = atttype.getElementType(); 
                Entity attelement = attelemtype.getEntity(); 
                init = 
                  Entity.makeCollectionInitialisation(
                                         attelement,init); 
                init.setType(atttype); 
                att.setInitialExpression(init);  
              } 
              else if (att.isFunctionRef() ||
                       att.isRefRef() ||   
                       att.isCollectionRef())
              { init = new BasicExpression("null"); 
                init.setType(atttype); 
              } 


              System.out.println(">>> Initialisation " + init);
              res.add(me);
            } 
          } 
          return res; 
        } 

        Vector results = new Vector(); 

        if (t != null && t.isEntity())
        { Entity newent = t.getEntity();
          if (ModelElement.lookupByName(newent.getName(), entities) == null) 
          { entities.add(entities.size()-1,newent); } 
          results.add(t); 
        } 
        else if (t != null && t.isEnumeration())
        { Type tx = 
           (Type) ModelElement.lookupByName(t.getName(), types); 
          if (tx == null) 
          { types.add(t); } 
          results.add(t); 
        } 
        return results; 
      } 
      
      System.out.println(">>> declaration with " + terms.size() + " terms: " + this); 

      Type t = cdeclarationToType(
          vartypes,varelemtypes,types,entities); 
      Vector mts = 
        cdeclaratorToModelElements(
            vartypes, varelemtypes, types, entities);

      Vector ures = new Vector(); 
      if (mts != null && mts.size() > 0) 
      { 
        for (int p = 0; p < mts.size(); p++) 
        { ModelElement mt = (ModelElement) mts.get(p); 

          if (mt != null && mt instanceof Attribute) 
          { System.out.println(">> Global feature: " + mt + " " + t + " " + mt.getType());
            Type mttype = mt.getType(); 
            Attribute att = (Attribute) mt; 
            System.out.println(">> Initial value: " + att.getInitialExpression()); 
            System.out.println(); 

            if (mttype != null && 
                (mttype.isCollection() || 
                 mttype.isReference() ||
                 mttype.isFunctionType()))
            { mttype.setInnerElementType(t); 
              att.setElementType(mttype.getElementType()); 
            } 

            vartypes.put(att.getName(), att.getType()); 
            varelemtypes.put(att.getName(), 
                             att.getElementType());  
        // System.out.println(mttype); 
            ures.add(mt);
          }
          return ures;  
        } 
      } 

      Vector xres = new Vector(); 

      if (t != null && t.isEntity())
      { Entity newent = t.getEntity();
        if (ModelElement.lookupByName(
                 newent.getName(), entities) == null) 
        { entities.add(entities.size()-1,newent); } 
        xres.add(t); 
      } 
      else if (t != null && t.isEnumeration())
      { Type tx = (Type) ModelElement.lookupByName(t.getName(), types); 
        if (tx == null) 
        { types.add(t); } 
        xres.add(t); 
      } 

      return xres; 
    } 
      

    return null; 
  } 

  public ModelElement cdeclaratorToModelElement(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Declarator to ModelElement " + tag + 
                       " with " + terms.size() + " terms"); 
    System.out.println();

    if ("declaration".equals(tag) && terms.size() == 3)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
             vartypes,varelemtypes,types,entities);
      ASTTerm varSpec = (ASTTerm) terms.get(1); 
      ModelElement me = 
        varSpec.cdeclaratorToModelElement(
            vartypes,varelemtypes,types,entities);

      // System.out.println(att + " type = " + att.getType() + " " + typ); 

      if (me == null) 
      { return null; } 

      Attribute att; 
      if (me instanceof BehaviouralFeature)
      { att = Attribute.fromOperation((BehaviouralFeature) me); } 
      else if (me instanceof Attribute) 
      { att = (Attribute) me; } 
      else 
      { return null; } 

      Type atttype = att.getType(); 
        
      if (att.isCollection() || att.isReferenceType() || 
          att.isFunctionType())
      { // att.setInnerElementType(typ); 
        atttype.setInnerElementType(typ);
        att.setElementType(atttype.getElementType());  
      } 
      else if (typ != null) 
      { att.setType(typ);
        att.setElementType(typ.getElementType()); 
      }

      System.out.println(">> Attribute " + att + " type = " + att.getType() + " " + att.getElementType()); 
      
      atttype = att.getType();

      Expression init = varSpec.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      if (init != null) 
      { // BasicExpression lhs = new BasicExpression(att);

        if ("null".equals(init + "") && 
            att.isCollection())
        { init = new SetExpression(true); } 
        else if (att.isEntityType())
        { Entity attent = atttype.getEntity(); 
          init = Entity.makeInitialisation(attent, init); 
          System.out.println(">>> object initialisation " + init);
        } 
        else if (att.isEntityCollection())
        { Type attelemtype = atttype.getElementType(); 
          Entity attelement = attelemtype.getEntity(); 
          init = 
            Entity.makeCollectionInitialisation(
                                         attelement,init); 
          System.out.println(">>> object initialisation " + init);
        } 

        init.setType(atttype); 
        att.setInitialExpression(init); 
      } 

      System.out.println(">> Initial expression: " + init); 

      return att; 
    } 

    if ("declaration".equals(tag) && terms.size() == 2)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
             vartypes,varelemtypes,types,entities);
  
      ModelElement me = 
        typeSpec.cdeclaratorToModelElement(
            vartypes,varelemtypes,types,entities);

      if (me == null) 
      { return typ; } 

      Attribute att; 
      if (me instanceof BehaviouralFeature)
      { att = Attribute.fromOperation((BehaviouralFeature) me); } 
      else if (me instanceof Attribute) 
      { att = (Attribute) me; } 
      else 
      { return null; } 

      Type atttype = att.getType(); 
        
      if (att.isCollection() || att.isReferenceType() || 
          att.isFunctionType())
      { // att.setInnerElementType(typ); 
        atttype.setInnerElementType(typ);
        att.setElementType(atttype.getElementType());  
      } 
      else if (typ != null) 
      { att.setType(typ);
        att.setElementType(typ.getElementType()); 
      }

      System.out.println(">> Uninitialised attribute " + att + " type = " + att.getType() + " " + att.getElementType()); 

      atttype = att.getType(); 
      if (atttype != null)
      { Expression init = atttype.getDefaultValueExpression(); 
        System.out.println(">>> Initialisation: " + init); 
        att.setInitialExpression(init); 
      } 

 
      return att; 
    } // Could be an uninitialised attribute. 

    if ("initDeclaratorList".equals(tag))
    { Vector mes = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (",".equals(tt.literalForm())) 
        { continue; } 
        ModelElement me = tt.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);
        if (me != null) 
        { mes.add(me); } 
      } 
      // System.out.println(">> Multiple variables: " + mes); 
      if (mes.size() == 0) 
      { return null; } 
      return (ModelElement) mes.get(0); 
    } // Several variables can be defined here. 

    if ("initDeclarator".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0);
      ModelElement xme = tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
      if (terms.size() > 2) 
      { ASTTerm initterm = (ASTTerm) terms.get(2);

        System.out.println(">>> Declarator initialisation: " + initterm); 
 
        Expression iexpr = 
           initterm.cexpressionToKM3(
                vartypes, varelemtypes, types, entities);

        System.out.println(">>> Initial value of " + xme + 
                           " is " + iexpr); 

        if (xme instanceof Attribute) 
        { ((Attribute) xme).setInitialExpression(iexpr); } 
      } 
      return xme; 
    }
    

    if ("declarator".equals(tag))
    { if (terms.size() == 1)
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        return tt.cdeclaratorToModelElement(
            vartypes,varelemtypes,types,entities); 
      } 
      else if (terms.size() > 1)
      { // (pointer ...) (directDeclarator ...)
        ASTTerm pt = (ASTTerm) terms.get(0); 
        ASTTerm tt = (ASTTerm) terms.get(1); 
        ModelElement me = tt.cdeclaratorToModelElement( 
                       vartypes,varelemtypes,types,entities);
        if (pt.hasTag("pointer"))
        { System.out.println(">> Pointers: " + pt.arity() + 
                             " " + pt.literalForm()); 

          Type met = me.getType(); 
          Type newtype = pt.pointersToRefType(met.getName(), 
                                              met); 
          // newtype.setInnerElementType(met); 
          me.setType(newtype); 
          return me; 
        } // maybe multiple pointers
        return me;  
      } 
    } 

    if ("directDeclarator".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { System.out.println(">> DD term " + i + " = " + terms.get(i)); }


      if (terms.size() == 1) 
      { String nme = ((ASTTerm) terms.get(0)).literalForm(); 
        return new Attribute(nme,new Type("OclAny", null), 
                             ModelElement.INTERNAL); 
      } 
      else if (terms.size() == 3 && 
               "(".equals(terms.get(0) + "") && 
               ")".equals(terms.get(2) + ""))
      { // ( dec ) for function
        ASTTerm rr = (ASTTerm) terms.get(1); 
        ModelElement me = rr.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);
        return me;  
      } 
      else if (terms.size() == 3 && 
               "(".equals(terms.get(1) + "") && 
               ")".equals(terms.get(2) + ""))
      { // Function with void parameter
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        ModelElement me = t0.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);

        String fnme = t0.literalForm();
        if (me != null) 
        { fnme = me.getName(); } 

        if (me instanceof Attribute && me.getType() != null) 
        { Attribute att = (Attribute) me; 
          att.setParameters(new Vector()); 
          Type typ = att.getType(); 
          Type ftype = new Type("Function", null); 
          ftype.setKeyType(new Type("void", null)); 
          ftype.setElementType(new Type("void", null)); 

          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype); 
          } 
          return att; 
        } 

        BehaviouralFeature bf = new BehaviouralFeature(fnme);
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
 
        bf.setParameters(new Vector()); 

        System.out.println(">> Operation " + bf.display()); 

        return bf; 
      } 
      else if (terms.size() == 4 && 
               "(".equals(terms.get(1) + "") && 
               ")".equals(terms.get(3) + ""))
      { // Function with parameters
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        ModelElement me = t0.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);

        String fnme = t0.literalForm();
        if (me != null) 
        { fnme = me.getName(); } 

        ASTTerm tt = (ASTTerm) terms.get(2); 
        Vector pars = tt.cparameterListToKM3(
                        vartypes,varelemtypes,types,entities);

        if (me instanceof Attribute && me.getType() != null) 
        { Attribute att = (Attribute) me; 
          att.setParameters(pars); 
          Type typ = att.getType(); 
          // Type ftype = new Type("Function", null);
          Type dtype = parametersToFunctionType(pars);  
          // ftype.setKeyType(dtype); 
          // ftype.setElementType(new Type("void", null)); 

          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(dtype); } 
          else 
          { typ.setInnerElementType(dtype); 
            // att.setInnerElementType(ftype); 
          } 

          System.out.println(">> Function-typed attribute " + att + " " + att.getType()); 
          return att; 
        } 

 
        BehaviouralFeature bf = new BehaviouralFeature(fnme);
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
 
        bf.setParameters(pars); 
        bf.setVarArgStereotype(pars); 

        return bf; 
      } 
      else if (terms.size() == 3 && 
               "[".equals(terms.get(1) + "") && 
               "]".equals(terms.get(2) + ""))
      { // array of unspecified size
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        String anme = t0.literalForm();

        ModelElement me = t0.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 

        if (me instanceof Attribute && 
            me.getType() != null) 
        { Attribute att = (Attribute) me;
          Type typ = att.getType(); 
          Type ftype = new Type("Sequence", null);
  
          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype);
          } 
 
          System.out.println(">> Sequence attribute " + att + " " + att.getType());
          att.setInitialExpression(new SetExpression(true)); 
          System.out.println(); 
          return att; 
        } 

        return new Attribute(anme,new Type("Sequence", null), 
                             ModelElement.INTERNAL); 
      } 
      else if (terms.size() == 4 && 
               "[".equals(terms.get(1) + "") && 
               "]".equals(terms.get(3) + ""))
      { // array of size terms.get(2)
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        
        String anme = t0.literalForm();

        ModelElement me = t0.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 

        if (me instanceof Attribute && 
            me.getType() != null) 
        { Attribute att = (Attribute) me;
          Type typ = att.getType(); 
          Type ftype = new Type("Sequence", null);
  
          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype);
          } 
 
          System.out.println(">> Sequence attribute " + att + " " + att.getType());
          return att; 
        } 

        System.out.println(">> Sequence attribute " + anme); 

        return new Attribute(anme,new Type("Sequence", null), 
                             ModelElement.INTERNAL); 
      } 
      else if (terms.size() == 5 && 
               "(".equals(terms.get(0) + "") && 
               ")".equals(terms.get(4) + ""))
      { // ERROR in the grammar
        ASTCompositeTerm c = 
          new ASTCompositeTerm("parameterDeclaration"); 
        c.addTerm((ASTTerm) terms.get(1)); 
        c.addTerm((ASTTerm) terms.get(2)); 
        c.addTerm((ASTTerm) terms.get(3)); 
        return c.cparameterToKM3(
           vartypes,varelemtypes,types,entities); 
      }
    }

    if ("declarationSpecifiers".equals(tag))
    { /* for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTCompositeTerm)
        { ASTCompositeTerm trm = (ASTCompositeTerm) tt; 
          ModelElement typ = trm.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 
          if (typ != null) 
          { return typ; } 
        } 
      }
      */ 

      // The model element if any is the last term: 

      ASTTerm tt = (ASTTerm) terms.get(terms.size()-1); 
      if (tt instanceof ASTCompositeTerm)
      { ASTCompositeTerm trm = (ASTCompositeTerm) tt; 
        ModelElement typ = trm.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 
        if (typ != null) 
        { return typ; } 
      } 
        
    }

    if ("declarationSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("typeSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
            vartypes,varelemtypes,types,entities); 
    } 

    if ("typedefName".equals(tag))
    { String nme = ((ASTTerm) terms.get(0)).literalForm();
      Entity tent = (Entity) ModelElement.lookupByName(nme, entities); 
      if (tent != null) 
      { return new Type(tent); } 
      Type typ = (Type) ModelElement.lookupByName(nme,types);
      if (typ != null) 
      { return typ; } 
      return new Attribute(nme, new Type("OclAny", null), 
                           ModelElement.INTERNAL); 
    } 

    if ("structDeclaration".equals(tag) && terms.size() < 3)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclaration".equals(tag) && terms.size() == 3)
    { ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclaratorList".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclarator".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("specifierQualifierList".equals(tag) && 
        terms.size() > 1)
    { ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("specifierQualifierList".equals(tag) && 
        terms.size() == 1)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
    } 

    return null; 
  } 

  public Vector cdeclaratorToModelElements(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Declarator to ModelElements " + tag + 
                       " with " + terms.size() + " terms"); 
    System.out.println();

    if ("declaration".equals(tag) && terms.size() == 3)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
             vartypes,varelemtypes,types,entities);
      ASTTerm varSpec = (ASTTerm) terms.get(1); 
      Vector mes = 
        varSpec.cdeclaratorToModelElements(
            vartypes,varelemtypes,types,entities);

      // System.out.println(att + " type = " + att.getType() + " " + typ); 

      if (mes == null) 
      { return null; } 

      Vector results = new Vector(); 

      for (int k = 0; k < mes.size(); k++) 
      { ModelElement me = (ModelElement) mes.get(k); 
        Attribute att; 
        if (me instanceof BehaviouralFeature)
        { att = Attribute.fromOperation((BehaviouralFeature) me); } 
        else if (me instanceof Attribute) 
        { att = (Attribute) me; } 
        else 
        { continue; } 

        Type atttype = att.getType(); 
        
        if (att.isCollection() || att.isReferenceType() || 
            att.isFunctionType())
        { // att.setInnerElementType(typ); 
          atttype.setInnerElementType(typ);
          att.setElementType(atttype.getElementType());  
        } 
        else if (typ != null) 
        { att.setType(typ);
          att.setElementType(typ.getElementType()); 
        }

        System.out.println(">> Attribute " + att + " type = " + att.getType() + " " + att.getElementType()); 
 
        atttype = att.getType();

        Expression init = varSpec.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
        if (init != null) 
        { // BasicExpression lhs = new BasicExpression(att);

          if ("null".equals(init + "") && 
              att.isCollection())
          { init = new SetExpression(true); } 
          else if (att.isEntityType())
          { Entity attent = atttype.getEntity(); 
            init = Entity.makeInitialisation(attent, init); 
            System.out.println(">>> object initialisation " + init);
          } 
          else if (att.isEntityCollection())
          { Type attelemtype = atttype.getElementType(); 
            Entity attelement = attelemtype.getEntity(); 
            init = 
               Entity.makeCollectionInitialisation(
                                         attelement,init); 
            System.out.println(">>> object initialisation " + init);
            att.setInitialExpression(init);  
          } 
           
          init.setType(atttype); 
 
          System.out.println(">>> Initialisation: " + init); 

          att.setInitialExpression(init); 
        } 
        results.add(att);
      } 
      return results;  
    } 

    if ("declaration".equals(tag) && terms.size() == 2)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
             vartypes,varelemtypes,types,entities);
  
      Vector mes = 
        typeSpec.cdeclaratorToModelElements(
            vartypes,varelemtypes,types,entities);

      Vector results = new Vector(); 

      if (mes == null) 
      { results.add(typ);
        return results;
      } 


      for (int k = 0; k < mes.size(); k++) 
      { ModelElement me = (ModelElement) mes.get(k); 
        Attribute att; 
        if (me instanceof BehaviouralFeature)
        { att = Attribute.fromOperation((BehaviouralFeature) me); } 
        else if (me instanceof Attribute) 
        { att = (Attribute) me; } 
        else 
        { continue; } 

        Type atttype = att.getType(); 
          
        if (att.isCollection() || att.isReferenceType() || 
            att.isFunctionType())
        { // att.setInnerElementType(typ); 
          atttype.setInnerElementType(typ);
          att.setElementType(atttype.getElementType());  
        } 
        else if (typ != null) 
        { att.setType(typ);
          att.setElementType(typ.getElementType()); 
        }

        System.out.println(">> Uninitialised attribute " + att + " type = " + att.getType() + " " + att.getElementType()); 

        atttype = att.getType(); 
        if (atttype != null)
        { Expression init = atttype.getDefaultValueExpression(); 
          System.out.println(">>> Initialisation: " + init); 
          att.setInitialExpression(init); 
        } 
     
        results.add(att); 
      } 
      return results; 
    } // Could be an uninitialised attribute. 

    if ("initDeclaratorList".equals(tag))
    { Vector mes = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (",".equals(tt.literalForm())) 
        { continue; } 
        ModelElement nme = tt.cdeclaratorToModelElement(
                        vartypes,varelemtypes,types,entities);
        if (nme != null) 
        { mes.add(nme); }
        System.out.println(">> Model element: " + nme);  
      } 
      System.out.println(">> Multiple variables from initDeclaratorList: " + mes); 
      // if (mes.size() == 0) 
      // { return null; } 
      return mes; 
    } // Several variables can be defined here. 

    if ("initDeclarator".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0);
      ModelElement xme = tt.cdeclaratorToModelElement(
         vartypes,varelemtypes,types,entities); 
      if (terms.size() > 2) 
      { ASTTerm initterm = (ASTTerm) terms.get(2); 
        Expression iexpr = 
           initterm.cexpressionToKM3(
                vartypes, varelemtypes, types, entities);

        System.out.println(">>> Initial value of " + xme + 
                           " is " + iexpr); 

        if (xme instanceof Attribute) 
        { ((Attribute) xme).setInitialExpression(iexpr); } 
      } 
      Vector res = new Vector(); 
      res.add(xme);
      return res;  
    }
    

    if ("declarator".equals(tag))
    { if (terms.size() == 1)
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        return tt.cdeclaratorToModelElements(
            vartypes,varelemtypes,types,entities); 
      } 
      else if (terms.size() > 1)
      { // (pointer ...) (directDeclarator ...)
        ASTTerm pt = (ASTTerm) terms.get(0); 
        ASTTerm tt = (ASTTerm) terms.get(1); 
        ModelElement me = tt.cdeclaratorToModelElement( 
                    vartypes,varelemtypes,types,entities);
        if (pt.hasTag("pointer"))
        { Type met = me.getType(); 
          Type newtype = pt.pointersToRefType(met.getName(), 
                                              met); 
          // newtype.setInnerElementType(met); 
          me.setType(newtype); 
        } // maybe multiple pointers
        Vector res = new Vector(); 
        res.add(me);
        return res;  
      } 
    } 

    if ("directDeclarator".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { System.out.println(">> DD term " + i + " = " + terms.get(i)); }


      if (terms.size() == 1) 
      { String nme = ((ASTTerm) terms.get(0)).literalForm(); 
        Attribute attr =
           new Attribute(nme,new Type("OclAny", null), 
                             ModelElement.INTERNAL);
        Vector res = new Vector(); 
        res.add(attr);
        return res; 
      } 
      else if (terms.size() == 3 && 
               "(".equals(terms.get(0) + "") && 
               ")".equals(terms.get(2) + ""))
      { // ( dec ) for function
        ASTTerm rr = (ASTTerm) terms.get(1); 
        ModelElement me = rr.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);
        Vector res = new Vector(); 
        res.add(me);
        return res;  
      } 
      else if (terms.size() == 3 && 
               "(".equals(terms.get(1) + "") && 
               ")".equals(terms.get(2) + ""))
      { // Function with void parameter
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        ModelElement me = t0.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);

        String fnme = t0.literalForm();
        if (me != null) 
        { fnme = me.getName(); } 

        if (me instanceof Attribute && me.getType() != null) 
        { Attribute att = (Attribute) me; 
          att.setParameters(new Vector()); 
          Type typ = att.getType(); 
          Type ftype = new Type("Function", null); 
          ftype.setKeyType(new Type("void", null)); 
          ftype.setElementType(new Type("void", null)); 

          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype); 
          } 
          Vector res = new Vector(); 
          res.add(att);
          return res; 
        } 

        BehaviouralFeature bf = new BehaviouralFeature(fnme);
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
 
        bf.setParameters(new Vector()); 

        System.out.println(">> Operation " + bf.display()); 
        Vector res = new Vector(); 
        res.add(bf);
        return res; 
      } 
      else if (terms.size() == 4 && 
               "(".equals(terms.get(1) + "") && 
               ")".equals(terms.get(3) + ""))
      { // Function with parameters
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        ModelElement me = t0.cdeclaratorToModelElement(
                  vartypes,varelemtypes,types,entities);

        String fnme = t0.literalForm();
        if (me != null) 
        { fnme = me.getName(); } 

        ASTTerm tt = (ASTTerm) terms.get(2); 
        Vector pars = tt.cparameterListToKM3(
                        vartypes,varelemtypes,types,entities);

        if (me instanceof Attribute && me.getType() != null) 
        { Attribute att = (Attribute) me; 
          att.setParameters(pars); 
          Type typ = att.getType(); 
          // Type ftype = new Type("Function", null);
          Type dtype = parametersToFunctionType(pars);  
          // ftype.setKeyType(dtype); 
          // ftype.setElementType(new Type("void", null)); 

          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(dtype); } 
          else 
          { typ.setInnerElementType(dtype); 
            // att.setInnerElementType(ftype); 
          } 

          System.out.println(">> Function-typed attribute " + att + " " + att.getType()); 
          Vector res = new Vector(); 
          res.add(att);
          return res;
        } 

 
        BehaviouralFeature bf = new BehaviouralFeature(fnme);
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
 
        bf.setParameters(pars); 
        bf.setVarArgStereotype(pars); 

        Vector res = new Vector(); 
        res.add(bf);
        return res; 
      } 
      else if (terms.size() == 3 && 
               "[".equals(terms.get(1) + "") && 
               "]".equals(terms.get(2) + ""))
      { // array of unspecified size
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        String anme = t0.literalForm();

        ModelElement me = t0.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 

        if (me instanceof Attribute && 
            me.getType() != null) 
        { Attribute att = (Attribute) me;
          Type typ = att.getType(); 
          Type ftype = new Type("Sequence", null);
  
          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype);
          } 
 
          System.out.println(">> Sequence attribute " + att + " " + att.getType());
          System.out.println(); 
          Vector res = new Vector(); 
          res.add(att);
          return res; 
        } 

        Attribute natt = 
          new Attribute(anme,new Type("Sequence", null), 
                             ModelElement.INTERNAL);
        Vector res = new Vector(); 
        res.add(natt);
        return res; 
      } 
      else if (terms.size() == 4 && 
               "[".equals(terms.get(1) + "") && 
               "]".equals(terms.get(3) + ""))
      { // array of size terms.get(2)
        ASTTerm t0 = (ASTTerm) terms.get(0); 
        
        String anme = t0.literalForm();

        ModelElement me = t0.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 

        if (me instanceof Attribute && 
            me.getType() != null) 
        { Attribute att = (Attribute) me;
          Type typ = att.getType(); 
          Type ftype = new Type("Sequence", null);
  
          String tname = typ.getName(); 
          if ("OclAny".equals(tname) || "void".equals(tname))
          { att.setType(ftype); } 
          else 
          { typ.setInnerElementType(ftype); 
            // att.setInnerElementType(ftype);
          } 
 
          System.out.println(">> Sequence attribute " + att + " " + att.getType());
          Vector res = new Vector(); 
          res.add(att);
          return res; 
        } 

        System.out.println(">> Sequence attribute " + anme); 

        Attribute natt =
          new Attribute(anme,new Type("Sequence", null), 
                             ModelElement.INTERNAL); 
        Vector res = new Vector(); 
        res.add(natt);
        return res;
      } 
      else if (terms.size() == 5 && 
               "(".equals(terms.get(0) + "") && 
               ")".equals(terms.get(4) + ""))
      { // ERROR in the grammar
        ASTCompositeTerm c = 
          new ASTCompositeTerm("parameterDeclaration"); 
        c.addTerm((ASTTerm) terms.get(1)); 
        c.addTerm((ASTTerm) terms.get(2)); 
        c.addTerm((ASTTerm) terms.get(3)); 
        ModelElement me = c.cparameterToKM3(
           vartypes,varelemtypes,types,entities);
        Vector res = new Vector(); 
        res.add(me);
        return res; 
      }
    }

    if ("declarationSpecifiers".equals(tag))
    { /* for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTCompositeTerm)
        { ASTCompositeTerm trm = (ASTCompositeTerm) tt; 
          ModelElement typ = trm.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 
          if (typ != null) 
          { return typ; } 
        } 
      }
      */ 

      // The model element if any is the last term: 

      ASTTerm tt = (ASTTerm) terms.get(terms.size()-1); 
      if (tt instanceof ASTCompositeTerm)
      { Vector res = new Vector();
        ASTCompositeTerm trm = (ASTCompositeTerm) tt; 
        ModelElement typ = trm.cdeclaratorToModelElement(
                vartypes,varelemtypes,types,entities); 
        if (typ != null) 
        { res.add(typ); }
        return res;  
      } 
        
    }

    if ("declarationSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("typeSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
            vartypes,varelemtypes,types,entities); 
    } 

    if ("typedefName".equals(tag))
    { String nme = ((ASTTerm) terms.get(0)).literalForm();
      Vector res = new Vector(); 
      Attribute tatt = 
        new Attribute(nme, new Type("OclAny", null), 
                           ModelElement.INTERNAL); 
      res.add(tatt); 
      return res; 
    } 

    if ("structDeclaration".equals(tag) && terms.size() < 3)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclaration".equals(tag) && terms.size() == 3)
    { ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclaratorList".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("structDeclarator".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("specifierQualifierList".equals(tag) && 
        terms.size() > 1)
    { ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    if ("specifierQualifierList".equals(tag) && 
        terms.size() == 1)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclaratorToModelElements(
         vartypes,varelemtypes,types,entities); 
    } 

    return null; 
  } 


  public Type pointersToRefType(String tname, Type basetype)
  { Type typ = basetype; 
    for (int i = 0; i < terms.size(); i++) 
    { if ("*".equals(terms.get(i) + ""))
      {  
        if ("char".equals(tname))
        { typ = new Type("String", null); 
          basetype = typ;  
        } 
        else if ("FILE".equals(tname))
        { typ = new Type("OclFile", null); 
          basetype = typ; 
        }
        else 
        { typ = new Type("Ref", null); 
          typ.setElementType(basetype); 
          basetype = typ;
        }  
        tname = ""; // Ignored after 1st pointer
      } 
    } 
    return typ; 
  }


  public Vector structDeclarationToFeatures(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { if ("structDeclarationList".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i);

        System.out.println(">> Processing struct declaration " + trm); 
 
        Type t = trm.cdeclarationToType(
           vartypes,varelemtypes,types,entities); 
        ModelElement me = 
           trm.cdeclaratorToModelElement(
             vartypes,varelemtypes,types,entities);

        if (me == null) 
        { continue; } 

        Attribute att = null; 

        if (me instanceof BehaviouralFeature)
        { att = Attribute.fromOperation((BehaviouralFeature) me); 
        } 
        else if (me instanceof Attribute) 
        { att = (Attribute) me; } 
 
        if (att != null && 
            (att.isCollection() || att.isReferenceType() ||
             att.isFunctionType()))
        { Type tt = att.getType(); 
          tt.setInnerElementType(t); 
          att.setElementType(tt.getElementType()); 
        } 
        else if (att != null)
        { att.setType(t); 
          if (t != null) 
          { att.setElementType(t.getElementType()); }
        } 
         
        if (att != null)
        { Type atttype = att.getType(); 
          if (atttype != null)
          { Expression init = atttype.getDefaultValueExpression(); 
            System.out.println(">>> Initialisation: " + init); 
            att.setInitialExpression(init); 
          } 

          System.out.println(">>> Struct member " + att + 
                             " type= " + att.getType() + 
                             " elementType= " + 
                             att.getElementType()); 
          res.add(att); 
        }  
      } 

      return res; 
    } 
    return null; 
  } 

  public Type cdeclarationToType(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> cdeclaration to type: " + tag + " " + terms.size()); 

    if ("declaration".equals(tag) && terms.size() == 3)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
         vartypes,varelemtypes,types,entities);
      return typ; 
    } 

    if ("declaration".equals(tag) && terms.size() == 2)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
               vartypes,varelemtypes,types,entities);
      return typ; 
    } 

    if ("declarationSpecifiers2".equals(tag))
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
              vartypes,varelemtypes,types,entities);
      return typ; 
    } 

    if ("declarationSpecifiers".equals(tag))
    { Vector typs = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTCompositeTerm)
        { ASTCompositeTerm trm = (ASTCompositeTerm) tt; 
          Type typ = trm.cdeclarationToType(
             vartypes,varelemtypes,types,entities); 
          if (typ != null) 
          { typs.add(typ); } 
        } 
      }

      if (typs.size() > 0)
      { return (Type) typs.get(typs.size()-1); } 
    }

    if ("declarationSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclarationToType(
          vartypes,varelemtypes,types,entities); 
    } 

    if ("typeSpecifier".equals(tag) && terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0);

      if (t1.hasTag("structOrUnionSpecifier"))
      { return t1.cdeclarationToType(
            vartypes,varelemtypes,types,entities); 
      } 

      if (t1.hasTag("enumSpecifier"))
      { return t1.cdeclarationToType(
            vartypes, varelemtypes, types, entities); 
      } 
      
 
      String tname = t1.literalForm(); 

      if ("char".equals(tname) || "short".equals(tname) || 
          "va_list".equals(tname))
      { return new Type("int", null); }

      if ("_Bool".equals(tname))
      { return new Type("boolean",null); }  

      if ("time_t".equals(tname) || "clock_t".equals(tname) ||
          "size_t".equals(tname) || "fpos_t".equals(tname))
      { return new Type("long",null); }  

      if ("float".equals(tname))
      { return new Type("double", null); } 

      if ("int".equals(tname) || "long".equals(tname) || 
          "double".equals(tname) || "void".equals(tname))
      { return new Type(tname,null); }
 
      if ("div_t".equals(tname) || "ldiv_t".equals(tname) || 
          "tm".equals(tname))
      { Entity entx = 
          ASTTerm.introduceCStruct(tname,entities); 
        if (entx != null)
        { return new Type(entx); } 
      } 

      Type t = (Type) ModelElement.lookupByName(tname,types); 
      if (t != null) 
      { return t; } 

      return t1.cdeclarationToType(
          vartypes,varelemtypes,types,entities); 
    } 

    if ("typeSpecifier".equals(tag) && terms.size() > 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      ASTTerm t2 = (ASTTerm) terms.get(1);
      String tname = t1.literalForm(); 
      Type baseType = t1.cdeclarationToType(
             vartypes,varelemtypes,types,entities);  

      if ("*".equals(t2.literalForm()))
      { if ("char".equals(tname))
        { return new Type("String", null); } 
        if ("FILE".equals(tname))
        { return new Type("OclFile", null); } 

        System.out.println(">> Pointer type Ref(" + baseType + ")"); 

        if (baseType != null) 
        { Type res = new Type("Ref",null); 
          res.setElementType(baseType); 
          return res; 
        } 
        else 
        { Type res = new Type("Ref",null); 
          return res; 
        } 
      } 
      else if ("**".equals(t2.literalForm()) || 
               "* *".equals(t2.literalForm()))
      { if ("char".equals(tname))
        { Type tstring = new Type("String", null); 
          Type reftype = new Type("Ref", null); 
          reftype.setElementType(tstring); 
          return reftype; 
        } 
        if ("FILE".equals(tname))
        { Type tstring = new Type("OclFile", null); 
          Type reftype = new Type("Ref", null); 
          reftype.setElementType(tstring); 
          return reftype; 
        } 

        System.out.println(">> Pointer type Ref(Ref(" + baseType + ")"); 

        if (baseType != null) 
        { Type res = new Type("Ref",null); 
          res.setElementType(baseType);
          Type refres = new Type("Ref", null); 
          refres.setElementType(res);  
          return refres; 
        } 
        else 
        { Type res = new Type("Ref",null); 
          Type refres = new Type("Ref", null); 
          refres.setElementType(res);  
          return refres; 
        } 
      } 
      else if (t2.hasTag("pointer"))
      { Type newtype = t2.pointersToRefType(tname,baseType); 
        return newtype; 
      } 
    }  


    if ("enumSpecifier".equals(tag) && 
        terms.size() == 5 && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + ""))
    { // enum name { (decls) }    
      String sname = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTCompositeTerm sdecls = (ASTCompositeTerm) terms.get(3);
      Vector values = sdecls.elementList(); 
      Type et = new Type(sname,values); 
      return et; 
    } 

    if ("enumSpecifier".equals(tag) && 
        terms.size() == 2 && 
        "enum".equals(terms.get(0) + ""))
    { // enum name    
      String sname = ((ASTTerm) terms.get(1)).literalForm(); 
      Type et = new Type(sname,null); 
      return et; 
    } 


    if ("structOrUnionSpecifier".equals(tag) && 
        terms.size() == 2)
    { // (structOrUnion struct) name
      ASTTerm structOrunion = (ASTTerm) terms.get(0); 
      String sname = ((ASTTerm) terms.get(1)).literalForm(); 

      if (sname.equals("tm"))
      { sname = "OclDate"; } 

      Entity ent = 
        (Entity) ModelElement.lookupByName(sname,entities); 
      if (ent == null) 
      { ent = new Entity(sname); 
        ent.addStereotype(structOrunion.literalForm()); 
      }  
      return new Type(ent); 
    } 

    if ("structOrUnionSpecifier".equals(tag) && 
        terms.size() == 5 && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + ""))
    { // (structOrUnion struct) name { (decls) }
      ASTTerm structOrunion = (ASTTerm) terms.get(0); 
      String sname = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTCompositeTerm sdecls = 
         (ASTCompositeTerm) terms.get(3);
      Entity ent = new Entity(sname); 
      Vector atts = sdecls.structDeclarationToFeatures(
          vartypes, varelemtypes, types, entities);
      System.out.println(">>> Struct/union Class " + sname); 
      System.out.println(">>> Attributes = ");
      for (int j = 0; j < atts.size(); j++) 
      { Attribute att = (Attribute) atts.get(j); 
        System.out.println(" attribute " + att.getName() + " : " + att.getType()); 
        att.setEntity(ent); 
      } 

      ent.setAttributes(atts);   
      ent.addStereotype(structOrunion.literalForm()); 
      return new Type(ent);  
    }

    if ("structOrUnionSpecifier".equals(tag) && 
        terms.size() == 4 && 
        "{".equals(terms.get(1) + "") && 
        "}".equals(terms.get(3) + ""))
    { // (structOrUnion struct) { (decls) }
      ASTTerm structOrunion = (ASTTerm) terms.get(0); 
      String sname = Identifier.nextIdentifier("Struct_"); 
      ASTCompositeTerm sdecls = 
         (ASTCompositeTerm) terms.get(2);
      Entity ent = new Entity(sname); 
      Vector atts = sdecls.structDeclarationToFeatures(
          vartypes, varelemtypes, types, entities);
      System.out.println(">>> Struct/union Class " + sname); 
      System.out.println(">>> Attributes = ");
      for (int j = 0; j < atts.size(); j++) 
      { Attribute att = (Attribute) atts.get(j); 
        System.out.println(" attribute " + att.getName() + " : " + att.getType()); 
        att.setEntity(ent); 
      } 

      ent.setAttributes(atts);   
      ent.addStereotype(structOrunion.literalForm()); 
      return new Type(ent);  
    }

    if ("structDeclaration".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.cdeclarationToType(
        vartypes,varelemtypes,types,entities); 
    } 

    if ("specifierQualifierList".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.cdeclarationToType(
                vartypes,varelemtypes,types,entities); 
    } 

    if ("typedefName".equals(tag))
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      String tname = trm.literalForm(); 
      Type t = (Type) ModelElement.lookupByName(tname,types); 
      if (t != null) 
      { return t; } 
      return new Type(tname, null); 
    } 

    if ("typeName".equals(tag) && terms.size() == 1)
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      return trm.cdeclarationToType(
                vartypes,varelemtypes,types,entities); 
    } 

    if ("typeName".equals(tag) && terms.size() == 2)
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      ASTTerm absDec = (ASTTerm) terms.get(1); 
      // trm absDec
      // Function type Function(absDec,trm) or 
      // Sequence type Sequence(trm)

      Type fType = absDec.cdeclarationToType(
                vartypes,varelemtypes,types,entities); 
      Type dType = trm.cdeclarationToType(
                vartypes,varelemtypes,types,entities);

      System.out.println(">> Base type: " + dType); 
      System.out.println(">> Superstructure type: " + fType); 

      if (fType != null && 
          (fType.isFunctionType() || 
           fType.isReference() ||
           fType.isCollection()))
      { fType.setInnerElementType(dType); }
      else 
      { fType = new Type("Function", null); 
        fType.setKeyType(new Type("void",null)); 
        fType.setElementType(dType); 
      } 

      System.out.println(">> Composed type: " + fType); 
      System.out.println(); 

      return fType; 
    } 

    if ("abstractDeclarator".equals(tag))
    { ASTTerm t0 = (ASTTerm) terms.get(0); 
      if (t0.hasTag("pointer"))
      { if (terms.size() == 1)
        { return new Type("Ref", null); } 
        ASTTerm t1 = (ASTTerm) terms.get(1); 
        Type tm = t1.cdeclarationToType(
                vartypes,varelemtypes,types,entities);
        Type typ = new Type("Ref", null);
        typ.setElementType(tm); 
        return typ; 
      } 
      return t0.cdeclarationToType(
                vartypes,varelemtypes,types,entities);  
    }

    if ("directAbstractDeclarator".equals(tag))
    { if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") && 
          ")".equals(terms.get(2) + ""))
      { ASTTerm t = (ASTTerm) terms.get(1); 
        return t.cdeclarationToType(
                vartypes,varelemtypes,types,entities);  
      }

      if (terms.size() == 4 && 
          "(".equals(terms.get(1) + "") &&
          ")".equals(terms.get(3) + ""))
      { ASTTerm t0 = (ASTTerm) terms.get(0); 
        ASTTerm tpars = (ASTTerm) terms.get(2); 
        Type typ = t0.cdeclarationToType(
                vartypes,varelemtypes,types,entities);
        Vector pars = tpars.cparameterListToKM3(
           vartypes,varelemtypes,types,entities);

        System.out.println(">>> Parameters: " + pars); 
        Type ftype = parametersToFunctionType(pars); 
        System.out.println(">>> Function type from parameters: " + ftype); 
        System.out.println(); 
        typ.setInnerElementType(ftype); 
        return typ;  
      } 

      if (terms.size() == 3 && 
          "(".equals(terms.get(1) + "") &&
          ")".equals(terms.get(2) + ""))
      { ASTTerm t0 = (ASTTerm) terms.get(0); 
        Type typ = t0.cdeclarationToType(
                vartypes,varelemtypes,types,entities);
        Type vtype = new Type("void", null);
        Type ftype = new Type("Function",null); 
        ftype.setKeyType(vtype); 
        ftype.setElementType(vtype); 
        typ.setInnerElementType(ftype);  
        return typ;  
      } 

      if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") &&
          "]".equals(terms.get(3) + ""))
      { ASTTerm t0 = (ASTTerm) terms.get(0); 
        Type typ = t0.cdeclarationToType(
                vartypes,varelemtypes,types,entities);
        Type ftype = new Type("Sequence",null);
        typ.setInnerElementType(ftype);  
        return typ;  
      } 

      if (terms.size() == 3 && 
          "[".equals(terms.get(1) + "") &&
          "]".equals(terms.get(2) + ""))
      { ASTTerm t0 = (ASTTerm) terms.get(0); 
        Type typ = t0.cdeclarationToType(
                vartypes,varelemtypes,types,entities);
        Type ftype = new Type("Sequence",null);
        typ.setInnerElementType(ftype);  
        return typ;  
      } 

    } 

    return null; 
  } 

  public String cdeclarationStorageClass()
  { System.out.println(">> cdeclaration to storage class: " + tag + " " + terms.size()); 

    if ("declaration".equals(tag) && terms.size() == 3)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      String typ = typeSpec.cdeclarationStorageClass();
      return typ; 
    } 

    if ("declaration".equals(tag) && terms.size() == 2)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      String typ = typeSpec.cdeclarationStorageClass();
      return typ; 
    } 

    if ("declarationSpecifiers2".equals(tag))
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      String typ = typeSpec.cdeclarationStorageClass();
      return typ; 
    } 

    if ("declarationSpecifiers".equals(tag))
    { Vector typs = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt.hasTag("storageClassSpecifier"))
        { String tlit = tt.literalForm();
          if ("static".equals(tlit)) 
          { return "static"; } 
        } 
        else 
        { String ss = tt.cdeclarationStorageClass(); 
          if (ss != null) 
          { return ss; } 
        } 
      }
    }

    if ("declarationSpecifier".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.cdeclarationStorageClass(); 
    } 

    if ("abstractDeclarator".equals(tag))
    { ASTTerm t0 = (ASTTerm) terms.get(0); 
      if (t0.hasTag("pointer"))
      { if (terms.size() == 1)
        { return null; } 
        ASTTerm t1 = (ASTTerm) terms.get(1); 
        String tm = t1.cdeclarationStorageClass();
        return tm; 
      } 
      return t0.cdeclarationStorageClass();  
    }

    if ("directAbstractDeclarator".equals(tag))
    { if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") && 
          ")".equals(terms.get(2) + ""))
      { ASTTerm t = (ASTTerm) terms.get(1); 
        return t.cdeclarationStorageClass();  
      }
    }

    return null; 
  } 

  private Type parametersToFunctionType(Vector pars)
  { Type restype = new Type("void", null); 
    Type ftype = restype; 

    if (pars.size() == 0)
    { ftype = new Type("Function", null); 
      ftype.setKeyType(new Type("void", null)); 
      ftype.setElementType(restype); 
      return ftype;  
    } 
    else  
    { for (int k = 0; k < pars.size(); k++) 
      { Attribute par = (Attribute) pars.get(k); 
        Type domtype = par.getType();
        Type typ = new Type("Function", null); 
        typ.setKeyType(domtype); 
        typ.setElementType(ftype); 
        ftype = typ; 
      } 
    } 
    return ftype; 
  } 	

  public Statement cstatementToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> cstatementToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cstatementToKM3(
           vartypes, varelemtypes, types, entities); 
    } 

    if ("declaration".equals(tag) && terms.size() == 3)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      ASTTerm varSpec = (ASTTerm) terms.get(1);
      String tname = typeSpec.literalForm(); 
 
      Type typ = typeSpec.cdeclarationToType(
                     vartypes,varelemtypes,types,entities);
      String storageClass = 
                 typeSpec.cdeclarationStorageClass();

      System.out.println(">>> Storage class is: " + storageClass); 
 
      Vector mes = 
        varSpec.cdeclaratorToModelElements(
                  vartypes, varelemtypes, types, entities);
      Statement pre = 
        varSpec.cpreSideEffect(
                  vartypes, varelemtypes, types, entities);
      Statement upd = 
        varSpec.cbasicUpdateForm(
                vartypes, varelemtypes, types, entities);
      Statement pst = 
        varSpec.cpostSideEffect(
                  vartypes, varelemtypes, types, entities);
      
      /* System.out.println(">>> Pre side-effect of " + this + " is: " + pre); 
      System.out.println(">>> Update form of " + this + " is: " + upd); 
      System.out.println(">>> Post side-effect of " + this + " is: " + pst); */ 

      if (mes == null) 
      { return null; } 

      SequenceStatement ss = new SequenceStatement(); 
          
      for (int i = 0; i < mes.size(); i++) 
      { ModelElement me = (ModelElement) mes.get(i); 

        System.out.println(">>> Model element: " + me + " type = " + me.getType() + " " + typ); 

        Attribute att; 
        if (me instanceof BehaviouralFeature)
        { // attribute of function type
          att = Attribute.fromOperation(
                              (BehaviouralFeature) me); 
        } 
        else if (me instanceof Attribute)
        { att = (Attribute) me; }
        else 
        { continue; }  

        if (att.isNestedReferenceType() && 
            "char".equals(tname))
        { Type atttype = att.getType(); 
          Type newtype = Type.replaceInnerType(atttype,
                                  new Type("String", null));
          att.setType(newtype); 
          att.setElementType(newtype.getElementType()); 
        }  
        else if (att.isNestedReferenceType() && 
            "FILE".equals(tname))
        { Type atttype = att.getType(); 
          Type newtype = Type.replaceInnerType(atttype,
                                  new Type("OclFile", null));
          att.setType(newtype); 
          att.setElementType(newtype.getElementType()); 
        }  
        else if (att.isCollection() || 
                 att.isReferenceType() || 
                 att.isFunctionType())
        { Type atttype = att.getType(); 
          // att.setInnerElementType(typ); 
          atttype.setInnerElementType(typ);
          att.setElementType(atttype.getElementType());  
        } 
        else if (typ != null) 
        { att.setType(typ);
          att.setElementType(typ.getElementType()); 
        }

        Type atttype = att.getType(); 

        System.out.println(">> Attribute " + att + " type = " + atttype + " " + att.getElementType()); 

        vartypes.put(att.getName(), atttype); 
        varelemtypes.put(att.getName(), 
                         att.getElementType());             
 
        CreationStatement cs = 
          new CreationStatement(att);

        Expression init = 
           // varSpec.cexpressionToKM3(
           //      vartypes, varelemtypes, types, entities);
           att.getInitialExpression(); 

        System.out.println(">> Initial expression of " + att + " is " + init); 

        if (init != null && init.isArray())
        { att.setArray(true); } 

        if (init != null && 
            !SetExpression.isRefSetExpression(init)) 
        { BasicExpression lhs = new BasicExpression(att);

          if ("null".equals(init + "") && 
              att.isCollection())
          { init = new SetExpression(true); } 
          else if (att.isEntityType())
          { Entity attent = atttype.getEntity(); 
            init = Entity.makeInitialisation(attent, init); 
            System.out.println(">>> object initialisation " + init);
            att.setInitialExpression(init);  
          } 
          else if (att.isEntityCollection())
          { Type attelemtype = atttype.getElementType(); 
            Entity attelement = attelemtype.getEntity(); 
            init = 
              Entity.makeCollectionInitialisation(
                                         attelement,init); 
            System.out.println(">>> object initialisation " + init);
            att.setInitialExpression(init);  
          } 
          else if (att.isRef())
          { if ("0".equals(init + "") || 
                "Ref{}".equals(init + ""))
            { init = new BasicExpression("null"); } 
          } 

          init.setType(atttype); 

          if (storageClass != null && 
              "static".equals(storageClass)) 
          { //add to FromC class.
            att.setStatic(true);  
            att.setInitialExpression(init);  
            Entity fromC = (Entity) 
                              ModelElement.lookupByName(
                                   "FromC", entities);
            if (fromC != null) 
            { fromC.addAttribute(att); } 
            return null; 
          } 
             
          AssignStatement ast = 
            new AssignStatement(lhs,init); 
          ss.addStatement(cs); 
          ss.addStatement(ast); 
        }  
        else // for Ref{n} initialise in the cs:  
        { if (att.isRef())
          { if ("0".equals(init + "") || 
                "Ref{}".equals(init + ""))
            { init = new BasicExpression("null"); } 
          } 

          // if (att.isStatic()) add to FromC class. 

          if (storageClass != null && 
              "static".equals(storageClass)) 
          { //add to FromC class.
            att.setStatic(true);  
            att.setInitialExpression(init);  
            Entity fromC = (Entity) 
                              ModelElement.lookupByName(
                                   "FromC", entities);
            if (fromC != null) 
            { fromC.addAttribute(att); } 
            return null; 
          } 

          cs.setInitialisation(init); 
          ss.addStatement(cs); 
        } 
      } 

      if (upd != null) 
      { ss.addStatement(0,upd); } 
      if (pre != null) 
      { ss.addStatement(0,pre); } 
      if (pst != null) 
      { ss.addStatement(pst); } 

      System.out.println(">>> Statement for declaration " + this.literalForm() + " is " + ss); 
          
      return ss; 
    } 

    if ("declaration".equals(tag) && terms.size() == 2)
    { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
      Type typ = typeSpec.cdeclarationToType(
                    vartypes,varelemtypes,types,entities);
      String tname = typeSpec.literalForm(); 

      Vector mes = 
        typeSpec.cdeclaratorToModelElements(
           vartypes,varelemtypes,types,entities);

      System.out.println(">>> " + typeSpec); 

      System.out.println(">>> Model elements: " + mes + " type = " + typ); 

      if (mes == null) 
      { return null; } 

      SequenceStatement ss = new SequenceStatement(); 

      for (int i = 0; i < mes.size(); i++) 
      { ModelElement me = (ModelElement) mes.get(i); 
        Attribute att; 
        if (me instanceof BehaviouralFeature)
        { // attribute of function type
          att = Attribute.fromOperation((BehaviouralFeature) me); 
        } 
        else if (me instanceof Attribute)
        { att = (Attribute) me; }
        else 
        { continue; }  

        Type atttype = att.getType(); 
          
        if (att.isNestedReferenceType() && 
            "char".equals(tname))
        { Type newtype = Type.replaceInnerType(atttype,
                                  new Type("String", null));
          att.setType(newtype); 
          att.setElementType(newtype.getElementType()); 
        }  
        else if (att.isNestedReferenceType() && 
            "FILE".equals(tname))
        { Type newtype = Type.replaceInnerType(atttype,
                                  new Type("OclFile", null));
          att.setType(newtype); 
          att.setElementType(newtype.getElementType()); 
        }  
        if (att.isCollection() || att.isReferenceType() || 
            att.isFunctionType())
        { atttype.setInnerElementType(typ);
          att.setElementType(atttype.getElementType());
        } 
        else if (typ != null) 
        { att.setType(typ); 
          att.setElementType(typ.getElementType()); 
        }

      // System.out.println(att + " type = " + att.getType() + " " + att.getElementType()); 
 
        vartypes.put(att.getName(), att.getType()); 
        varelemtypes.put(att.getName(), 
                         att.getElementType());             

        atttype = att.getType(); 
 
        if (atttype != null)
        { Expression init = 
              atttype.getDefaultValueExpression(); 
          System.out.println(">>> Initialisation: " + init); 
          att.setInitialExpression(init); 
        }

        CreationStatement cs = 
          new CreationStatement(att);
        ss.addStatement(cs);
      } 

      System.out.println(">>> Statement for " + this + " is " + ss); 

      return ss;   
    } 

    if ("jumpStatement".equals(tag) && terms.size() > 1)
    { ASTTerm keywd = (ASTTerm) terms.get(0);
      String keyword = keywd.literalForm();  

      if ("break".equals(keyword))
      { return new BreakStatement(); } 

      if ("continue".equals(keyword))
      { return new ContinueStatement(); } 

      if ("return".equals(keyword))
      { if (terms.size() == 2)
        { return new ReturnStatement(); } 
        ASTTerm val = (ASTTerm) terms.get(1); 
        Expression retval = val.cexpressionToKM3(
            vartypes, varelemtypes, types, entities); 
        
        Statement prestat = val.cpreSideEffect(
            vartypes, varelemtypes, types, entities); 

        // Statement poststat = val.cpostSideEffect(
        //     vartypes, varelemtypes, types, entities); 
        // if (poststat != null) 
        // { 

        ReturnStatement ret = new ReturnStatement(retval); 
        return SequenceStatement.composedStatement(
                                           prestat,ret); 
      }
 
      if ("goto".equals(keyword))
      { String label = ((ASTTerm) terms.get(1)).literalForm();

        // Lookup the function in FromC, if it has a result 
        // type the code here is return label(pars)
        // Otherwise label(pars)

        Entity ent = (Entity) ModelElement.lookupByName(
                                "FromC", entities); 
        if (ent != null) 
        { BehaviouralFeature bf = ent.getOperation(label); 
          if (bf != null) 
          { if (bf.hasResultType())
            { BasicExpression retval = 
                new BasicExpression(bf); 
              Statement retstat = 
                new ReturnStatement(retval); 
              return retstat; 
            }  
            InvocationStatement st = 
              new InvocationStatement(bf);
            return st; 
          } 
        } 

        Vector pars = 
          Expression.parametersFromTypeMap(vartypes); 
        BasicExpression callexpr = 
          BasicExpression.newCallBasicExpression(label,pars); 
        InvocationStatement stat = 
          InvocationStatement.newInvocationStatement(
                                 callexpr,pars); 
        return stat; 
      }     
    } 
    
    if ("iterationStatement".equals(tag) && terms.size() > 1)
    { ASTTerm keywd = (ASTTerm) terms.get(0);
      String keyword = keywd.literalForm(); 
 
      if ("while".equals(keyword) && terms.size() > 4)
      { ASTTerm test = (ASTTerm) terms.get(2); 
        ASTTerm body = (ASTTerm) terms.get(4);
        Expression loopTest = test.cexpressionToKM3(
                vartypes, varelemtypes, types, entities); 
        Statement pre = 
           test.cpreSideEffect(
                  vartypes, varelemtypes, types, entities);
        Statement pst = 
           test.cpostSideEffect(
                  vartypes, varelemtypes, types, entities);
        
        Statement lbody = body.cstatementToKM3(
                vartypes, varelemtypes, types, entities);
        Statement wbody = 
          SequenceStatement.combineSequenceStatements(
                                            pst,lbody);  
        Statement wbody1 = 
          SequenceStatement.combineSequenceStatements(
                                            wbody,pre);  
        Statement ws = new WhileStatement(loopTest,wbody1); 
        return SequenceStatement.combineSequenceStatements(
                                          pre,ws); 
      } // and pre before the loop. 
      else if ("do".equals(keyword) && terms.size() > 5)
      { // do body while test is 
        // while true do (body ; if test then skip else break)

        ASTTerm test = (ASTTerm) terms.get(4); 
        ASTTerm body = (ASTTerm) terms.get(1);
        Expression loopTest = test.cexpressionToKM3(
                vartypes, varelemtypes, types, entities); 
        Statement lbody = body.cstatementToKM3(
                vartypes, varelemtypes, types, entities); 
        
        Statement pre = 
           test.cpreSideEffect(
                  vartypes, varelemtypes, types, entities);
        Statement pst = 
           test.cpostSideEffect(
                  vartypes, varelemtypes, types, entities);
        
        Statement wbody = 
          SequenceStatement.combineSequenceStatements(
                                              lbody,pre);
        Statement pstbreak =
          SequenceStatement.combineSequenceStatements(
                                              pst,
                                    new BreakStatement());

        if (pst == null) 
        { pst = new InvocationStatement("skip"); } 

        BasicExpression truebe = new BasicExpression(true);  
        ConditionalStatement cs = 
           new ConditionalStatement(loopTest, pst, pstbreak); 
        Statement wbody1 = 
          SequenceStatement.combineSequenceStatements(
                                              wbody, cs);
 
        WhileStatement ws = 
          new WhileStatement(truebe,wbody1);
        return ws; 
      } 
      else if ("for".equals(keyword)) 
      { ASTCompositeTerm forCond = 
                    (ASTCompositeTerm) terms.get(2);
        int sze = forCond.terms.size(); 

        ASTTerm code = (ASTTerm) terms.get(terms.size()-1); 
           
        ASTTerm init = (ASTTerm) (forCond.terms.get(0)); 
        if (";".equals(init.literalForm()))
        { // (forCondition ; test ; incr )
 
          ASTTerm test = (ASTTerm) forCond.terms.get(1);
          ASTTerm incr = (ASTTerm) forCond.terms.get(sze-1); 
          Expression cond = new BasicExpression(true);
          Statement increment = null;
          Statement body = null;    

          if (";".equals(test.literalForm())) { } 
          else 
          { cond = test.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities); 
          } 
          cond.setType(new Type("boolean", null)); 

          if (";".equals(incr.literalForm())) { } 
          else 
          { increment = 
              incr.cupdateForm(vartypes, varelemtypes, 
                               types, entities); 
          } 
 
          body = code.cstatementToKM3(vartypes, varelemtypes, 
                               types, entities);
          if (increment == null)
          { return new WhileStatement(cond, body); } 
          else 
          { SequenceStatement loopBody = new SequenceStatement();
            loopBody.addStatement(body); 
            loopBody.addStatement(increment); 
            loopBody.setBrackets(true); 
            return new WhileStatement(cond,loopBody); 
          } 
        } 
        else 
        { // (forCondition init ; test ; incr )
          Statement ini = init.cupdateForm(vartypes, 
                            varelemtypes, types, entities);
          SequenceStatement res = new SequenceStatement(); 
          res.addStatement(ini); 
 
          ASTTerm test = (ASTTerm) forCond.terms.get(2);
          ASTTerm incr = (ASTTerm) forCond.terms.get(sze-1); 
          Expression cond = new BasicExpression(true);
          Statement increment = null;
          Statement body = null;    

          if (";".equals(test.literalForm())) { } 
          else 
          { cond = test.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities); 
          } 

          if (";".equals(incr.literalForm())) { } 
          else 
          { increment = 
              incr.cupdateForm(vartypes, varelemtypes, 
                               types, entities); 
          } 
 
          body = code.cstatementToKM3(vartypes, varelemtypes, 
                               types, entities);
          if (increment == null)
          { WhileStatement ws = new WhileStatement(cond, body); 
            res.addStatement(ws); 
            return res; 
          } 
          else 
          { SequenceStatement loopBody = new SequenceStatement();
            loopBody.addStatement(body); 
            loopBody.addStatement(increment); 
            loopBody.setBrackets(true); 
            WhileStatement ws = new WhileStatement(cond,loopBody); 
            res.addStatement(ws); 
            return res; 
          } 
        } 
      }  
    } 

    if ("selectionStatement".equals(tag) && terms.size() > 1)
    { ASTTerm keywd = (ASTTerm) terms.get(0);
      String keyword = keywd.literalForm();  
      if ("if".equals(keyword) && terms.size() > 6)
      { // if with else 
        ASTTerm test = (ASTTerm) terms.get(2); 
        ASTTerm ifbody = (ASTTerm) terms.get(4);
        ASTTerm elsebody = (ASTTerm) terms.get(6); 
        Expression ifTest = 
          test.cexpressionToKM3(
             vartypes, varelemtypes, types, entities); 
        if (ifTest != null && ifTest.isNumeric())
        { ifTest.setBrackets(true); 
          ifTest = 
            new BinaryExpression("/=", ifTest, zeroExpression);
        }  
        Statement ifstat = ifbody.cstatementToKM3(
          vartypes, varelemtypes, types, entities); 
        Statement elsestat = elsebody.cstatementToKM3(
          vartypes, varelemtypes, types, entities); 
        Statement pre = 
           test.cpreSideEffect(
                  vartypes, varelemtypes, types, entities);
        Statement pst = 
           test.cpostSideEffect(
                  vartypes, varelemtypes, types, entities);
        
        Statement ifbranch = 
          SequenceStatement.combineSequenceStatements(
                                              pst,ifstat); 
        Statement elsebranch = 
          SequenceStatement.combineSequenceStatements(
                                              pst,elsestat); 
        return new ConditionalStatement(ifTest, 
                                        ifbranch, 
                                        elsebranch); 
      } // and pre before the statement. 
      else if ("if".equals(keyword) && terms.size() == 5)
      { // if without else 
        ASTTerm test = (ASTTerm) terms.get(2); 
        ASTTerm ifbody = (ASTTerm) terms.get(4);
        Expression ifTest = test.cexpressionToKM3(
              vartypes, varelemtypes, types, entities);
        if (ifTest != null && ifTest.isNumeric())
        { ifTest.setBrackets(true); 
          ifTest = 
            new BinaryExpression("/=", ifTest, zeroExpression);
        }  
        Statement ifstat = ifbody.cstatementToKM3(
              vartypes, varelemtypes, types, entities); 
        Statement elsestat = new InvocationStatement("skip"); 
        Statement pre = 
           test.cpreSideEffect(
                  vartypes, varelemtypes, types, entities);
        Statement pst = 
           test.cpostSideEffect(
                  vartypes, varelemtypes, types, entities);
        Statement ifbranch = 
          SequenceStatement.combineSequenceStatements(
                                              pst,ifstat); 
        Statement elsebranch = 
          SequenceStatement.combineSequenceStatements(
                                              pst,elsestat); 
        return new ConditionalStatement(ifTest, 
                                        ifbranch, 
                                        elsebranch); 
      } 
      else if ("switch".equals(keyword) && terms.size() == 5) 
      { // switch ( expr ) stat
        ASTTerm test = (ASTTerm) terms.get(2); 
        ASTCompositeTerm switchbody = (ASTCompositeTerm) terms.get(4);
        Expression sTest = test.cexpressionToKM3(
              vartypes, varelemtypes, types, entities); 

        String ivarid = Identifier.nextIdentifier("_i"); 

        BasicExpression ivar = new BasicExpression(ivarid);
        ivar.setUmlKind(Expression.VARIABLE);  
        ivar.setType(new Type("int", null)); 
        Vector pars = new Vector(); 
        pars.add(unitExpression); 
        pars.add(unitExpression); 
        BasicExpression rng = 
          BasicExpression.newFunctionBasicExpression(
                       "subrange", "Integer", pars);
        Type intseqType = new Type("Sequence", null);
        intseqType.setElementType(new Type("int", null)); 
        rng.setElementType(new Type("int", null)); 
        rng.setType(intseqType);  

        Expression tst = new BinaryExpression(":", ivar, rng); 
        tst.setType(new Type("boolean", null)); 

        SequenceStatement body = new SequenceStatement();
        String svarid = 
            Identifier.nextIdentifier("_switchvar"); 

        CreationStatement vdec = 
          new CreationStatement(svarid, 
                                new Type("int", null)); 
        BasicExpression svar = 
            new BasicExpression(svarid); 
        svar.setType(new Type("int", null)); 
        svar.setUmlKind(Expression.VARIABLE);
  
        AssignStatement vassign = 
          new AssignStatement(svar, sTest); 
        body.addStatement(vdec); 
        body.addStatement(vassign); 
        Statement sstat = switchbody.cswitchstatementToKM3(
              svar, vartypes, varelemtypes, types, entities);
        body.addStatement(sstat);  
        body.setBrackets(true); 
        WhileStatement wstat = new WhileStatement(tst,body);  
        wstat.setLoopKind(Statement.FOR); 
        wstat.setLoopRange(ivar,rng);
        return wstat; 
      } 
    } 

    if ("labeledStatement".equals(tag))
    { ASTTerm keywd = (ASTTerm) terms.get(0);
      String keyword = keywd.literalForm();  
      if ("case".equals(keyword) && terms.size() == 4) 
      { // case val : stat
        ASTTerm cval = (ASTTerm) terms.get(1); 
        ASTTerm cstat = (ASTTerm) terms.get(3); 
        Expression cexpr = cval.cexpressionToKM3(
              vartypes, varelemtypes, types, entities); 
        Statement caction = cstat.cstatementToKM3(
              vartypes, varelemtypes, types, entities);
        BasicExpression svar = new BasicExpression("_switchvar"); 
        svar.setType(new Type("int", null)); 
        Expression ctest = 
          new BinaryExpression("=", svar, cexpr); 
        Statement skipstat = 
          new InvocationStatement("skip");  
        ConditionalStatement cs = 
          new ConditionalStatement(ctest, caction, skipstat); 
        return cs; 
      }
      else if ("default".equals(keyword) && terms.size() == 3) 
      { // default : stat
        ASTTerm cstat = (ASTTerm) terms.get(2); 
        Statement caction = cstat.cstatementToKM3(
              vartypes, varelemtypes, types, entities);
        return caction; 
      }
      else if (terms.size() == 3 && 
               ":".equals(terms.get(1) + "")) 
      { // label : stat
        ASTTerm lab = (ASTTerm) terms.get(0);
        String label = lab.literalForm();  
        ASTTerm cstat = (ASTTerm) terms.get(2);
 
        Statement caction = cstat.cstatementToKM3(
              vartypes, varelemtypes, types, entities);
        /* Vector retvals = 
                 Statement.getReturnValues(caction); 

        Entity ent = 
           (Entity) ModelElement.lookupByName("FromC",
                                              entities); 
        if (ent != null) 
        { BehaviouralFeature bf = 
            new BehaviouralFeature(label); 
          bf.setParameters(vartypes, varelemtypes); 
          bf.setPre(new BasicExpression(true)); 
          bf.setPost(new BasicExpression(true)); 
          bf.setActivity(caction); 
          if (retvals != null && retvals.size() > 0)
          { Type retType = Type.determineType(retvals); 
            bf.setType(retType); 
          } 
          ent.refineOperation(bf); 
          bf.setOwner(ent); 
        } 
        */ 
        return caction; 
      } // but actually the code to the end of the function
        // Must be accumulated in a first pass of the function
    }

    if ("compoundStatement".equals(tag) && terms.size() > 1)
    { ASTTerm items = (ASTTerm) terms.get(1); 
      Vector stats = items.cstatementListToKM3(
                  vartypes,varelemtypes,types,entities);  
      SequenceStatement stat = new SequenceStatement(stats); 
      stat.setBrackets(true); 
      return stat; 
    } 

    if ("expressionStatement".equals(tag) && terms.size() > 1)
    { ASTTerm expr = (ASTTerm) terms.get(0); 
      Statement stat = expr.cupdateForm(
                 vartypes,varelemtypes,types,entities);
      return stat; 
    } 

    return null; 
  } 

  public Vector cparameterListToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">>> Parameter list " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("parameterTypeList".equals(tag))
    { // (parameterList ) , ...
      ASTTerm ptl = (ASTTerm) terms.get(0);
      Vector pargs = 
         ptl.cparameterListToKM3(
            vartypes,varelemtypes,types,entities);
      if (terms.size() > 2)
      { ASTTerm pt2 = (ASTTerm) terms.get(2); 
        if ("...".equals(pt2.literalForm()))
        { String parx = "par_varg_sq"; 
          Type seqt = new Type("Sequence", null); 
          Attribute vararg = 
            new Attribute(parx, seqt, ModelElement.INTERNAL);
          pargs.add(vararg);  
        } 
      }  
      return pargs;  
    } 

    if ("parameterList".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i);
        if (",".equals(tt.literalForm())) 
        { continue; } 

        Attribute expr = tt.cparameterToKM3(
            vartypes,varelemtypes,types,entities); 
        if (expr != null) 
        { res.add(expr);

          System.out.println("*** Parameter for " + tt + " is " + expr + " : " + expr.getType()); 
          System.out.println(); 
        } 

      } 
      return res;  
    } 

    return new Vector(); 
  } 

  public Attribute cparameterToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">>> Parameter " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("parameterDeclaration".equals(tag))
    { if (terms.size() == 3) 
      { ASTTerm typeSpec = (ASTTerm) terms.get(0);
        ASTTerm ptr = (ASTTerm) terms.get(1);  
        ASTTerm dec = (ASTTerm) terms.get(2); 
        Type typ = typeSpec.cdeclarationToType(
                      vartypes,varelemtypes,types,entities); 
        Attribute att = 
          (Attribute) dec.cdeclaratorToModelElement(
                   vartypes, varelemtypes, types, entities);
     
        Type atttype = att.getType(); 

        if (ptr.hasTag("pointer"))
        { // ASTTerm ptrs = ptr; 

          String tname = typeSpec.literalForm(); 
          // if ("char".equals(tname))
          // { typ = new Type("String", null); 
            // ptrs = ASTTerm.removeFirstTerm(ptr); 
          // } 
          // else if ("FILE".equals(tname))
          // { typ = new Type("OclFile", null);
            // ptrs = ASTTerm.removeFirstTerm(ptr);
          // }
         
          Type reftyp = ptr.pointersToRefType(tname,typ); 
          if (att.isCollection() || att.isReferenceType() ||
              att.isFunctionType())
          { atttype.setInnerElementType(reftyp); 
            att.setElementType(atttype.getElementType()); 
          } 
          else 
          { att.setType(reftyp); }
        } 
        else 
        { if (att.isCollection() || att.isReferenceType() ||
              att.isFunctionType())
          { atttype.setInnerElementType(typ); 
            att.setElementType(atttype.getElementType()); 
          } 
          else 
          { att.setType(typ); } 
        } 

        return att; 
      } 
      else if (terms.size() == 2) 
      { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
        ASTTerm dec = (ASTTerm) terms.get(1); 
        Type typ = typeSpec.cdeclarationToType(
                      vartypes,varelemtypes,types,entities); 
        Attribute att = 
          (Attribute) dec.cdeclaratorToModelElement(
                   vartypes, varelemtypes, types, entities); 

        Type atttype = att.getType(); 
        if (att.isCollection() || att.isReferenceType() ||
            att.isFunctionType())
        { atttype.setInnerElementType(typ); 
          att.setElementType(atttype.getElementType()); 
        } 
        else 
        { att.setType(typ); } 
        // and element type

        return att; 
      } 
      else if (terms.size() == 1) 
      { ASTTerm typeSpec = (ASTTerm) terms.get(0); 
        Type typ = typeSpec.cdeclarationToType(
                     vartypes,varelemtypes,types,entities); 
        if (typ == null || "void".equals(typ.getName()))
        { return null; } 

        String parname = 
           Identifier.nextIdentifier("_par"); 
        Attribute att = new Attribute(parname,typ,
                                      ModelElement.INTERNAL); 
        return att; 
      } 
    }
   
    return null; 
  }        


  public Vector cstatementListToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)

  { // if ("blockItemList".equals(tag))
    Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i);
      Statement expr = tt.cstatementToKM3(
             vartypes,varelemtypes,types,entities); 
      if (expr != null) 
      { res.add(expr); } 
    } 
    return res; 
  } 

  public Vector labelFunctions(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { Vector res = new Vector(); 
    if ("compoundStatement".equals(tag) && terms.size() > 1)
    { ASTCompositeTerm items = (ASTCompositeTerm) terms.get(1); 
      Vector stats = items.labelFunctions(
                  vartypes,varelemtypes,types,entities);  
      return stats; 
    }

    if ("blockItemList".equals(tag))
    { Entity ent = 
       (Entity) ModelElement.lookupByName("FromC",
                                              entities); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        if (t.isLabeledStatement())
        { // start new function from this point for the label
          String label = t.getLabel(); 
          
          BehaviouralFeature bf = 
              new BehaviouralFeature(label); 
          if (ent != null) 
          { ent.refineOperation(bf);                        
            bf.setOwner(ent); 
          }
          bf.setParameters(vartypes, varelemtypes); 
          bf.setPre(new BasicExpression(true)); 
          bf.setPost(new BasicExpression(true)); 
          bf.addStereotype("unsafe"); 
          bf.setStatic(true); 

          Vector tailterms = VectorUtil.vectorTail(i,terms); 
          ASTCompositeTerm act = 
                 new ASTCompositeTerm(tag, tailterms);

          System.out.println(">> Remaining code: " + act); 
 
          Vector stats = act.cstatementListToKM3(
                 vartypes, varelemtypes, types, entities);
          SequenceStatement caction = 
                     new SequenceStatement(stats); 

          System.out.println(">> Code action: " + caction); 
 

          Vector retvals = 
                 Statement.getReturnValues(caction); 

          System.out.println(">> Return values: " + retvals); 

          bf.setActivity(caction); 
          if (retvals != null && retvals.size() > 0)
          { Type retType = Type.determineType(retvals); 
            bf.setType(retType); 
          } 

          System.out.println(">>> Label function: " + bf.display()); 

          res.add(bf); 
        } 
        else 
        { t.cstatementToKM3(
                 vartypes, varelemtypes, types, entities);
          Vector tailterms = VectorUtil.vectorTail(i+1,terms); 
          ASTCompositeTerm act = 
            new ASTCompositeTerm(tag, tailterms); 
          return act.labelFunctions(
              vartypes,varelemtypes,types,entities); 
        }         
      } 
    } 

    return res; 
  }

  public boolean isLabeledStatement()
  { if ("blockItem".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.isLabeledStatement(); 
    } 

    if ("statement".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.isLabeledStatement(); 
    } 

    if ("labeledStatement".equals(tag) && terms.size() == 3)
    { ASTTerm t0 = (ASTTerm) terms.get(0); 
      if ("default".equals(t0.literalForm()))
      { return false; } 
      ASTTerm t1 = (ASTTerm) terms.get(1); 
      if (":".equals(t1.literalForm()))
      { return true; } 
      return false; 
    } 

    return false; 
  } 

  public String getLabel()
  { if ("blockItem".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.getLabel(); 
    } 

    if ("statement".equals(tag))
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      return tt.getLabel(); 
    } 

    if ("labeledStatement".equals(tag) && terms.size() == 3)
    { ASTTerm t0 = (ASTTerm) terms.get(0); 
      if ("default".equals(t0.literalForm()))
      { return null; } 
      ASTTerm t1 = (ASTTerm) terms.get(1); 
      if (":".equals(t1.literalForm()))
      { return t0.literalForm(); } 
      return null; 
    } 

    return null; 
  } 


  public Vector cexpressionListToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)

  { // if ("argumentExpressionList".equals(tag))
    Vector res = new Vector(); 
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i);
      if (",".equals(tt + "")) 
      { continue; }  
      Expression expr = tt.cexpressionToKM3(
              vartypes,varelemtypes,types,entities); 
      if (expr != null) 
      { res.add(expr); } 
    } 
    return res; 
  } 

  public Statement cpreSideEffectList(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { Statement s1 = null; 

    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i);
      if (",".equals(tt + "")) 
      { continue; }  
      Statement s2 = tt.cpreSideEffect(
              vartypes,varelemtypes,types,entities); 
      
      if (s1 == null) 
      { s1 = s2; } 
      else if (s2 == null) 
      { } 
      else 
      { SequenceStatement ss = new SequenceStatement(); 
        ss.addStatement(s1); 
        ss.addStatement(s2); 
        s1 = ss; 
      }
    } 
    return s1; 
  } 

  public Statement cpostSideEffectList(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { Statement s1 = null; 

    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i);
      if (",".equals(tt + "")) 
      { continue; }  
      Statement s2 = tt.cpostSideEffect(
              vartypes,varelemtypes,types,entities); 
      
      if (s1 == null) 
      { s1 = s2; } 
      else if (s2 == null) 
      { } 
      else 
      { SequenceStatement ss = new SequenceStatement(); 
        ss.addStatement(s1); 
        ss.addStatement(s2); 
        s1 = ss; 
      }
    } 
    return s1; 
  } 

  public Statement cupdateForm(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> C update form for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    Statement pse = cpreSideEffect(
                vartypes, varelemtypes, types, entities);
    Statement upd = cbasicUpdateForm(
                vartypes, varelemtypes, types, entities);
    Statement tse = cpostSideEffect(
                vartypes, varelemtypes, types, entities);

    Statement res = 
       SequenceStatement.composedStatement(pse,upd,tse);

    System.out.println(">> Pre side-effect = " + pse); 
    System.out.println(">> Basic update form = " + upd); 
    System.out.println(">> Post side-effect = " + tse); 

    System.out.println(">> Overall update form = " + res); 
    return res;   
  } 

  public Statement cbasicUpdateForm(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> C update form for " + tag + " with " + terms.size() + " terms"); 
    System.out.println();
 
    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cbasicUpdateForm(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initDeclaratorList".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cbasicUpdateForm(
         vartypes, varelemtypes, types, entities); 
    } // accumulate them? 

    if ("initDeclarator".equals(tag) && terms.size() == 3)
    { ASTTerm tinit = (ASTTerm) terms.get(2); 
      return tinit.cbasicUpdateForm(
          vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cbasicUpdateForm(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + ""))
    { return null; } 



    if ("expression".equals(tag) && terms.size() == 3)
    { // e1 , e2
      ASTTerm tt = (ASTTerm) terms.get(0); 
      Statement s1 = tt.cbasicUpdateForm(
         vartypes, varelemtypes, types, entities); 
      ASTTerm t2 = (ASTTerm) terms.get(2); 
      Statement s2 = t2.cbasicUpdateForm(
         vartypes, varelemtypes, types, entities); 
      if (s1 == null) 
      { return s2; } 
      if (s2 == null) 
      { return s1; } 
      SequenceStatement ss = new SequenceStatement(); 
      ss.addStatement(s1); 
      ss.addStatement(s2); 
      return ss; 
    } 

    if ("postfixExpression".equals(tag))
    { if (terms.size() == 2)
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        /* Expression res = t1.cexpressionToKM3(
                 vartypes, varelemtypes, types, entities);
        BinaryExpression incr = 
          new BinaryExpression("+", res, unitExpression); 
        return new AssignStatement(res, incr); */ 

        return t1.cbasicUpdateForm(
           vartypes, varelemtypes, types, entities); 
      } // move to postSideEffect

      if (terms.size() == 4 && 
          "(".equals(terms.get(1) + "") && 
          ")".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm pars = (ASTTerm) terms.get(2); 
        // (argumentExpressionList e1 , ... en)
        Expression arre = arr.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
        
        Vector args = pars.cexpressionListToKM3(
            vartypes, varelemtypes, types, entities);
        return cfunctioncallUpdateForm(
                   arr.literalForm(),arre,args,
                   vartypes, entities); 
      } 
    } 

    if ("unaryExpression".equals(tag) && terms.size() == 2)
    { ASTTerm arg = (ASTTerm) terms.get(1); 
      return arg.cbasicUpdateForm(
                vartypes, varelemtypes, types, entities);
    } 

    if ("assignmentExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      ASTTerm arg2 = (ASTTerm) terms.get(2);
      Statement s1 = arg1.cbasicUpdateForm(
                vartypes, varelemtypes, types, entities);
      Statement s2 = arg2.cbasicUpdateForm(
                vartypes, varelemtypes, types, entities);
      return SequenceStatement.combineSequenceStatements(
                                              s1,s2); 
  /*
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      Expression res2 = this.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);

      return new AssignStatement(res1, res2); */  
    } // Move this to preSideEffect

    return null; 
  }

  public Statement cpreSideEffect(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> cpreSideEffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cpreSideEffect(
                  vartypes, varelemtypes, types, entities); 
    } 

    if ("primaryExpression".equals(tag) && 
        terms.size() == 3 && "(".equals(terms.get(0) + "") &&
        ")".equals(terms.get(2) + "")) 
    { // (expr)
      ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cpreSideEffect(vartypes,
                             varelemtypes,types,entities);  
    } 

    if ("initDeclaratorList".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cpreSideEffect(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initDeclarator".equals(tag) && terms.size() == 3)
    { ASTTerm tinit = (ASTTerm) terms.get(2); 
      return tinit.cpreSideEffect(
          vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cpreSideEffect(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + ""))
    { return null; } 



    if ("expression".equals(tag) && terms.size() == 3)
    { // e1 , e2
      ASTTerm tt = (ASTTerm) terms.get(0); 
      Statement s1 = tt.cpreSideEffect(
                     vartypes, varelemtypes, types, entities); 
      ASTTerm t2 = (ASTTerm) terms.get(2); 
      Statement s2 = t2.cpreSideEffect(
                     vartypes, varelemtypes, types, entities); 
      if (s1 == null) 
      { return s2; } 
      else if (s2 == null) 
      { return s1; } 
      SequenceStatement ss = new SequenceStatement(); 
      ss.addStatement(s1); 
      ss.addStatement(s2); 
      return ss; 
    } 

    if ("postfixExpression".equals(tag))
    { if (terms.size() == 2 && 
          "++".equals(terms.get(1) + ""))
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        return t1.cpreSideEffect(
                     vartypes, varelemtypes, types, entities); 
      } 

      if (terms.size() == 2 && 
          "--".equals(terms.get(1) + ""))
      { // t1--
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        return t1.cpreSideEffect(
            vartypes, varelemtypes, types, entities);
      } 

      if (terms.size() == 4 && 
          "(".equals(terms.get(1) + "") && 
          ")".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTCompositeTerm pars = (ASTCompositeTerm) terms.get(2); 
        // (argumentExpressionList e1 , ... en)
        Statement arre = arr.cpreSideEffect(
            vartypes, varelemtypes, types, entities);
        
        Statement stat = pars.cpreSideEffectList(
            vartypes, varelemtypes, types, entities);

        Expression arrexpr = arr.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
        
        Vector args = pars.cexpressionListToKM3(
            vartypes, varelemtypes, types, entities);

        Statement call = cfunctioncallPresideeffect(
                             arr.literalForm(), arrexpr,
                             args, vartypes, entities);

        Statement nstat = 
          SequenceStatement.composedStatement(arre,stat,call);
        return nstat; 
      } 

      if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind = (ASTTerm) terms.get(2); 
        Statement arre = arr.cpreSideEffect(
                   vartypes, varelemtypes, types, entities);
        
        Statement inde = ind.cpreSideEffect(
                   vartypes, varelemtypes, types, entities);
        if (arre == null) 
        { return inde; } 
        else if (inde == null) 
        { return arre; } 
        else 
        { return new SequenceStatement(arre,inde); }  
      } 

      if (terms.size() == 7 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "") && 
          "[".equals(terms.get(4) + "") && 
          "]".equals(terms.get(6) + "") )
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind1 = (ASTTerm) terms.get(2); 
        ASTTerm ind2 = (ASTTerm) terms.get(5); 
        Statement arre = arr.cpreSideEffect(
                vartypes, varelemtypes, types, entities);
        
        Statement ind1e = ind1.cpreSideEffect(
                vartypes, varelemtypes, types, entities);
        Statement ind2e = ind2.cpreSideEffect(
                vartypes, varelemtypes, types, entities);
        return 
          SequenceStatement.composedStatement(arre,ind1e,ind2e); 
      } 


    } 

    if ("unaryExpression".equals(tag) && terms.size() == 2)
    { String op = ((ASTTerm) terms.get(0)).literalForm(); 
      ASTTerm arg = (ASTTerm) terms.get(1); 
      Expression res = arg.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      
      if ("++".equals(op))
      { if (res.isString())
        { Expression substr = 
            new UnaryExpression("->tail", res); 
          substr.setType(res.getType()); 
          return 
            new AssignStatement(res, substr); 
        } 
        BinaryExpression incr = 
           new BinaryExpression("+", res, unitExpression); 
        return new AssignStatement(res, incr); 
      } 

      if ("--".equals(op))
      { BinaryExpression decr = new BinaryExpression("-", res, unitExpression);
        return new AssignStatement(res, decr);
      } 

      return arg.cpreSideEffect(
               vartypes, varelemtypes, types, entities);
    } 

    if ("unaryExpression".equals(tag) && terms.size() > 2)
    { String op = ((ASTTerm) terms.get(0)).literalForm(); 
      Vector remterms = new Vector(); 
      remterms.addAll(terms); 
      remterms.remove(0); 
      ASTCompositeTerm newct = 
        new ASTCompositeTerm(tag, remterms); 
      Expression lhs = newct.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      Statement seff = newct.cpreSideEffect(
          vartypes, varelemtypes, types, entities);

      if ("++".equals(op))
      { if (lhs.isString())
        { Expression rhs = 
            new UnaryExpression("->tail", lhs); 
          rhs.setType(lhs.getType()); 
          Statement s0 = 
            new AssignStatement(lhs,rhs); 
          return SequenceStatement.composedStatement(s0,seff); 
        }  
        BinaryExpression rhs = 
           new BinaryExpression("+", lhs, unitExpression); 
        Statement s1 = new AssignStatement(lhs, rhs);
        return SequenceStatement.composedStatement(s1,seff);  
      } 

      if ("--".equals(op))
      { BinaryExpression rhs = 
          new BinaryExpression("-", lhs, unitExpression);
        rhs.setType(lhs.getType()); 
        Statement s2 = new AssignStatement(lhs, rhs);
        return SequenceStatement.composedStatement(s2,seff);
      }

      return seff;  
    } 



    if ("additiveExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("multiplicativeExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("shiftExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("castExpression".equals(tag) && terms.size() == 4 && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + ""))
    { ASTTerm arg = (ASTTerm) terms.get(3); 
      return arg.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
    } 

    if ("relationalExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("equalityExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
            vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("andExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
  
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("exclusiveOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
            vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("inclusiveOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("logicalAndExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("logicalOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("conditionalExpression".equals(tag) && terms.size() == 5)
    { ASTTerm test = (ASTTerm) terms.get(0); 
      ASTTerm ifPart = (ASTTerm) terms.get(2); 
      ASTTerm elsePart = (ASTTerm) terms.get(4);
      Statement testSE = test.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      Statement ifSE = ifPart.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      Statement elseSE = elsePart.cpreSideEffect(
           vartypes, varelemtypes, types, entities);
      return SequenceStatement.composedStatement(testSE, 
                                       ifSE, elseSE); 
    } 

    if ("assignmentExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement pre1 = arg1.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement pre2 = arg2.cpreSideEffect(
          vartypes, varelemtypes, types, entities);
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      Expression res2 = null; 
      if ("=".equals(op))
      { res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      } 
      else 
      { res2 = this.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      } 

      Statement effect = new AssignStatement(res1, res2); 

      return SequenceStatement.composedStatement(pre1, 
                                       pre2, effect); 
    }

    return null; 
  }

  public Statement cpostSideEffect(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Postsideeffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cpostSideEffect(
                  vartypes, varelemtypes, types, entities); 
    } 

    if ("initDeclaratorList".equals(tag))
    { Statement ss = null; 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t1 = (ASTTerm) terms.get(i);
        if (",".equals(t1.literalForm())) 
        { } 
        else  
        { Statement pst = t1.cpostSideEffect(
                vartypes, varelemtypes, types, entities);
          if (pst != null) 
          { if (ss == null) 
            { ss = pst; } 
            else 
            { ss = 
                SequenceStatement.composedStatement(ss,pst); 
            }
          }        
        } 
      }  
      return ss; 
    } 

    if ("initDeclarator".equals(tag) && terms.size() == 3)
    { ASTTerm tinit = (ASTTerm) terms.get(2); 
      return tinit.cpostSideEffect(
          vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cpostSideEffect(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + ""))
    { return null; } 


    if ("primaryExpression".equals(tag) && 
        terms.size() == 3 && "(".equals(terms.get(0) + "") &&
        ")".equals(terms.get(2) + "")) 
    { // (expr)
      ASTTerm tt = (ASTTerm) terms.get(1); 
      return tt.cpostSideEffect(vartypes,
                             varelemtypes,types,entities);  
    } 

    if ("expression".equals(tag) && terms.size() == 3)
    { // e1 , e2
      ASTTerm tt = (ASTTerm) terms.get(0); 
      Statement s1 = tt.cpostSideEffect(
                     vartypes, varelemtypes, types, entities); 
      ASTTerm t2 = (ASTTerm) terms.get(2); 
      Statement s2 = t2.cpostSideEffect(
                     vartypes, varelemtypes, types, entities); 
      if (s1 == null) 
      { return s2; } 
      else if (s2 == null) 
      { return s1; } 
      SequenceStatement ss = new SequenceStatement(); 
      ss.addStatement(s1); 
      ss.addStatement(s2); 
      return ss; 
    } 

    if ("postfixExpression".equals(tag))
    { if (terms.size() == 2 && 
          "++".equals(terms.get(1) + ""))
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0);
        Expression expr = t1.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities); 
        Expression rhs = null; 
        if (expr.isString())
        { rhs = new UnaryExpression("->tail", expr); } 
        else 
        { rhs = new BinaryExpression("+", expr, 
                                     unitExpression); 
        } 
        rhs.setType(expr.getType());

        Statement incr = 
              new AssignStatement(expr, rhs);  
        Statement stat1 = t1.cpostSideEffect(
                     vartypes, varelemtypes, types, entities);
        return SequenceStatement.composedStatement(
                                             incr,stat1);  
      } 

      if (terms.size() == 2 && 
          "--".equals(terms.get(1) + ""))
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        Expression expr = t1.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities); 
        Statement decr = 
          new AssignStatement(expr, 
                new BinaryExpression("-", expr, 
                      unitExpression));  
        Statement stat1 = t1.cpostSideEffect(
            vartypes, varelemtypes, types, entities);
        return SequenceStatement.composedStatement(
                                             decr,stat1);  
      } 

      if (terms.size() == 4 && 
          "(".equals(terms.get(1) + "") && 
          ")".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTCompositeTerm pars = (ASTCompositeTerm) terms.get(2); 
        // (argumentExpressionList e1 , ... en)
        Statement arre = arr.cpostSideEffect(
            vartypes, varelemtypes, types, entities);
        
        Statement stat = pars.cpostSideEffectList(
            vartypes, varelemtypes, types, entities);
        if (arre == null) 
        { return stat; } 
        else if (stat == null) 
        { return arre; } 
        else 
        { SequenceStatement nstat = new SequenceStatement(); 
          nstat.addStatement(arre); 
          nstat.addStatement(stat); 
          return nstat; 
        } 
      } 

      if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind = (ASTTerm) terms.get(2); 
        Statement arre = arr.cpostSideEffect(
                   vartypes, varelemtypes, types, entities);
        
        Statement inde = ind.cpostSideEffect(
                   vartypes, varelemtypes, types, entities);
        if (arre == null) 
        { return inde; } 
        else if (inde == null) 
        { return arre; } 
        else 
        { return new SequenceStatement(arre,inde); }  
      } 

      if (terms.size() == 7 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "") && 
          "[".equals(terms.get(4) + "") && 
          "]".equals(terms.get(6) + "") )
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind1 = (ASTTerm) terms.get(2); 
        ASTTerm ind2 = (ASTTerm) terms.get(5); 
        Statement arre = arr.cpostSideEffect(
                vartypes, varelemtypes, types, entities);
        
        Statement ind1e = ind1.cpostSideEffect(
                vartypes, varelemtypes, types, entities);
        Statement ind2e = ind2.cpostSideEffect(
                vartypes, varelemtypes, types, entities);
        return 
          SequenceStatement.composedStatement(
                                   arre,ind1e,ind2e); 
      } 

      Statement resx = null; 
      Vector previousTerms = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tterm = (ASTTerm) terms.get(i);
        String lex = tterm.literalForm(); 
 
        if ("[".equals(lex) && 
            i+2 < terms.size() && 
            "]".equals(terms.get(i+2) + ""))
        { if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cpostSideEffect(
                   vartypes, varelemtypes, types, entities);
          } 
          ASTTerm ind = (ASTTerm) terms.get(i+1); 
         
          Statement inde = ind.cpostSideEffect(
             vartypes, varelemtypes, types, entities);
          resx = SequenceStatement.combineSequenceStatements(
                                                   resx,inde); 
          i++; 
          i++;  
        }
        else if (".".equals(lex) && i+1 < terms.size())
        { // t1.f
          
          if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cpostSideEffect(
                   vartypes, varelemtypes, types, entities);
          } 
          
          i++; 
        }
        else if ("->".equals(lex) && i+1 < terms.size())
        { if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cpostSideEffect(
                   vartypes, varelemtypes, types, entities);
          } 
          i++; 
        } 
        else if ("(".equals(lex) && 
                 i+2 < terms.size() && 
                 ")".equals(terms.get(i+2) + ""))
        { ASTTerm pars = (ASTTerm) terms.get(i+1); 
          // (argumentExpressionList e1 , ... en)
        
          Vector args = pars.cexpressionListToKM3(
               vartypes, varelemtypes, types, entities);
          if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cpostSideEffect(
                     vartypes, varelemtypes, types, entities);
          } // and the side-effects of the args? 
          i++; 
          i++; 
        } 
        else if ("++".equals(lex) || "--".equals(lex))
        { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
          if (resx == null) 
          { resx = ct.cpostSideEffect(
                     vartypes, varelemtypes, types, entities);
          }
          Expression lhs =
            ct.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities);
          Expression rhs = null; 
          if (lhs.isString() && "++".equals(lex))
          { rhs = new UnaryExpression("->tail", lhs); } 
          else  
          { rhs = new BinaryExpression(lex.substring(1), 
                                   lhs, unitExpression); 
          } 
          rhs.setType(lhs.getType()); 

          AssignStatement asm = 
                     new AssignStatement(lhs,rhs); 
          resx = SequenceStatement.combineSequenceStatements(
                                           resx,asm); 
        } 
        else 
        { previousTerms.add(tterm); } 
      } 

      return resx; 
    } 

    if ("unaryExpression".equals(tag) && terms.size() == 2)
    { ASTTerm arg = (ASTTerm) terms.get(1); 
     
      return arg.cpostSideEffect(
               vartypes, varelemtypes, types, entities);
    } 

    if ("additiveExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("multiplicativeExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("shiftExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("castExpression".equals(tag) && terms.size() == 4 && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + ""))
    { ASTTerm arg = (ASTTerm) terms.get(3); 
      return arg.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
    } 

    if ("relationalExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("equalityExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
            vartypes, varelemtypes, types, entities);
      
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("andExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
  
      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("exclusiveOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
            vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("inclusiveOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("logicalAndExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("logicalOrExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);

      return SequenceStatement.composedStatement(res1, res2);   
    } 

    if ("conditionalExpression".equals(tag) && terms.size() == 5)
    { ASTTerm test = (ASTTerm) terms.get(0); 
      ASTTerm ifPart = (ASTTerm) terms.get(2); 
      ASTTerm elsePart = (ASTTerm) terms.get(4);
      Statement testSE = test.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      Statement ifSE = ifPart.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      Statement elseSE = elsePart.cpostSideEffect(
           vartypes, varelemtypes, types, entities);
      return SequenceStatement.composedStatement(testSE, 
                                       ifSE, elseSE); 
    } 

    if ("assignmentExpression".equals(tag) && terms.size() == 3)
    { ASTTerm arg1 = (ASTTerm) terms.get(0); 
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Statement res1 = arg1.cpostSideEffect(
          vartypes, varelemtypes, types, entities);
      Statement res2 = arg2.cpostSideEffect(
          vartypes, varelemtypes, types, entities);

      if (res1 == null) 
      { return res2; } 
      if (res2 == null) 
      { return res1; } 
      return new SequenceStatement(res1, res2); 
    }

    return null; 
  }


  public BasicExpression cFieldApplication(Expression obj,
                                      String f)
  { if ("tm_sec".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getSecond",obj); 
    }
 
    if ("tm_min".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getMinute",obj); 
    }
 
    if ("tm_hour".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getHour",obj); 
    }
 
    if ("tm_mday".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getDate",obj); 
    }

    if ("tm_mon".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getMonth",obj); 
    }

    if ("tm_year".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getYear",obj); 
    }

    if ("tm_wday".equals(f))
    { return 
        BasicExpression.newQueryCallBasicExpression(
                                 "getDay",obj); 
    }

    return BasicExpression.newAttributeBasicExpression(
                                             f, obj); 
  } 


  public Expression cexpressionToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> cexpressionToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cexpressionToKM3(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initDeclaratorList".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cexpressionToKM3(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initDeclarator".equals(tag) && terms.size() == 3)
    { ASTTerm tinit = (ASTTerm) terms.get(2); 
      return tinit.cexpressionToKM3(
          vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.cexpressionToKM3(
         vartypes, varelemtypes, types, entities); 
    } 

    if ("initializer".equals(tag) && terms.size() == 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + ""))
    { ASTTerm t1 = (ASTTerm) terms.get(1); 
      Vector exprs = t1.cexpressionListToKM3(
          vartypes, varelemtypes, types, entities); 
      SetExpression st = new SetExpression(exprs,true); 

      System.out.println(">> Initial array value: " + st); 
      System.out.println(); 

      return st; 
    } 


    if ("expression".equals(tag) && terms.size() == 3)
    { // e1 , e2
      ASTTerm tt = (ASTTerm) terms.get(2); 
      return tt.cexpressionToKM3(
          vartypes, varelemtypes, types, entities); 
    } 

    if ("primaryExpression".equals(tag) && 
        terms.size() == 3 && "(".equals(terms.get(0) + "") &&
        ")".equals(terms.get(2) + "")) 
    { // (expr)
      ASTTerm tt = (ASTTerm) terms.get(1); 
      Expression res = tt.cexpressionToKM3(vartypes,
                             varelemtypes,types,entities); 
      res.setBrackets(true);
      return res; 
    } 

    if ("primaryExpression".equals(tag) && 
        terms.size() > 1 && 
        '\'' == (terms.get(0) + "").charAt(0))
    { String actualTerm = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { actualTerm = actualTerm + 
          ((ASTTerm) terms.get(i)).literalForm();
        if (i < terms.size() -1)
        { actualTerm = actualTerm + " "; }  
      } 
      ASTBasicTerm bt = 
        new ASTBasicTerm(tag, actualTerm); 
      return bt.cexpressionToKM3(
             vartypes,varelemtypes,types,entities); 
    } 

    if ("postfixExpression".equals(tag) && 
        terms.size() == 3 && "(".equals(terms.get(1) + "") &&
        ")".equals(terms.get(2) + "")) 
    { // f()
      ASTTerm tt = (ASTTerm) terms.get(0); 
      Expression res = tt.cexpressionToKM3(vartypes,
                             varelemtypes,types,entities); 
      return cfunctioncallToKM3(
        tt.literalForm(),res,new Vector(),vartypes,entities); 
    } 

    if ("postfixExpression".equals(tag) && 
        terms.size() == 5 && ".".equals(terms.get(1) + "") &&
        "(".equals(terms.get(3) + "") &&
        ")".equals(terms.get(4) + "")) 
    { // x.f()
      ASTTerm tt = (ASTTerm) terms.get(0); 
      Expression obj = tt.cexpressionToKM3(vartypes,
                             varelemtypes,types,entities);
      ASTTerm fld = (ASTTerm) terms.get(2); 
      Expression f = fld.cexpressionToKM3(vartypes,
                             varelemtypes,types,entities); 
      if (f instanceof BasicExpression)
      { BasicExpression be = (BasicExpression) f; 
        be.setIsEvent();
        be.setParameters(new Vector());
        be.setObjectRef(obj); 
        return be; 
      }   
      return f; 
    } 

    if ("postfixExpression".equals(tag))
    { if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind = (ASTTerm) terms.get(2); 
        Expression arre = arr.cexpressionToKM3(vartypes, varelemtypes, types, entities);
        
        Expression inde = ind.cexpressionToKM3(vartypes, varelemtypes, types, entities);
        BinaryExpression umlindex = 
          new BinaryExpression("+", inde, new BasicExpression(1)); 
        BinaryExpression res = 
          new BinaryExpression("->at", arre, umlindex); 
        return res; 
      } // really !(arre+inde)

      if (terms.size() == 7 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "") && 
          "[".equals(terms.get(4) + "") && 
          "]".equals(terms.get(6) + "") )
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm ind1 = (ASTTerm) terms.get(2); 
        ASTTerm ind2 = (ASTTerm) terms.get(5); 
        Expression arre = arr.cexpressionToKM3(vartypes, varelemtypes, types, entities);
        
        Expression ind1e = ind1.cexpressionToKM3(vartypes, varelemtypes, types, entities);
        Expression ind2e = ind2.cexpressionToKM3(vartypes, varelemtypes, types, entities);
        BinaryExpression umlindex1 = 
          new BinaryExpression("+", ind1e, unitExpression); 
        BinaryExpression res1 = 
          new BinaryExpression("->at", arre, umlindex1); 
        BinaryExpression umlindex2 = 
          new BinaryExpression("+", ind2e, unitExpression); 
        BinaryExpression res = 
          new BinaryExpression("->at", res1, umlindex2); 
        return res; 
      } // really !(arre+inde)


      if (terms.size() == 4 && 
          "(".equals(terms.get(1) + "") && 
          ")".equals(terms.get(3) + ""))
      { ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm pars = (ASTTerm) terms.get(2); 
        // (argumentExpressionList e1 , ... en)
        Expression arre = arr.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
        
        Vector args = pars.cexpressionListToKM3(
             vartypes, varelemtypes, types, entities);

        System.out.println("> cfunctioncalltoKM3 " + arr + " " + arre + " " + args); 

        return cfunctioncallToKM3(
           arr.literalForm(),arre,args,vartypes,entities); 
      } 

      if (terms.size() == 6 && 
          ".".equals(terms.get(1) + "") && 
          "(".equals(terms.get(3) + "") &&
          ")".equals(terms.get(5) + ""))
      { // obj . m ( args )
        ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm met = (ASTTerm) terms.get(2); 
        ASTTerm pars = (ASTTerm) terms.get(4); 
        Expression arre = arr.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
        
        Vector args = pars.cexpressionListToKM3(
             vartypes, varelemtypes, types, entities);

        System.out.println(">> cfunctioncalltoKM3 " + arre + " . " + met + " " + args); 

        BasicExpression arrem = 
          new BasicExpression(met + ""); 
        arrem.setObjectRef(arre); 
        return cfunctioncallToKM3(
           met.literalForm(),arrem,args,vartypes,entities); 
      } 

      if (terms.size() == 5 && 
          ".".equals(terms.get(1) + "") && 
          "(".equals(terms.get(3) + "") &&
          ")".equals(terms.get(4) + ""))
      { // obj . m ( )
        ASTTerm arr = (ASTTerm) terms.get(0);
        ASTTerm met = (ASTTerm) terms.get(2); 
        Expression arre = arr.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
        
        Vector args = new Vector(); 

        System.out.println(">> cfunctioncalltoKM3 " + arre + " . " + met + " " + args); 

        BasicExpression arrem = 
          new BasicExpression(met + ""); 
        arrem.setObjectRef(arre); 
        return cfunctioncallToKM3(
           met.literalForm(),arrem,args,vartypes,entities); 
      } 

      if (terms.size() == 3 && 
          ".".equals(terms.get(1) + ""))
      { // t1.f
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        String f = terms.get(2) + ""; 
        Expression obj = t1.cexpressionToKM3(
              vartypes, varelemtypes, types, entities);
        BasicExpression res = cFieldApplication(obj,f);  
        return res; 
      }

      if (terms.size() == 5 && 
          ".".equals(terms.get(1) + "") && 
          ".".equals(terms.get(3) + ""))
      { // t1.f.g
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        BasicExpression res1 = 
           new BasicExpression(terms.get(2) + ""); 
        res1.setUmlKind(Expression.ATTRIBUTE); 
        BasicExpression res = 
           new BasicExpression(terms.get(4) + ""); 
        res.setUmlKind(Expression.ATTRIBUTE); 
        Expression obj = t1.cexpressionToKM3(
              vartypes, varelemtypes, types, entities);
        res1.setObjectRef(obj); 
        res.setObjectRef(res1); 
        return res; 
      }

      if (terms.size() == 5 && 
          ".".equals(terms.get(1) + "") && 
          "->".equals(terms.get(3) + ""))
      { // !(t1.f).g
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        BasicExpression res1 = 
           new BasicExpression(terms.get(2) + ""); 
        res1.setUmlKind(Expression.ATTRIBUTE); 
        BasicExpression res = 
           new BasicExpression(terms.get(4) + ""); 
        res.setUmlKind(Expression.ATTRIBUTE); 
        Expression obj = t1.cexpressionToKM3(
              vartypes, varelemtypes, types, entities);
        res1.setObjectRef(obj);
        res1.setBrackets(true); 
        Expression deref = 
          new UnaryExpression("!", res1); 
        deref.setBrackets(true); 
        res.setObjectRef(deref); 
        return res; 
      }


      if (terms.size() == 3 && 
          "->".equals(terms.get(1) + ""))
      { // (!t1).f
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        String f = terms.get(2) + ""; 
        Expression obj = t1.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);

        Expression deref = new UnaryExpression("!", obj); 

        if (obj instanceof UnaryExpression &&
            ((UnaryExpression) obj).operator.equals("?"))
        { deref = ((UnaryExpression) obj).argument; } 
        deref.setBrackets(true); 

        // res.setObjectRef(deref); 
        return cFieldApplication(deref,f); 
      } 

      if (terms.size() == 5 && 
          "->".equals(terms.get(1) + "") && 
          "->".equals(terms.get(3) + ""))
      { // t1->f->g is !((!t1).f).g
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        BasicExpression res1 = 
           new BasicExpression(terms.get(2) + ""); 
        res1.setUmlKind(Expression.ATTRIBUTE); 
        Expression obj = t1.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
        Expression deref = new UnaryExpression("!", obj); 
        if (obj instanceof UnaryExpression &&
            ((UnaryExpression) obj).operator.equals("?"))
        { deref = ((UnaryExpression) obj).argument; } 
        deref.setBrackets(true); 
        res1.setObjectRef(deref);
        BasicExpression res = 
           new BasicExpression(terms.get(4) + ""); 
        UnaryExpression deref1 = 
           new UnaryExpression("!", res1); 
        res1.setBrackets(true); 
        deref1.setBrackets(true); 
        res.setObjectRef(deref1);
        res.setUmlKind(Expression.ATTRIBUTE); 
        
        return res; 
      } 

      if (terms.size() == 5 && 
          "->".equals(terms.get(1) + "") && 
          ".".equals(terms.get(3) + ""))
      { // t1->f.g is (!t1).f.g
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        BasicExpression res1 = 
           new BasicExpression(terms.get(2) + ""); 
        res1.setUmlKind(Expression.ATTRIBUTE); 
        Expression obj = t1.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
        UnaryExpression deref = new UnaryExpression("!", obj); 
        deref.setBrackets(true); 
        res1.setObjectRef(deref);
        BasicExpression res = 
           new BasicExpression(terms.get(4) + ""); 
        res.setObjectRef(res1);
        res.setUmlKind(Expression.ATTRIBUTE); 
        
        return res; 
      } 


      if (terms.size() == 2 && 
          "++".equals(terms.get(1) + ""))
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        Expression res = t1.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
        return res; 
      } 

      if (terms.size() == 2 && 
          "--".equals(terms.get(1) + ""))
      { // t1++
        ASTTerm t1 = (ASTTerm) terms.get(0); 
        Expression res = t1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
        return res; 
      } 
     
      Expression resx = null; 
      Vector previousTerms = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tterm = (ASTTerm) terms.get(i);
        String lex = tterm.literalForm(); 

        System.out.println(">> Postfix term " + i + " = " + lex); 
 
        if ("[".equals(lex) && 
            i+2 < terms.size() && 
            "]".equals(terms.get(i+2) + ""))
        { if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cexpressionToKM3(
                   vartypes, varelemtypes, types, entities);
          } 
          ASTTerm ind = (ASTTerm) terms.get(i+1); 
         
          Expression inde = ind.cexpressionToKM3(
             vartypes, varelemtypes, types, entities);
          BinaryExpression umlindex = 
            new BinaryExpression("+", inde, unitExpression); 
          resx = 
            new BinaryExpression("->at", resx, umlindex);

          System.out.println(">> Indexed expression " + resx); 

          i++; 
          i++;  
        }
        else if (".".equals(lex) && i+1 < terms.size())
        { // t1.f
          String f = ((ASTTerm) terms.get(i+1)).literalForm();
          BasicExpression bf = new BasicExpression(f); 
          bf.setUmlKind(Expression.ATTRIBUTE); 
        
          if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cexpressionToKM3(
                   vartypes, varelemtypes, types, entities);
          } 
          
          bf.setObjectRef(resx);
          resx = bf; 

          System.out.println(">> Navigation expression " + resx); 

          i++; 
        }
        else if ("->".equals(lex) && i+1 < terms.size())
        { BasicExpression bf = 
            new BasicExpression(terms.get(i+1) + ""); 
          if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cexpressionToKM3(
                   vartypes, varelemtypes, types, entities);
          } 
          UnaryExpression deref = 
                      new UnaryExpression("!", resx); 
          deref.setBrackets(true); 
          bf.setObjectRef(deref); 
          bf.setUmlKind(Expression.ATTRIBUTE); 
          resx = bf; 

          System.out.println(">> Dereference expression " + resx); 

          i++; 
        } 
        else if ("(".equals(lex) && 
                 i+2 < terms.size() && 
                 ")".equals(terms.get(i+2) + ""))
        { ASTTerm pars = (ASTTerm) terms.get(i+1); 
          // (argumentExpressionList e1 , ... en)
        
          Vector args = pars.cexpressionListToKM3(
               vartypes, varelemtypes, types, entities);
          if (resx == null) 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            resx = ct.cexpressionToKM3(
                     vartypes, varelemtypes, types, entities);
            System.out.println(">>> Function call " + resx + 
                               " " + args); 
            resx = UnaryExpression.argumentsToLambdaCall(resx,
                                                         args);           
          } 
          else 
          { ASTCompositeTerm ct = 
              new ASTCompositeTerm(tag,previousTerms); 
            System.out.println(">>> Function call " + resx + 
                               " " + args); 
            resx = UnaryExpression.argumentsToLambdaCall(resx,
                                                         args);           
          } 

          System.out.println(">> Function call expression " + resx); 

          i++; 
          i++; 
        } 
        else if ("++".equals(lex) || "--".equals(lex))
        { } 
        else 
        { previousTerms.add(tterm); } 
      } 

      return resx; 
    } 

    if ("unaryExpression".equals(tag) && terms.size() == 2)
    { String op = ((ASTTerm) terms.get(0)).literalForm(); 
      ASTTerm arg = (ASTTerm) terms.get(1); 
      Expression res = arg.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      
      if ("&".equals(op) && res != null)
      { res.setBrackets(true); 
        Expression resx = new UnaryExpression("?", res); 
        Type rest = new Type("Ref", null); 
        rest.setElementType(res.getType()); 
        resx.setType(rest); 
        resx.setElementType(res.getType()); 
        return resx; 
      } // a reference to a function is the function

      if ("*".equals(op) && res != null)
      { if (res.isString())
        { Expression bexpr = 
            new BinaryExpression("->at", res, unitExpression); 
          Expression aschar = 
            new UnaryExpression("->char2byte", bexpr); 
          aschar.setType(new Type("int", null)); 
          return aschar; 
        } 

        if (res.isSequence())
        { Expression bexpr = 
            new BinaryExpression("->at", res, unitExpression); 
          bexpr.setType(res.getElementType()); 
          return bexpr; 
        }

        if (res instanceof BinaryExpression)
        { BinaryExpression be = (BinaryExpression) res; 
          if ("+".equals(be.operator) && 
              be.left.isSequence())
          { Expression indx =
              new BinaryExpression("+", be.right,
                                   unitExpression);  
            Expression bres = 
              new BinaryExpression("->at", be.left, indx); 
            bres.setType(be.left.getElementType()); 
            return bres; 
          }
        } // *(sq + i) is sq->at(i+1)

        res.setBrackets(true); 
        Expression expr = new UnaryExpression("!", res);
        expr.setType(res.getElementType()); 
        return expr;  
      } // dereference of a function is the function

      if ("!".equals(op))
      { Expression resx = new UnaryExpression("not", res); 
        resx.setType(new Type("boolean", null)); 
        return resx; 
      }

      if ("++".equals(op))
      { // return new BinaryExpression("+", res, unitExpression); 
        return res; 
      } 

      if ("--".equals(op))
      { // return new BinaryExpression("-", res, unitExpression); 
        return res; 
      }

      if ("~".equals(op))
      { BinaryExpression addexpr = 
          new BinaryExpression("+", res, unitExpression);
        addexpr.setBrackets(true); 
        UnaryExpression minusexpr = 
          new UnaryExpression("-", addexpr);
        return minusexpr;  
      } 

      if ("+".equals(op))
      { return res; }

      if ("-".equals(op) && 
          "HUGE_VAL".equals(arg.literalForm()))
      { Expression resx =
           new BasicExpression("Math_NINFINITY"); 
        resx.setType(new Type("double", null)); 
        return resx; 
      }
      else if ("-".equals(op) && res != null)
      { Expression resx = new UnaryExpression(op,res);
        resx.setType(res.getType());  
        return resx; 
      }   

      if ("sizeof".equals(op))
      { Expression rtn = ASTCompositeTerm.sizeofExpression(
                                    res,types,entities); 
        System.out.println(">>--- sizeof type " + 
                           rtn.getsizeofType());
        return rtn;  
      }  

      return new UnaryExpression(op,res); 
    } 

    if ("unaryExpression".equals(tag) && terms.size() == 4)
    { String op = ((ASTTerm) terms.get(0)).literalForm(); 
      if ("sizeof".equals(op))
      { ASTTerm t2 = (ASTTerm) terms.get(2); 
        Type typ = t2.cdeclarationToType(
               vartypes, varelemtypes, types, entities);
 
        System.out.println(">>-- sizeof type " + typ); 

        Expression rtn = ASTCompositeTerm.sizeofExpression(
                                      typ,types,entities);
        if (typ != null) 
        { rtn.setsizeofType(typ); }
  
        return rtn;   
      } 
    } 

    if ("additiveExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);
      
      if ("+".equals(op) && res1 != null && res2 != null &&
          res1.isString() && res2.isInteger())
      { Expression res2incr = 
          new BinaryExpression("+", res2, unitExpression); 
        res2incr.setType(res2.getType()); 
        Expression resx = 
          BasicExpression.newFunctionBasicExpression(
                     "subrange", res1, res2incr);
        resx.setType(res1.getType()); 
        return resx;  
      } // pointer addition

      if ("-".equals(op) && res1 != null && res2 != null &&
          res1.isString() && res2.isString())
      { Expression res1size = 
          new UnaryExpression("->size", res1); 
        Expression res2size = 
          new UnaryExpression("->size", res2); 
        res1size.setType(new Type("int", null)); 
        res2size.setType(new Type("int", null)); 
        Expression resx = 
          new BinaryExpression("-", res2size, res1size);
        resx.setType(new Type("int", null)); 
        return resx;  
      } // pointer subtraction


      return new BinaryExpression(op, res1, res2);   
    } 

    if ("multiplicativeExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      
      if ("%".equals(op))
      { Expression resx = 
           new BinaryExpression("mod", res1, res2); 
        resx.setType(new Type("int", null)); 
        return resx; 
      }
 
      Expression resx = new BinaryExpression(op, res1, res2);
      if (res1 != null) 
      { resx.setType(res1.getType()); } 
      return resx;    
    } 

    if ("shiftExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);
      
      BinaryExpression res2pow2 = 
        new BinaryExpression("->pow", 
              new BasicExpression(2), res2); 

      if ("<<".equals(op) && res1 != null)
      { Expression resx = 
          new BinaryExpression("*", res1, res2pow2); 
        resx.setType(res1.getType());
        resx.setBrackets(true);  
        return resx; 
      } 
      
      if (">>".equals(op))
      { Expression resx =
          new BinaryExpression("div", res1, res2pow2);
        resx.setBrackets(true);  
        resx.setType(new Type("int", null)); 
        return resx; 
      } 

      return new BinaryExpression(op, res1, res2);   
    } 

    if ("castExpression".equals(tag) && terms.size() == 4 && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + ""))
    { ASTTerm ct = (ASTTerm) terms.get(1);
      Type ctyp = ct.cdeclarationToType(          
             vartypes, varelemtypes, types, entities);

      System.out.println(">>> Cast-to type: " + ctyp); 
      System.out.println(); 

      if (ctyp == null)
      { ctyp = new Type(ct.literalForm(), null); }
	  
      ASTTerm arg = (ASTTerm) terms.get(3); 
      Expression res = arg.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      res.setBrackets(true); 
      Expression resx = 
         new BinaryExpression("->oclAsType", res, 
                                  new BasicExpression(ctyp));
      resx.setType(ctyp); 
      return resx;  
    } 

    if ("relationalExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      
      Expression resx = new BinaryExpression(op, res1, res2);
      resx.setType(new Type("boolean", null)); 
      return resx;    
    } 

    if ("equalityExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
      
      Expression resx; 
      if ("!=".equals(op))
      { if (res1.isString() || res1.isCollection())
        { BinaryExpression ineq = 
            new BinaryExpression("<>=", res1, res2);
          resx = new UnaryExpression("not", ineq); 
        }
        else 
        { resx = new BinaryExpression("/=", res1, res2); }
        resx.setType(new Type("boolean", null)); 
      } 
      else if ("==".equals(op))
      { if (res1.isString() || res1.isCollection())
        { resx = new BinaryExpression("<>=", res1, res2); }
        else 
        { resx = new BinaryExpression("=", res1, res2); }
        resx.setType(new Type("boolean", null)); 
      } 
      else 
      { resx = new BinaryExpression(op, res1, res2); } 
      resx.setType(new Type("boolean", null)); 
      return resx;  
    } 

    if ("andExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
           vartypes, varelemtypes, types, entities);

      if ("&".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx =
          BasicExpression.newStaticCallBasicExpression(
              "bitwiseAnd", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx; 
      }
  
      return new BinaryExpression(op, res1, res2);   
    } 

    if ("exclusiveOrExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
            vartypes, varelemtypes, types, entities);

      if ("^".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx = 
          BasicExpression.newStaticCallBasicExpression(
             "bitwiseXor", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx;
      }
  
      return new BinaryExpression(op, res1, res2);   
    } 

    if ("inclusiveOrExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);

      if ("|".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx =
          BasicExpression.newStaticCallBasicExpression(
             "bitwiseOr", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx;
      }
  
      return new BinaryExpression(op, res1, res2);   
    } 

    if ("logicalAndExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);

      if ("&&".equals(op))
      { Expression resx = new BinaryExpression("&", res1, res2); 
        resx.setType(new Type("boolean", null)); 
        return resx; 
      }
  
      return new BinaryExpression(op, res1, res2);   
    } 

    if ("logicalOrExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(
          vartypes, varelemtypes, types, entities);

      if ("||".equals(op))
      { Expression resx =
          new BinaryExpression("or", res1, res2); 
        resx.setType(new Type("boolean", null)); 
        return resx;
      }
  
      return new BinaryExpression(op, res1, res2);   
    } 

    if ("conditionalExpression".equals(tag) && terms.size() == 5)
    { ASTTerm test = (ASTTerm) terms.get(0); 
      ASTTerm ifPart = (ASTTerm) terms.get(2); 
      ASTTerm elsePart = (ASTTerm) terms.get(4);
      Expression testExpr = test.cexpressionToKM3(vartypes, varelemtypes, types, entities);
      if (testExpr != null && testExpr.isNumeric())
      { testExpr.setBrackets(true); 
        testExpr = 
          new BinaryExpression("/=", testExpr, zeroExpression); 
      } 
      testExpr.setType(new Type("boolean", null)); 

      Expression ifExpr = ifPart.cexpressionToKM3(vartypes, varelemtypes, types, entities);
      Expression elseExpr = elsePart.cexpressionToKM3(vartypes, varelemtypes, types, entities);
      Expression resx = new ConditionalExpression(testExpr, 
                                       ifExpr, elseExpr);
      resx.setType(ifExpr.getType()); 
      return resx;  
    } 

    if ("assignmentExpression".equals(tag) && terms.size() == 3)
    { String op = ((ASTTerm) terms.get(1)).literalForm(); 
      ASTTerm arg1 = (ASTTerm) terms.get(0); 
      Expression res1 = arg1.cexpressionToKM3(vartypes, varelemtypes, types, entities);
      ASTTerm arg2 = (ASTTerm) terms.get(2); 
      Expression res2 = arg2.cexpressionToKM3(vartypes, varelemtypes, types, entities);

      if ("=".equals(op))
      { return res1; } // res1 := res2 
      
      if ("+=".equals(op))
      { Expression resx = new BinaryExpression("+", res1, res2); 
        resx.setType(res1.getType()); 
        return resx; 
      }
 
      if ("-=".equals(op))
      { Expression resx = new BinaryExpression("-", res1, res2); 
        resx.setType(res1.getType()); 
        return resx;
      } 

      if ("*=".equals(op))
      { Expression resx = new BinaryExpression("*", res1, res2); 
        resx.setType(res1.getType()); 
        return resx;
      } 

      if ("/=".equals(op))
      { return new BinaryExpression("/", res1, res2); }
 
      if ("%=".equals(op))
      { return new BinaryExpression("mod", res1, res2); } 

      if ("<<=".equals(op))
      { BinaryExpression res2pow2 = 
          new BinaryExpression("->pow", 
              new BasicExpression(2), res2); 
        
        Expression resx = 
          new BinaryExpression("*", res1, res2pow2);
        resx.setType(res1.getType()); 
        return resx;  
      } 

      if (">>=".equals(op))
      { BinaryExpression res2pow2 = 
          new BinaryExpression("->pow", 
              new BasicExpression(2), res2); 
        Expression resx = 
             new BinaryExpression("div", res1, res2pow2);
        resx.setType(res1.getType()); 
        return resx; 
      } 

      if ("|=".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseOr", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx; 
      }

      if ("^=".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseXor", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx;
      }

      if ("&=".equals(op))
      { Vector pars = new Vector(); 
        pars.add(res1); 
        pars.add(res2); 
         
        Expression resx = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseAnd", "MathLib", pars);
        resx.setType(new Type("int", null)); 
        return resx;
      }

      return new BinaryExpression(op, res1, res2);   
    } // set types for these

    return null; 

  } 

  public static Expression sizeofExpression(Expression res, 
                              Vector types, Vector entities)
  { Type t = res.getType(); 
    System.out.println(">>-- sizeofExpression " + res + " " + t); 

    String tname = "int"; 
    
    if (t == null) 
    { String resstr = res + ""; 
      if (resstr.startsWith("(") && 
          resstr.endsWith(")"))
      { tname = resstr.substring(1,resstr.length()-1); } 
      else  
      { tname = resstr; } 
    } 
    else 
    { tname = t.getName(); }  

    System.out.println(">>-- sizeofExpression " + tname); 

    return sizeofExpression(tname,types,entities); 
  } // records - classes; sequences

  public static Expression sizeofExpression(Type typ, 
                              Vector types, Vector entities)
  { if (typ == null) 
    { return new BasicExpression(4); } 
    String tname = typ.getName(); 
    return sizeofExpression(tname,types,entities); 
  } // records - classes; sequences

  public static Expression sizeofExpression(String tname, 
                             Vector types, Vector entities)
  { if ("double".equals(tname) || tname.startsWith("long") ||
        "time_t".equals(tname) || "clock_t".equals(tname) ||
        "size_t".equals(tname) || "fpos_t".equals(tname) ) 
    { Expression res = new BasicExpression(8); 
      res.setsizeofType(new Type("long", null)); 
      return res; 
    } 

    if ("char".equals(tname)) 
    { Expression res = new BasicExpression(1); 
      res.setsizeofType(new Type("int", null));
      return res;  
    } 

    Entity ent = 
      (Entity) ModelElement.lookupByName(tname,entities); 
    if (ent != null) 
    { Expression res = new BasicExpression(
                            ent.sizeof(types,entities)); 
      res.setsizeofType(new Type(ent)); 
      System.out.println(">-- sizeoftype of " + tname + " is " + res.getsizeofType()); 
      return res; 
    } 

    Expression be = new BasicExpression(4);
    be.setsizeofType(new Type(tname, null)); 
    System.out.println(">>- sizeoftype of " + tname + " is " + 
                be.getsizeofType()); 
    return be;  
  } // records - classes; sequences

  public Statement cfunctioncallPresideeffect(String fname, 
                           Expression arre, Vector args, 
                           java.util.Map vtypes, Vector ents)
  { System.out.println("+++ cfunctioncallPresideeffect for " + fname + " " + args); 

    if (ASTTerm.cqueryFunction(fname)) 
    { return null; } 

    if ("realloc".equals(fname) && args.size() == 2) 
    { Expression ptr = (Expression) args.get(0);
      Expression sze = (Expression) args.get(1); 
      // Create the new array and copy the old one to it. 
      BasicExpression tmp = 
        BasicExpression.newVariableBasicExpression(
                                          "_tmpRealloc");
      tmp.setType(ptr.getType()); 
      tmp.setElementType(ptr.getElementType());

      SetExpression resexpr = 
        // new BinaryExpression("->resizeTo", ptr, sze);
        SetExpression.newRefSetExpression(sze);
      resexpr.setType(ptr.getType()); 
      resexpr.setElementType(ptr.getElementType());
      ptr.setArray(true);
      tmp.setArray(true);  
      resexpr.setArray(true);   
      
      // creation statement 
      CreationStatement cs = 
        new CreationStatement(tmp); 
      cs.setType(ptr.getType()); 
      cs.setElementType(ptr.getElementType()); 
      cs.setInitialisation(resexpr); 

      // AssignStatement asgn = 
      //   new AssignStatement(tmp, resexpr); 

      SequenceStatement sqstat = new SequenceStatement(); 
      sqstat.addStatement(cs);
      // sqstat.addStatement(asgn); 

      // UnaryExpression argn = 
      //   new UnaryExpression("->size", ptr); 
      Expression argnsub = 
        new BinaryExpression("-", sze, unitExpression); 
      Vector pars = new Vector(); 
      pars.add(zeroExpression); 
      pars.add(argnsub);  
      Expression intsubrange = 
        BasicExpression.newFunctionBasicExpression("subrange",
                              "Integer", pars);
      intsubrange.setType(new Type("Sequence", null)); 
      intsubrange.setElementType(new Type("int", null)); 

      String ind = Identifier.nextIdentifier("_var"); 
      Expression indexexpr = 
         BasicExpression.newVariableBasicExpression(ind);   
      indexexpr.setType(new Type("int", null));

      Expression arg0incr = 
         new BinaryExpression("+", ptr, indexexpr);
      arg0incr.setBrackets(true);
      Expression arg1incr = 
         new BinaryExpression("+", tmp, indexexpr);   
      arg1incr.setBrackets(true);
      Expression arg0deref = 
        new UnaryExpression("!", arg0incr); 
      Expression arg1deref = 
        new UnaryExpression("!", arg1incr); 

      Expression test = 
         new BinaryExpression(":", indexexpr, intsubrange); 
      test.setType(new Type("boolean", null)); 

      AssignStatement cpy = 
         new AssignStatement(arg1deref, arg0deref); 
      WhileStatement forstat = 
        new WhileStatement(test, cpy); 
      forstat.setLoopKind(Statement.FOR);
      forstat.setLoopVar(indexexpr); 
      forstat.setIterationRange(intsubrange);  

      sqstat.addStatement(forstat);   
      return sqstat; 
    }  
    else if ("strtok".equals(fname) && args.size() == 2)
    { // if s /= "" then _tok_string := s else skip ;
      // if _tok_string->hasMatch(ct) 
      // then tok_token := _tok_string->firstMatch(ct); 
      //   _tok_ind := _tok_string->indexOf(_tok_token) + _tok_token.size;
      //   _tok_string := _tok_string.substring(_tok_ind)
      // else _tok_token := ""; _tok_ind := 0; 
      //   _tok_string := "" 

      Expression s = (Expression) args.get(0);
      Expression ct = (Expression) args.get(1);
      s.setType(new Type("String", null)); 
      ct.setType(new Type("String", null));

      Expression indexexpr = 
         BasicExpression.newVariableBasicExpression("_tok_ind");   
      indexexpr.setType(new Type("int", null));
      Expression tokenexpr = 
         BasicExpression.newVariableBasicExpression(
                        "_tok_token");   
      tokenexpr.setType(new Type("String", null));
      Expression tokstringexpr = 
         BasicExpression.newVariableBasicExpression(
                        "_tok_string");   
      tokstringexpr.setType(new Type("String", null));
      
      Expression nonempty = 
        new BinaryExpression("/=",s,emptyStringExpression);
      nonempty.setType(new Type("boolean", null)); 
      AssignStatement assigns = 
        new AssignStatement(tokstringexpr, s);   
      ConditionalStatement cond1 = 
        new ConditionalStatement(
                   nonempty,assigns,skipStatement);
      
      SequenceStatement stat0 = new SequenceStatement();
      AssignStatement asgn1 = 
        new AssignStatement(tokenexpr,  
          new BinaryExpression("->firstMatch", 
                               tokstringexpr, ct)); 
      stat0.addStatement(asgn1); 
      Expression indof = 
        new BinaryExpression("->indexOf", tokstringexpr, ct);
      Expression sizetok = 
        new UnaryExpression("->size", tokenexpr);  
      AssignStatement asgn2 = 
        new AssignStatement(indexexpr,  
          new BinaryExpression("+", indof, sizetok)); 
      stat0.addStatement(asgn2); 
      Expression substr = 
        BasicExpression.newFunctionBasicExpression("substring", 
                                      tokstringexpr, indexexpr); 
      AssignStatement asgn3 = 
        new AssignStatement(tokstringexpr, substr); 
      stat0.addStatement(asgn3); 

      SequenceStatement stat1 = new SequenceStatement();
      AssignStatement asgn4 = 
        new AssignStatement(tokenexpr, emptyStringExpression);   
      stat1.addStatement(asgn4); 
      AssignStatement asgn5 = 
        new AssignStatement(indexexpr, zeroExpression); 
      stat1.addStatement(asgn5); 
      AssignStatement asgn6 = 
        new AssignStatement(
               tokstringexpr, emptyStringExpression); 
      stat1.addStatement(asgn6); 
      
      Expression test = 
        new BinaryExpression("->hasMatch", tokstringexpr, ct); 
      ConditionalStatement cond2 =
        new ConditionalStatement(test,stat0,stat1);
      SequenceStatement res = new SequenceStatement(); 
      res.addStatement(cond1); 
      res.addStatement(cond2); 
      return res;   
    } // Use OclRegex find. 

    return null; 
  }

  public Statement cfunctioncallUpdateForm(String fname, 
                           Expression arre, Vector args, 
                           java.util.Map vtypes, Vector ents)
  { System.out.println("+++ cfunctioncallUpdateForm for " + fname + " " + args); 

    if (ASTTerm.cqueryFunction(fname)) 
    { return null; } 
    
    if ("strcpy".equals(fname) && args.size() == 2)
    { Expression arg0 = (Expression) args.get(0);
      Expression arg1 = (Expression) args.get(1);
      arg1.setType(new Type("String", null)); 
      return new AssignStatement(arg0, arg1);  
    }  
    else if ("strncpy".equals(fname) && args.size() == 3)
    { Expression arg0 = (Expression) args.get(0);
      Expression arg1 = (Expression) args.get(1);
      arg1.setType(new Type("String", null));
      Expression argn = (Expression) args.get(2);
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(argn);  
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, pars);  
      fbe.setType(new Type("String", null));
      return new AssignStatement(arg0, fbe); 
    }  
    else if (("memcpy".equals(fname) || 
              "memmove".equals(fname)) && args.size() == 3)
    { // for i : 0..argn-1 
      // do !(arg0 + i) := !(arg1 + i)

      Expression arg0 = (Expression) args.get(0);
      Expression arg1 = (Expression) args.get(1);
      arg0.setType(new Type("Ref", null));
      arg1.setType(new Type("Ref", null));
      Expression argn = (Expression) args.get(2);

      Expression argnsub = 
        new BinaryExpression("-", argn, unitExpression); 
      Vector pars = new Vector(); 
      pars.add(zeroExpression); 
      pars.add(argnsub);  
      Expression intsubrange = 
        BasicExpression.newFunctionBasicExpression("subrange",
                              "Integer", pars);
      intsubrange.setType(new Type("Sequence", null)); 
      intsubrange.setElementType(new Type("int", null)); 

      String ind = Identifier.nextIdentifier("_var"); 
      Expression indexexpr = 
         BasicExpression.newVariableBasicExpression(ind);   
      indexexpr.setType(new Type("int", null));

      Expression arg0incr = 
         new BinaryExpression("+", arg0, indexexpr);
      arg0incr.setBrackets(true);
      Expression arg1incr = 
         new BinaryExpression("+", arg1, indexexpr);   
      arg1incr.setBrackets(true);
      Expression arg0deref = 
        new UnaryExpression("!", arg0incr); 
      Expression arg1deref = 
        new UnaryExpression("!", arg1incr); 

      Expression test = 
         new BinaryExpression(":", indexexpr, intsubrange); 
      test.setType(new Type("boolean", null)); 

      AssignStatement cpy = 
         new AssignStatement(arg0deref, arg1deref); 
      WhileStatement forstat = 
        new WhileStatement(test, cpy); 
      forstat.setLoopKind(Statement.FOR);
      forstat.setLoopVar(indexexpr); 
      forstat.setIterationRange(intsubrange);  
      return forstat; 
    } 
    else if ("realloc".equals(fname) && args.size() == 2)
    { return null; } 
    else if ("strcat".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      BinaryExpression sumstr = 
        new BinaryExpression("+", arg1, arg2); 
      sumstr.setType(new Type("String", null));
      return new AssignStatement(arg1,sumstr); 
    } // and side-effect 
    else if ("strncat".equals(fname) && args.size() == 3)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      Expression argn = (Expression) args.get(2); 
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(argn);  
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg2, pars);  
      fbe.setType(new Type("String", null));

      BinaryExpression sumstr = 
        new BinaryExpression("+", arg1, fbe); 
      sumstr.setType(new Type("String", null));
      return new AssignStatement(arg1, sumstr); 
    } 
    else if ("srand".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Vector pars = new Vector();
      pars.add(new BinaryExpression("mod", arg1, 
                        new BasicExpression(30269))); 
      pars.add(new BinaryExpression("mod", arg1, 
                        new BasicExpression(30307))); 
      pars.add(new BinaryExpression("mod", arg1, 
                        new BasicExpression(30323))); 
 
      Expression mcall = 
        BasicExpression.newStaticCallBasicExpression(
          "setSeeds", 
          "MathLib", pars); 
      InvocationStatement stat = 
        InvocationStatement.newInvocationStatement(
                                         mcall,pars); 
      return stat; 
    } 
    else if ("free".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Expression delarg = 
        new UnaryExpression("->isDeleted", arg1); 
      ImplicitInvocationStatement ee = 
        new ImplicitInvocationStatement(delarg); 
      return ee; 
    } // But !p is deleted, not p?
    else if ("abort".equals(fname) && args.size() == 0)
    { Expression fail = 
        BasicExpression.newStaticCallBasicExpression("exit",
          "OclProcess", unitExpression); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(fail, 
                                         unitExpression); 
      return ee; 
    } 
    else if ("exit".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Expression fail = 
        BasicExpression.newStaticCallBasicExpression("exit",
          "OclProcess", arg1); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(fail, 
                                                   arg1); 
      return ee; 
    } 
    else if ("system".equals(fname) && args.size() == 1) 
    { Expression arg1 = (Expression) args.get(0);
      Expression par0 = new BasicExpression("null"); 
      Vector pars = new Vector(); 
      pars.add(par0); 
      pars.add(arg1); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
                 "newOclProcess", "OclProcess", pars); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   pars); 
      return ee; 
    }    
    else if ("assert".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Expression msg = 
        new BasicExpression("\"Assertion failed: " + arg1 + "\""); 
      AssertStatement astn = 
        new AssertStatement(arg1,msg); 
      return astn; 
    } 
    else if ("raise".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      String err = Type.getOCLExceptionForC(arg1 + ""); 
      BasicExpression errbe = 
        BasicExpression.newStaticCallBasicExpression(
          "new" + err, err); 
      errbe.setParameters(new Vector()); 
      ErrorStatement astn = 
        new ErrorStatement(errbe); 
      return astn; 
    } 
    else if ("printf".equals(fname) && args.size() > 1) 
    { // System_out.printf(Sequence{args`tail})

      Expression fmt = (Expression) args.get(0);
      Vector elems = new Vector(); 
      for (int i = 1; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Vector argf = new Vector(); 
      argf.add(fmt); 
      argf.add(sq); 
      Expression stdout = new BasicExpression("System_out"); 
      stdout.setType(new Type("OclFile", null));
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
                 "printf", stdout, 
                 argf); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   argf); 
             
      return ee; 
    }
    else if ("fprintf".equals(fname) && args.size() > 2) 
    { Expression fle = (Expression) args.get(0); 
      Expression fmt = (Expression) args.get(1);
      Vector elems = new Vector(); 
      for (int i = 2; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Vector argf = new Vector(); 
      argf.add(fmt); 
      argf.add(sq); 
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
                 "printf", fle, 
                 argf); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   argf); 
             
      return ee; 
    }
    else if ("sprintf".equals(fname) && args.size() > 2) 
    { Expression fle = (Expression) args.get(0); 
      Expression fmt = (Expression) args.get(1);
      Vector elems = new Vector(); 
      for (int i = 2; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Vector argf = new Vector(); 
      
      argf.add(fmt); 
      argf.add(sq); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
                 "format", "StringLib", 
                 argf); 
      AssignStatement ee = 
        new AssignStatement(fle,res); 
             
      return ee; 
    }
    else if ("scanf".equals(fname) && args.size() > 1) 
    { // sq := StringLib.scan(System_in.readLine(),fmt)

      Expression fmt = (Expression) args.get(0);
      Vector elems = new Vector(); 
      for (int i = 1; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Expression stdin = new BasicExpression("System_in"); 
      stdin.setType(new Type("OclFile", null));
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
                 "readLine", stdin);
      Vector pars = new Vector();
      pars.add(res); 
      pars.add(fmt); 
      BasicExpression resx = 
        BasicExpression.newStaticCallBasicExpression(
                 "scan", "StringLib", pars);  
      resx.setType(new Type("Sequence",null)); 
      resx.setElementType(new Type("String", null)); 
      AssignStatement ee = 
        new AssignStatement(sq, resx); 
      return ee; 
    }
    else if ("fscanf".equals(fname) && args.size() > 2) 
    { Expression fle = (Expression) args.get(0); 
      Expression fmt = (Expression) args.get(1);
      Vector elems = new Vector(); 
      for (int i = 2; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
                 "readLine", fle); 
      Vector pars = new Vector();
      pars.add(res); 
      pars.add(fmt); 
      BasicExpression resx = 
        BasicExpression.newStaticCallBasicExpression(
                 "scan", "StringLib", pars); 
      resx.setType(new Type("Sequence",null)); 
      resx.setElementType(new Type("String", null)); 
 
      AssignStatement ee = 
        new AssignStatement(sq, resx); 
             
      return ee; 
    }
    else if ("sscanf".equals(fname) && args.size() > 2) 
    { Expression fle = (Expression) args.get(0); 
      Expression fmt = (Expression) args.get(1);
      Vector elems = new Vector(); 
      for (int i = 2; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Vector argf = new Vector();
      argf.add(fle);  
      argf.add(fmt); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
                 "scan", "StringLib", 
                 argf); 
      res.setType(new Type("Sequence",null)); 
      res.setElementType(new Type("String", null)); 
      AssignStatement ee = 
        new AssignStatement(sq,res); 
             
      return ee; 
    }
    else if ("fflush".equals(fname) && args.size() == 1)
    { Expression fle = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "flush", fle);
      Vector argf = new Vector(); 
      argf.add(fle); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   argf); 
             
      return ee; 
    }  
    else if ("fclose".equals(fname) && args.size() == 1)
    { Expression fle = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "closeFile", fle);
      Vector argf = new Vector(); 
      argf.add(fle); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   argf); 
             
      return ee; 
    }  
    else if ("remove".equals(fname) && args.size() == 1)
    { Expression fle = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
             "deleteFile", "OclFile", fle);
      Vector argf = new Vector(); 
      argf.add(fle); 
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   argf); 
             
      return ee; 
    }  
    else if ("rename".equals(fname) && args.size() == 2)
    { Expression fle = (Expression) args.get(0);
      Expression newfle = (Expression) args.get(1);
      Vector pars = new Vector(); 
      pars.add(fle); 
      pars.add(newfle); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
             "renameFile", "OclFile", pars);
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   pars); 
             
      return ee; 
    }  
    else if ("fgets".equals(fname) && args.size() == 3) 
    { Expression s = (Expression) args.get(0);
      Expression n = (Expression) args.get(1);
      Expression fle = (Expression) args.get(2);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "readLine", fle); 
      res.setType(new Type("String", null)); 
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(n); 
      Expression intres = 
        BasicExpression.newFunctionBasicExpression(
           "subrange", res, pars); 
      intres.setType(new Type("String", null)); 

      return new AssignStatement(s,intres); 
    } 
    else if ("gets".equals(fname) && args.size() == 1) 
    { Expression s = (Expression) args.get(0);
      Expression fle = new BasicExpression("System_in"); 
      fle.setType(new Type("OclFile", null)); 
        
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "readLine", fle); 
      res.setType(new Type("String", null)); 
      
      return new AssignStatement(s,res); 
    }
    else if ("fread".equals(fname) && args.size() == 4) 
    { Expression data = (Expression) args.get(0); 
      Expression n = (Expression) args.get(2);
      Expression fle = (Expression) args.get(3); 
      // if (data.isStringSequence()) 
      { Expression readN = 
          BasicExpression.newCallBasicExpression(
            "readN", fle, n);                   
        return new AssignStatement(data, readN); 
      }
    }   
    else if ("fwrite".equals(fname) && args.size() == 4)
    { Expression fle = (Expression) args.get(3);
      Expression data = (Expression) args.get(0);
      Expression sze = (Expression) args.get(1); 
      Expression n = (Expression) args.get(2);
      
      if (data.isStringSequence())
      { // fle.write(data.subrange(1,n)->sum())
        Vector pars = new Vector(); 
        pars.add(unitExpression); 
        pars.add(n); 
        Expression subrng = 
          BasicExpression.newFunctionBasicExpression(
              "subrange", data, pars); 
        Expression sumexpr = 
          new UnaryExpression("->sum", subrng); 
        BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "write", fle, sumexpr);
        InvocationStatement ee = 
          InvocationStatement.newInvocationStatement(res, 
                                                     sumexpr); 
        return ee; 
      }
      else if (data.isIntSequence())   
      { // fle.write(data.subrange(1,n)->collect( 
        //                _z | _z->byte2char() )->sum()
        Vector pars = new Vector(); 
        pars.add(unitExpression); 
        pars.add(n); 
        Expression subrng = 
          BasicExpression.newFunctionBasicExpression(
              "subrange", data, pars); 
        BasicExpression chr = 
          BasicExpression.newVariableBasicExpression("_chr"); 
        chr.setType(new Type("int", null)); 
        Expression coldom = 
          new BinaryExpression(":", chr, subrng); 
        Expression par = 
          new UnaryExpression("->byte2char", chr);
        Expression colexpr =
          new BinaryExpression("|C", coldom, par); 
 
        Expression sumexpr = 
          new UnaryExpression("->sum", colexpr); 
        BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "write", fle, sumexpr);
        InvocationStatement ee = 
          InvocationStatement.newInvocationStatement(res, 
                                                     sumexpr); 
        return ee; 
      } 
      else if (data.isLongSequence())   
      { // fle.writeNbytes(data.subrange(1,n)->collect(
        //   _z| MathLib.integer2Nbytes(_z,sze)),n*sze) 

        Vector pars0 = new Vector(); 
        pars0.add(unitExpression); 
        pars0.add(n); 
        Expression subrng = 
          BasicExpression.newFunctionBasicExpression(
              "subrange", data, pars0); 
        BasicExpression chr = 
          BasicExpression.newVariableBasicExpression("_z"); 
        chr.setType(new Type("long", null)); 
        Expression coldom = 
          new BinaryExpression(":", chr, subrng);
        Vector pars1 = new Vector(); 
        pars1.add(chr); 
        pars1.add(sze);  
        Expression colrng = 
          BasicExpression.newStaticCallBasicExpression(
            "integer2Nbytes", "MathLib", pars1);
        Expression colexpr =
          new BinaryExpression("|C", coldom, colrng); 
        Expression prd = 
          new BinaryExpression("*", n, sze); 
        Vector pars2 = new Vector(); 
        pars2.add(colexpr);
        pars2.add(prd);  
 
        BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "writeNbytes", fle, pars2);
        InvocationStatement ee = 
          InvocationStatement.newInvocationStatement(res, 
                                                     pars2); 
        return ee; 
      } 
    }  
    else if (("putc".equals(fname) ||
              "fputc".equals(fname)) && args.size() == 2)
    { Expression fle = (Expression) args.get(1);
      Expression chr = (Expression) args.get(0);
      Expression par = 
        new UnaryExpression("->byte2char", chr); 

      if (chr instanceof UnaryExpression && 
          ((UnaryExpression) chr).operator.equals("->char2byte"))
      { par = ((UnaryExpression) chr).argument; }  

      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "write", fle, par);
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   par); 
      return ee; 
    }  
    else if ("fputs".equals(fname) && args.size() == 2)
    { Expression fle = (Expression) args.get(1);
      Expression chr = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "writeln", fle, chr);
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   chr); 
      return ee; 
    }  
    else if ("puts".equals(fname) && args.size() == 1)
    { // System_out.writeln(_1)

      Expression chr = (Expression) args.get(0);
      BasicExpression systemOut = 
        new BasicExpression("System_out"); 
      systemOut.setType(new Type("OclFile", null)); 
        
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "writeln", systemOut, chr);
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   chr); 
      return ee; 
    }  
    else if ("putchar".equals(fname) && args.size() == 1)
    { // System_out.write(_1->byte2char())

      Expression fle = new BasicExpression("System_out"); 
      fle.setType(new Type("OclFile", null)); 
        
      Expression chr = (Expression) args.get(0);
      Expression par = 
        new UnaryExpression("->byte2char", chr); 
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "write", fle, par);
      InvocationStatement ee = 
        InvocationStatement.newInvocationStatement(res, 
                                                   par); 
      return ee; 
    }  
    else if ("fgetpos".equals(fname) && args.size() == 2)
    { Expression fle = (Expression) args.get(0);
      Expression ptr = (Expression) args.get(1);

      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "getPosition", fle); 
      res.setType(new Type("long", null));

      UnaryExpression deref = 
        new UnaryExpression("!", ptr);  
      AssignStatement asgn = 
        new AssignStatement(deref, res); 
      
      return asgn; 
    } 
    else if ("fseek".equals(fname) && args.size() == 3)
    { Expression fle = (Expression) args.get(0);
      Expression offset = (Expression) args.get(1);

      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "skipBytes", fle, offset); 
      InvocationStatement s1 = 
          InvocationStatement.newInvocationStatement(res,
                                                     offset); 

      BasicExpression res1 = 
          BasicExpression.newCallBasicExpression(
             "mark", fle); 
      InvocationStatement s2 = 
          InvocationStatement.newInvocationStatement(res1); 
          
      SequenceStatement ss = 
          new SequenceStatement(s1,s2); 
      return ss; 
    } 
    else if ("fsetpos".equals(fname) && args.size() == 2)
    { Expression fle = (Expression) args.get(0);
      Expression offset = (Expression) args.get(1);
      UnaryExpression deref = 
        new UnaryExpression("!", offset);  

      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "skipBytes", fle, deref); 
      InvocationStatement s1 = 
          InvocationStatement.newInvocationStatement(res,
                                                     deref); 
      return s1; 
    }
    else if ("va_start".equals(fname) && args.size() == 2)
    { Expression va = (Expression) args.get(0);
      va.setType(new Type("int", null)); 
      
      return new AssignStatement(va, zeroExpression); 
    } 
    else if ("va_end".equals(fname) && args.size() == 1)
    { Expression va = (Expression) args.get(0);
      va.setType(new Type("int", null)); 
      
      return new AssignStatement(va, zeroExpression); 
    } 
    else if ("va_arg".equals(fname) && args.size() == 2)
    { Expression va = (Expression) args.get(0); 
      va.setType(new Type("int", null)); 
      
      Expression incr = 
        new BinaryExpression("+", va, unitExpression); 
      return new AssignStatement(va, incr); 
    } 
    else if ("modf".equals(fname) && args.size() == 2)
    { Expression x = (Expression) args.get(0); 
      Expression ip = (Expression) args.get(1); 
      x.setType(new Type("double", null)); 
      Type refdouble = new Type("Ref", null);
      refdouble.setElementType(new Type("double", null)); 
      ip.setType(refdouble); 
      Expression flrflr = 
        new UnaryExpression("->floor", x); 
      Expression deref = 
        new UnaryExpression("!", ip); 
      return new AssignStatement(deref, flrflr); 
    } 
    else if ("frexp".equals(fname) && args.size() == 2) 
    { Expression x = (Expression) args.get(0); 
      Expression ip = (Expression) args.get(1); 
      x.setType(new Type("double", null)); 
      Type refint = new Type("Ref", null);
      refint.setElementType(new Type("int", null)); 
      ip.setType(refint); 
      Expression deref = 
        new UnaryExpression("!", ip); 

      Expression logx = new UnaryExpression("->log", x); 
      Expression log2 = new UnaryExpression("->log", 
                               new BasicExpression(2)); 

      Expression log2x = 
        new BinaryExpression("/", logx, log2);
      log2x.setBrackets(true);  
      Expression floorlog = 
         new UnaryExpression("->floor", log2x); 
      Expression floorlogincr = 
         new BinaryExpression("+", floorlog, unitExpression); 
      Expression x2pow = 
        new BinaryExpression("->pow", new BasicExpression(2),
                             floorlogincr); 

      BasicExpression intt = 
        new BasicExpression(new Type("int", null)); 

      BinaryExpression x2powcast = 
         new BinaryExpression("->oclAsType", x2pow, intt); 

      Expression dzero = new BasicExpression(0.0); 
      BinaryExpression eqzero = 
         new BinaryExpression("=", x, dzero); 
      AssignStatement assignzero = 
         new AssignStatement(deref, zeroExpression); 
      AssignStatement assignpow = 
         new AssignStatement(deref, x2powcast); 

      return new ConditionalStatement(eqzero, assignzero, 
                                      assignpow); 
    } 
    else if ("strtod".equals(fname) && args.size() == 2)
    { Expression x = (Expression) args.get(0); 
      Expression endp = (Expression) args.get(1); 
      x.setType(new Type("String", null)); 
      Type refString = new Type("Ref", null);
      refString.setElementType(new Type("String", null)); 
      endp.setType(refString); 

      Expression patt = 
        BasicExpression.newValueBasicExpression(
                                      "\"[0-9]+.[0-9]+\""); 
      patt.setType(new Type("String", null)); 

      Expression firstmatch = 
        new BinaryExpression("->firstMatch", x, patt);
      firstmatch.setType(new Type("String", null)); 
      Expression aftermatch = 
        new BinaryExpression("->after", x, firstmatch);  
      aftermatch.setType(new Type("String", null)); 
      Expression deref = 
        new UnaryExpression("!", endp); 
      AssignStatement asgn1 =
        new AssignStatement(deref, aftermatch); 
      return asgn1; 
    } 
    else if (("strtol".equals(fname) || 
              "strtoul".equals(fname)) && args.size() >= 2)
    { Expression x = (Expression) args.get(0); 
      Expression endp = (Expression) args.get(1); 
      x.setType(new Type("String", null)); 
      Type refString = new Type("Ref", null);
      refString.setElementType(new Type("String", null)); 
      endp.setType(refString); 

      Expression patt = 
        BasicExpression.newValueBasicExpression(
                     "\"0x[0-9A-F]+|0[0-7]*|[1-9][0-9]*\""); 
      patt.setType(new Type("String", null)); 

      Expression firstmatch = 
        new BinaryExpression("->firstMatch", x, patt);
      firstmatch.setType(new Type("String", null)); 
      Expression aftermatch = 
        new BinaryExpression("->after", x, firstmatch);  
      aftermatch.setType(new Type("String", null)); 
      Expression deref = 
        new UnaryExpression("!", endp); 
      AssignStatement asgn1 =
        new AssignStatement(deref, aftermatch); 
      return asgn1; 
    } 


    System.out.println(">>> C Function update form for " + arre + " " + args); 
    System.out.println(); 
    // System.out.println(ents); 
    // System.out.println(entities); 
    // System.out.println(); 

    Entity mainC = (Entity) ModelElement.lookupByName(
                                      "FromC", ents);
    if (mainC != null) 
    { BehaviouralFeature bf = mainC.getOperation(fname); 

      if (bf != null) 
      { System.out.println(">>> Function defined in main program: " + fname + " " + bf.display() + " " + bf.isVarArg()); } 

      if (bf != null && 
          bf.hasStereotype("vararg"))
      { // Convert args to a call of args + sq arg
        Vector pars = bf.getParameters(); 
        Vector newargs = new Vector(); 
        for (int i = 0; i < pars.size() - 1; i++)
        { newargs.add(args.get(i)); } 
        SetExpression sq = new SetExpression(true); 
        for (int i = pars.size()-1; i < args.size(); i++) 
        { sq.addElement((Expression) args.get(i)); } 
        newargs.add(sq);
        Expression earg = 
          new BasicExpression(mainC); 
        earg.setElementType(new Type(mainC));  
        BasicExpression be = 
          BasicExpression.newCallBasicExpression(
                                      fname,newargs);
        be.setStatic(true);  
        be.entity = mainC; 
        InvocationStatement executecall = 
          InvocationStatement.newInvocationStatement(be,
                                                     newargs); 
        return executecall; 
      }
      else if (bf != null) 
      { Expression earg = 
          new BasicExpression(mainC); 
        earg.setElementType(new Type(mainC));  
        BasicExpression bef = 
          BasicExpression.newCallBasicExpression(fname,
                                                 earg,
                                                 args);
        bef.entity = mainC;  
        bef.setStatic(true); 
        InvocationStatement executecall = 
           InvocationStatement.newInvocationStatement(bef,
                                                     args); 
        return executecall;  
      } 
    } 
 
    Type ftype = (Type) vtypes.get(fname); 
    if (ftype != null) 
    { // A local variable, must be of function type
      Expression call = 
        UnaryExpression.argumentsToLambdaCall(fname, args); 
      InvocationStatement executecall = 
          InvocationStatement.newInvocationStatement(call,
                                                     args); 
      return executecall; 
    } 
    else 
    { Expression call = 
        UnaryExpression.argumentsToLambdaCall(arre, args); 
      InvocationStatement executecall = 
          InvocationStatement.newInvocationStatement(call,
                                                     args); 
      return executecall; 
    } 


  /*  if (arre instanceof BasicExpression)
    { BasicExpression be = (BasicExpression) arre; 
      be.setParameters(args); 
      be.setIsEvent();
      be.setUmlKind(Expression.UPDATEOP); 
      InvocationStatement s1 = 
          InvocationStatement.newInvocationStatement(be,
                                                     args); 
      return s1; 
    }  
   
    return null; */ 
 
  } 

  public Expression cfunctioncallToKM3(
      String fname, Expression arre, Vector args, 
      java.util.Map vartypes, Vector ents)
  { if ("sin".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->sin", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    } 
    else if ("cos".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->cos", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("tan".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->tan", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("asin".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->asin", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    } 
    else if ("acos".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->acos", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("atan".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->atan", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("sinh".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->sinh", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    } 
    else if ("cosh".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->cosh", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("tanh".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->tanh", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("exp".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->exp", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    } 
    else if ("log".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->log", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("log10".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->log10", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("sqrt".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->sqrt", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    } 
    else if ("ceil".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->ceil", arg1); 
      BinaryExpression resx = 
        new BinaryExpression("->oclAsType", res,
          new BasicExpression(new Type("double", null))); 

      resx.setType(new Type("double", null)); 
      return resx; 
    }
    else if ("floor".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->floor", arg1); 
      BinaryExpression resx = 
        new BinaryExpression("->oclAsType", res,
          new BasicExpression(new Type("double", null))); 
      resx.setType(new Type("double", null)); 
      return resx; 
    }
    else if ("fabs".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->abs", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("abs".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->abs", arg1); 
      res.setType(new Type("int", null)); 
      return res; 
    }
    else if ("labs".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->abs", arg1); 
      res.setType(new Type("long", null)); 
      return res; 
    }
    else if ("pow".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg2 = (Expression) args.get(1); 
      BinaryExpression res = new BinaryExpression("->pow", arg1, arg2); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("atan2".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0); 
      Expression arg2 = (Expression) args.get(1); 
      BinaryExpression res0 = new BinaryExpression("/", arg1, arg2); 
      res0.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->atan", res0); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("ldexp".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0); 
      Expression arg2 = (Expression) args.get(1); 
      BinaryExpression res0 = new BinaryExpression("->pow", new BasicExpression(2), arg2); 
      BinaryExpression res = new BinaryExpression("*", arg1, res0); 
      res.setType(new Type("double", null));
      res.setBrackets(true);  
      return res; 
    }
    else if ("fmod".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0); 
      Expression arg2 = (Expression) args.get(1); 
      BinaryExpression res = new BinaryExpression("mod", arg1, arg2); 
      res.setType(new Type("double", null)); 
      res.setBrackets(true);  
      return res; 
    }
    else if ("atof".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->toReal", arg1); 
      res.setType(new Type("double", null)); 
      return res; 
    }
    else if ("atoi".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->toInteger", arg1); 
      res.setType(new Type("int", null)); 
      return res; 
    }
    else if ("atol".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      UnaryExpression res = new UnaryExpression("->toLong", arg1); 
      res.setType(new Type("long", null)); 
      return res; 
    }
    else if ("isalnum".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg2 = new BasicExpression("\"[a-zA-Z0-9]\""); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1);

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      BinaryExpression res = 
        new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isalpha".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = new BasicExpression("\"[a-zA-Z]\""); 
      BinaryExpression res = 
        new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isdigit".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = new BasicExpression("\"[0-9]\""); 
      BinaryExpression res =
        new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("islower".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 
            
      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = new BasicExpression("\"[a-z]\""); 
      BinaryExpression res = 
        new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isupper".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 
      
      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = new BasicExpression("\"[A-Z]\""); 
      BinaryExpression res = 
         new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isspace".equals(fname) && args.size() == 1)
    { // arg1 = 32 or (arg1 <= 13 & arg1 >= 9)

      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression eqspace = 
         new BinaryExpression("=", arg1, 
                              new BasicExpression(32)); 
      BinaryExpression leqnl = 
         new BinaryExpression("<=", arg1, 
                 new BasicExpression(13)); 
      BinaryExpression geqnl = 
         new BinaryExpression(">=", arg1, 
                 new BasicExpression(9)); 
      BinaryExpression eqnl = 
         new BinaryExpression("&", geqnl, leqnl); 
      eqnl.setBrackets(true); 
      BinaryExpression res = 
         new BinaryExpression("or", eqspace, eqnl); 
      res.setType(new Type("boolean", null));
      res.setBrackets(true);  
      return res; 
    }
    else if ("iscntrl".equals(fname) && args.size() == 1)
    { // arg1 >= 0 & arg1 <= 31
      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression leqnl = 
         new BinaryExpression("<=", arg1, 
                 new BasicExpression(31)); 
      BinaryExpression geqnl = 
         new BinaryExpression(">=", arg1, 
                 new BasicExpression(0)); 
      BinaryExpression res = 
         new BinaryExpression("&", geqnl, leqnl); 
      res.setBrackets(true); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isgraph".equals(fname) && args.size() == 1)
    { // arg1 <= 126 & arg1 >= 33

      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression leqnl = 
         new BinaryExpression("<=", arg1, 
                 new BasicExpression(126)); 
      BinaryExpression geqnl = 
         new BinaryExpression(">=", arg1, 
                 new BasicExpression(33)); 
      BinaryExpression res = 
         new BinaryExpression("&", geqnl, leqnl); 
      res.setBrackets(true); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isprint".equals(fname) && args.size() == 1)
    { // arg1 <= 126 & arg1 >= 32

      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression leqnl = 
         new BinaryExpression("<=", arg1, 
                 new BasicExpression(126)); 
      BinaryExpression geqnl = 
         new BinaryExpression(">=", arg1, 
                 new BasicExpression(32)); 
      BinaryExpression res = 
         new BinaryExpression("&", geqnl, leqnl); 
      res.setBrackets(true); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("ispunct".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = new BasicExpression("\"[!-/:-@\\[-'{|}~]\""); 
      BinaryExpression res = 
         new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("isxdigit".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      Expression arg1str = 
        new UnaryExpression("->byte2char", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("->char2byte"))
      { arg1str = ((UnaryExpression) arg1).argument; }  

      Expression arg2 = 
         new BasicExpression("\"[a-fA-F0-9]\""); 
      BinaryExpression res = 
         new BinaryExpression("->isMatch", arg1str, arg2); 
      res.setType(new Type("boolean", null)); 
      return res; 
    }
    else if ("tolower".equals(fname) && args.size() == 1)
    { // if arg1 >= 65 & arg1 <= 90 then arg1 + 32 else arg1

      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression c1 = new BinaryExpression("<=", arg1,
                                  new BasicExpression(90));
      BinaryExpression c2 = new BinaryExpression(">=", arg1,
                                  new BasicExpression(65));
      BinaryExpression c = 
          new BinaryExpression("&", c1, c2);
      c.setType(new Type("boolean", null)); 
      c.setBrackets(true);  
      BinaryExpression subtr = 
          new BinaryExpression("+", arg1, 
                               new BasicExpression(32));
      subtr.setType(new Type("int", null));  
      Expression res = 
        new ConditionalExpression(c, subtr, arg1);
      res.setBrackets(true);  
      res.setType(new Type("int", null));  
      return res; 
    }
    else if ("toupper".equals(fname) && args.size() == 1)
    { // if arg1 >= 97 & arg1 <= 122 then arg1 - 32 else arg1

      Expression arg1 = (Expression) args.get(0); 
      arg1.setBrackets(true); 
      BinaryExpression c1 = new BinaryExpression("<=", arg1,
                                  new BasicExpression(122));
      BinaryExpression c2 = new BinaryExpression(">=", arg1,
                                  new BasicExpression(97));
      BinaryExpression c = 
          new BinaryExpression("&", c1, c2);
      c.setType(new Type("boolean", null)); 
      c.setBrackets(true);  
      BinaryExpression subtr = 
          new BinaryExpression("-", arg1, 
                               new BasicExpression(32)); 
      subtr.setType(new Type("int", null));  
      arg1.setType(new Type("int", null));  
      Expression res = 
        new ConditionalExpression(c, subtr, arg1);
      res.setBrackets(true);  
      res.setType(new Type("int", null));  
      return res; 
    }
    else if ("isnan".equals(fname) && 
             args.size() == 1)
    { Expression arg1 = (Expression) args.get(0); 
          
      UnaryExpression res = 
        new UnaryExpression("->oclIsInvalid", arg1); 
      res.setType(new Type("boolean", null)); 
      return res; 
    } 
    else if ("strcpy".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(1);
      arg1.setType(new Type("String", null)); 
      return arg1; 
    } // and side-effect 
    else if ("strncpy".equals(fname) && args.size() == 3)
    { Expression arg1 = (Expression) args.get(1);
      arg1.setType(new Type("String", null));
      Expression argn = (Expression) args.get(2);
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(argn);  
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, pars);  
      fbe.setType(new Type("String", null));
      return fbe; 
    } // and side-effect 
    else if ("strcat".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      BinaryExpression sumstr = 
        new BinaryExpression("+", arg1, arg2); 
      sumstr.setType(new Type("String", null));
      return sumstr; 
    } // and side-effect 
    else if ("strncat".equals(fname) && args.size() == 3)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      Expression argn = (Expression) args.get(2); 
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(argn);  
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg2, pars);  
      fbe.setType(new Type("String", null));

      BinaryExpression sumstr = 
        new BinaryExpression("+", arg1, fbe); 
      sumstr.setType(new Type("String", null));
      return sumstr; 
    } // and side-effect 
    else if ("strcmp".equals(fname) && args.size() == 2) 
    { // arg1->compareTo(arg2)
      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      BinaryExpression res = 
        new BinaryExpression("->compareTo", arg1, arg2); 
      res.setType(new Type("int", null)); 
      return res; 
    } 
    else if ("strncmp".equals(fname) && args.size() == 3) 
    { // arg1->compareTo(arg2)
      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      Expression argn = (Expression) args.get(2); 
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(argn);  
      BasicExpression fbe1 = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, pars);  
      fbe1.setType(new Type("String", null));
      BasicExpression fbe2 = 
        BasicExpression.newFunctionBasicExpression("subrange", arg2, pars);  
      fbe2.setType(new Type("String", null));

      BinaryExpression res = 
        new BinaryExpression("->compareTo", fbe1, fbe2); 
      res.setType(new Type("int", null)); 
      return res; 
    }
    else if ("strtok".equals(fname) && args.size() == 2)
    { Expression tokenexpr = 
         BasicExpression.newVariableBasicExpression(
                        "_tok_token");   
      tokenexpr.setType(new Type("String", null));
      return tokenexpr; 
    } 
    else if ("memcmp".equals(fname) && args.size() == 3) 
    { // arg1.subrange(1,n)->compareTo(arg2.subrange(1,n))
      Expression arg1 = (Expression) args.get(0);
      Expression arg2 = (Expression) args.get(1);
      Expression argn = (Expression) args.get(2); 
      Expression arg1s = 
        new BinaryExpression("->sequenceRange", arg1, argn); 
      Expression arg2s = 
        new BinaryExpression("->sequenceRange", arg2, argn); 
      arg1s.setType(new Type("Sequence", null));
      arg2s.setType(new Type("Sequence", null));

      BinaryExpression res = 
        new BinaryExpression("->compareTo", arg1s, arg2s); 
      res.setType(new Type("int", null)); 
      return res; 
    }
    else if ("strchr".equals(fname) && args.size() == 2)
    { // if arg1->indexOf(arg2) = 0 then null 
      // else arg1.subrange(arg1->indexOf(arg2)) endif

      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      Expression arg2str = 
        new UnaryExpression("->byte2char", arg2);

      if (arg2 instanceof UnaryExpression && 
          ((UnaryExpression) arg2).operator.equals("->char2byte"))
      { arg2str = ((UnaryExpression) arg2).argument; } 
 
      Expression ind = 
        new BinaryExpression("->indexOf", arg1, arg2str); 
      Expression test = 
        new BinaryExpression("=", ind, zeroExpression); 
      test.setType(new Type("boolean", null)); 
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, ind);  
      fbe.setType(new Type("String", null));

      Expression nullstring = 
         BasicExpression.newValueBasicExpression("\"\""); 
      nullstring.setType(new Type("String", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, nullstring, fbe);  
      conde.setType(new Type("String", null)); 
      return conde; 
    } 
    else if ("memchr".equals(fname) && args.size() == 3)
    { // if arg1.subrange(1,n)->indexOf(arg2) = 0 then null 
      // else arg1.subrange(arg1->indexOf(arg2)) endif
      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("Ref", null));
      Expression arg2 = (Expression) args.get(1);
      Expression n = (Expression) args.get(2);
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(n); 
      Expression arg1sub = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, pars);  
      Expression ind = 
        new BinaryExpression("->indexOf", arg1sub, arg2); 
      Expression test = 
        new BinaryExpression("=", ind, zeroExpression); 
      test.setType(new Type("boolean", null)); 
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, ind);  
      fbe.setType(new Type("Ref", null));
      fbe.setElementType(arg1.getElementType()); 

      Expression nullptr = 
         BasicExpression.newValueBasicExpression("null"); 
      nullptr.setType(new Type("Ref", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, nullptr, fbe); 
      conde.setType(new Type("Ref", null)); 
      fbe.setElementType(arg1.getElementType()); 
      return conde; 
    } 
    else if ("strrchr".equals(fname) && args.size() == 2)
    { // if arg1->lastIndexOf(arg2) = 0 then null 
      // else arg1.substring(arg1->lastIndexOf(arg2)) endif
      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      Expression arg2str = 
        new UnaryExpression("->byte2char", arg2); 
      if (arg2 instanceof UnaryExpression && 
          ((UnaryExpression) arg2).operator.equals("->char2byte"))
      { arg2str = ((UnaryExpression) arg2).argument; } 

      Expression ind = 
        new BinaryExpression("->lastIndexOf", arg1, arg2str); 
      Expression test = 
        new BinaryExpression("=", ind, zeroExpression); 
      test.setType(new Type("boolean", null)); 
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, ind);  
      fbe.setType(new Type("String", null));
 
      Expression nullstring = 
         BasicExpression.newValueBasicExpression("\"\""); 
      nullstring.setType(new Type("String", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, nullstring, 
              fbe); 
      conde.setType(new Type("String", null)); 
      return conde; 
    } 
    else if ("strlen".equals(fname) && args.size() == 1)
    { // _1->size()

      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      arg1.setBrackets(true); 
      UnaryExpression res = 
        new UnaryExpression("->size", arg1); 
      res.setType(new Type("int", null));
      return res; 
    } 
    else if ("strstr".equals(fname) && args.size() == 2)
    { // if _1->indexOf(_2) > 0 
      // then _1.subrange(_1->indexOf(_2)) else "" endif

      Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      arg1.setBrackets(true); 

      BinaryExpression inde = 
        new BinaryExpression("->indexOf", arg1, arg2); 

      BinaryExpression test = 
        new BinaryExpression(">", inde, zeroExpression); 
      test.setType(new Type("boolean", null)); 

      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange", arg1, inde);  
      fbe.setType(new Type("String", null));

      Expression nullstring = 
         BasicExpression.newValueBasicExpression("\"\""); 
      nullstring.setType(new Type("String", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, fbe, nullstring); 
      conde.setType(new Type("String", null));

      return conde;  
    }  
    else if ("strspn".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      arg1.setBrackets(true); 
      Expression matchExpr = 
        new BasicExpression("\"[\" + " + arg2 + " + \"]+\""); 
      matchExpr.setType(new Type("String", null)); 

      BinaryExpression inde = 
        new BinaryExpression("->firstMatch", arg1, matchExpr); 

      BinaryExpression test = 
        new BinaryExpression("->hasMatch", arg1, matchExpr); 
      test.setType(new Type("boolean", null)); 

      Expression expr1 = new UnaryExpression("->size", inde); 
      expr1.setType(new Type("int", null)); 

      ConditionalExpression cond1 = 
        new ConditionalExpression(
          new BinaryExpression("->hasPrefix", arg1, inde), 
          expr1, 
          zeroExpression); 
      cond1.setType(new Type("int", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, cond1, 
                                  zeroExpression); 
      conde.setType(new Type("int", null));  
      return conde;  
    }  
    else if ("strcspn".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      arg1.setBrackets(true); 
      Expression matchExpr = 
        new BasicExpression("\"[^\" + " + arg2 + " + \"]+\""); 
      matchExpr.setType(new Type("String", null)); 

      BinaryExpression inde = 
        new BinaryExpression("->firstMatch", arg1, matchExpr); 

      BinaryExpression test = 
        new BinaryExpression("->hasMatch", arg1, matchExpr); 
      test.setType(new Type("boolean", null)); 

      Expression expr1 = new UnaryExpression("->size", inde); 
      expr1.setType(new Type("int", null)); 

      ConditionalExpression cond1 = 
        new ConditionalExpression(
          new BinaryExpression("->hasPrefix", arg1, inde), 
          expr1, 
          zeroExpression); 
      cond1.setType(new Type("int", null));  

      ConditionalExpression conde = 
        new ConditionalExpression(test, cond1, 
                                  zeroExpression); 
      conde.setType(new Type("int", null));  
      return conde;  
    }  
    else if ("strpbrk".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      arg1.setType(new Type("String", null));
      Expression arg2 = (Expression) args.get(1);
      arg1.setBrackets(true); 
      Expression matchExpr = 
        new BasicExpression("\"[\" + " + arg2 + " + \"]+\""); 
      matchExpr.setType(new Type("String", null)); 

      BinaryExpression inde = 
        new BinaryExpression("->firstMatch", arg1, matchExpr); 
      BinaryExpression indexExpr = 
        new BinaryExpression("->indexOf", arg1, inde); 
      BasicExpression fbe = 
        BasicExpression.newFunctionBasicExpression("subrange",
          arg1, indexExpr); 
      fbe.setType(new Type("String", null));  
      
      BinaryExpression test = 
        new BinaryExpression("->hasMatch", arg1, matchExpr); 
      test.setType(new Type("boolean", null)); 

      Expression nullstring = 
         BasicExpression.newValueBasicExpression("\"\""); 
      nullstring.setType(new Type("String", null)); 

      ConditionalExpression conde = 
        new ConditionalExpression(test, fbe, nullstring);
      conde.setType(new Type("String", null));  
      return conde;  
    }  
    else if ("strerror".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      BinaryExpression res = 
        new BinaryExpression("+", 
          new BasicExpression("\"Error: \""), arg1); 
      res.setType(new Type("String", null));  
      return res; 
    } 
    else if ("rand".equals(fname) && args.size() == 0)
    { Expression mrand = 
        BasicExpression.newStaticCallBasicExpression(
          "random", "MathLib"); 
      BinaryExpression mlt = 
        new BinaryExpression("*", mrand, 
             new BasicExpression(2147483647));
      mlt.setBrackets(true);  
      UnaryExpression res = 
        new UnaryExpression("->floor", mlt); 
      res.setType(new Type("int", null)); 
      return res; 
    } 
    else if ("calloc".equals(fname) && args.size() == 2) 
    { Expression sze = (Expression) args.get(0);
      Expression typsize = (Expression) args.get(1); 
      SetExpression res = 
        SetExpression.newRefSetExpression();
      Type tt = typsize.getsizeofType();  
      res.addElement(sze); 
      res.setElementType(tt);
      res.setArray(true); 
      // System.out.println(">>> calloc expression: " + res);  
      return res; 
    } // Element type? 
    else if ("malloc".equals(fname) && args.size() == 1) 
    { Expression typsize = (Expression) args.get(0); 
      SetExpression res = 
        SetExpression.newRefSetExpression();
      res.addElement(new BasicExpression(1));  
      Type tt = typsize.getsizeofType();  
      res.setElementType(tt); 
      return res; 
    } // Element type? 
    else if ("realloc".equals(fname) && args.size() == 2) 
    { Expression ptr = (Expression) args.get(0);
      Expression sze = (Expression) args.get(1); 
      // Create the new array and copy the old one to it. 
      BasicExpression tmp = 
        BasicExpression.newVariableBasicExpression(
                                          "_tmpRealloc");
      tmp.setType(ptr.getType()); 
      tmp.setElementType(ptr.getElementType());

  /* SetExpression res = 
        // new BinaryExpression("->resizeTo", ptr, sze);
        SetExpression.newRefSetExpression();
      res.setType(ptr.getType()); 
      res.setElementType(ptr.getElementType());
      ptr.setArray(true); 
      res.setArray(true);  */ 
  
      return tmp; 
    } // Element type? 
    else if ("system".equals(fname) && args.size() == 1) 
    { Expression arg1 = (Expression) args.get(0);
      Expression par0 = new BasicExpression("null"); 
      Vector pars = new Vector(); 
      pars.add(par0); 
      pars.add(arg1); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
                 "newOclProcess", "OclProcess", pars); 
      // res.setType(new Type("int", null));  
             
      return res; 
    } // also as update form   
    else if ("getenv".equals(fname) && args.size() == 1) 
    { Expression arg1 = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
                 "getEnvironmentProperty", "OclProcess", 
                 arg1); 
      res.setType(new Type("String", null));  
             
      return res; 
    }
    else if ("bsearch".equals(fname) && args.size() == 5)
    { Expression keyval = (Expression) args.get(0);
      Expression col = (Expression) args.get(1);
      Expression n = (Expression) args.get(2);
      Expression cmp = (Expression) args.get(4); 

      // col->sequenceRange(n)->any( x | 
      //                              cmp(keyval,x) = 0 )

      String xid = Identifier.nextIdentifier("_x"); 
      BasicExpression x = 
        BasicExpression.newVariableBasicExpression(xid); 

      Expression colseq = 
        new BinaryExpression("->sequenceRange", col, n); 
      colseq.setType(new Type("Sequence", null)); 
      colseq.setElementType(col.getElementType()); 

      Expression anydom = 
        new BinaryExpression(":", x, colseq);
      cmp.setBrackets(true);  
      // Expression cmpf1 = 
      //   new BinaryExpression("->apply", cmp, keyval); 
      // cmpf1.setBrackets(true); 
      Expression cmpf = 
        Expression.simplifyApply(cmp,keyval,x); 
      //  new BinaryExpression("->apply", cmpf1, x); 
      Expression anycnd = 
         new BinaryExpression("=", cmpf, zeroExpression); 
      Expression anyexpr = 
        new BinaryExpression("|A", anydom, anycnd); 
      return anyexpr; 
    } 
    else if ("qsort".equals(fname) && args.size() == 4)
    { Expression col = (Expression) args.get(0);
      Expression n = (Expression) args.get(1);
      Expression cmp = (Expression) args.get(3); 

      // col->sequenceRange(n)->sort()->asReference()
      // OclComparator.sortWithFunction(col->sequenceRange(n),
      //                                cmp)->asReference()

      Expression colseq = 
        new BinaryExpression("->sequenceRange", col, n); 
      colseq.setType(new Type("Sequence", null)); 
      colseq.setElementType(col.getElementType()); 
      Expression cmpf1 = 
        new UnaryExpression("->sort", colseq); 
      Expression anyexpr = 
        new UnaryExpression("->asReference", cmpf1); 
      return anyexpr; 
    } 
    else if ("time".equals(fname) && args.size() == 1)
    { Expression res = 
        BasicExpression.newStaticCallBasicExpression(
          "getSystemTime", "OclDate"); 
      res.setType(new Type("long", null));
      Expression resx = 
        new BinaryExpression("/", res, 
                             new BasicExpression(1000)); 
      resx.setType(new Type("long", null));
      return resx; 
    } 
    else if ("mktime".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Expression dte = new UnaryExpression("!", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("?"))
      { dte = ((UnaryExpression) arg1).argument; } 

      dte.setBrackets(true); 

      Expression res = 
        BasicExpression.newCallBasicExpression(
                                   "getTime", dte); 
      res.setType(new Type("long", null));
      Expression resx = 
        new BinaryExpression("/", res, 
                             new BasicExpression(1000)); 
      resx.setType(new Type("long", null));
      return resx; 
    } 
    else if ("asctime".equals(fname) && args.size() == 1)
    { Expression arg1 = (Expression) args.get(0);
      Expression dte = new UnaryExpression("!", arg1); 

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("?"))
      { dte = ((UnaryExpression) arg1).argument; } 

      dte.setBrackets(true); 

      Expression res = 
        BasicExpression.newCallBasicExpression(
                                   "toString", dte); 
      res.setType(new Type("String", null));
      return res; 
    } 
    else if ("difftime".equals(fname) && args.size() == 2)
    { Expression arg1 = (Expression) args.get(0);
      Expression arg2 = (Expression) args.get(1);
      Expression res = 
        new BinaryExpression("-", arg1, arg2); 
      res.setType(new Type("double", null)); 
      res.setBrackets(true); 
      return res; 
    } 
    else if (("localtime".equals(fname) ||
              "gmtime".equals(fname)) && args.size() == 1)
    { // mktime(t)  is  OclDate.newOclDate_Time(
      Expression arg1 = (Expression) args.get(0);
      
      Expression par = new UnaryExpression("!", arg1);

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("?"))
      { par = ((UnaryExpression) arg1).argument; } 

      Expression par1 = 
        new BinaryExpression("*",par,
                             new BasicExpression(1000));
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                       "newOclDate_Time", "OclDate", par1); 
      res.setType(new Type("OclDate", null));
      Expression resx = 
        new UnaryExpression("?", res); 
      resx.setType(new Type("Ref", null)); 
      resx.setElementType(new Type("OclDate", null));
      return resx; 
    } 
    else if ("ctime".equals(fname) && args.size() == 1)
    { // create an OclDate for arg1 & display it.
      Expression arg1 = (Expression) args.get(0);
      
      Expression par = new UnaryExpression("!", arg1);

      if (arg1 instanceof UnaryExpression && 
          ((UnaryExpression) arg1).operator.equals("?"))
      { par = ((UnaryExpression) arg1).argument; } 

      Expression par1 = 
        new BinaryExpression("*",par,
                             new BasicExpression(1000));
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                       "newOclDate_Time", "OclDate", par1);
      Expression resx = 
        BasicExpression.newCallBasicExpression(
                       "toString", res);  
      resx.setType(new Type("String", null));
      return resx; 
    } 
    else if ("printf".equals(fname) && args.size() > 1) 
    { Expression fmt = (Expression) args.get(0);
      Vector elems = new Vector(); 
      for (int i = 1; i < args.size(); i++) 
      { elems.add(args.get(i)); } 
      SetExpression sq = new SetExpression(elems, true); 
      Vector argf = new Vector(); 
      argf.add(fmt); 
      argf.add(sq); 
      Expression stdout = new BasicExpression("System_out"); 
      stdout.setType(new Type("OclFile", null));
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
                 "printf", stdout, 
                 argf); 
      res.setType(new Type("int", null));  
             
      return res; 
    }
    else if ("fopen".equals(fname) && args.size() == 2) 
    { // OclFile.newOclFile_Read(_1) or 
      // OclFile.newOclFile_Write(_1)

      Expression fle = (Expression) args.get(0);
      Expression mde = (Expression) args.get(1);
      
      if ("\"r\"".equals(mde + ""))
      { BasicExpression be = 
          BasicExpression.newStaticCallBasicExpression(
             "newOclFile", "OclFile", fle); 
        BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
             "newOclFile_Read", "OclFile", be); 
        res.setType(new Type("OclFile", null)); 
        return res; 
      } 
      else 
      { BasicExpression be = 
          BasicExpression.newStaticCallBasicExpression(
             "newOclFile", "OclFile", fle); 
        BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
             "newOclFile_Write", "OclFile", be); 
        res.setType(new Type("OclFile", null)); 
        return res; 
      } 
    } // freopen? 
    else if ("tmpfile".equals(fname) && args.size() == 0) 
    { // OclFile.createTemporaryFile("tmp", "txt")

      Expression fle = new BasicExpression("tmp");
      Expression ext = new BasicExpression("txt");
      Vector pars = new Vector(); 
      pars.add(fle); 
      pars.add(ext); 
      BasicExpression res = 
          BasicExpression.newStaticCallBasicExpression(
             "createTemporaryFile", "OclFile", pars); 
      res.setType(new Type("OclFile", null)); 
      return res; 
    } 
    else if (("fgetc".equals(fname) || "getc".equals(fname))
             && args.size() == 1) 
    { // _1.read()->char2byte()

      Expression fle = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "read", fle); 
      res.setType(new Type("String", null)); 
      Expression intres = 
        new UnaryExpression("->char2byte", res); 
      intres.setType(new Type("int", null)); 

      return intres; 
    } 
    else if ("fgets".equals(fname) && args.size() == 3) 
    { // fle.readLine().subrange(1,n)

      Expression n = (Expression) args.get(1);
      Expression fle = (Expression) args.get(2);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "readLine", fle); 
      res.setType(new Type("String", null)); 
      Vector pars = new Vector(); 
      pars.add(unitExpression); 
      pars.add(n); 
      Expression intres = 
        BasicExpression.newFunctionBasicExpression(
           "subrange", res, pars); 
      intres.setType(new Type("String", null)); 

      return intres; 
    } 
    else if ("getchar".equals(fname) && args.size() == 0) 
    { // System_in.read()->char2byte()
      Expression fle = 
        new BasicExpression("System_in"); 
      fle.setType(new Type("OclFile", null)); 
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "read", fle); 
      res.setType(new Type("String", null)); 
      Expression intres = 
        new UnaryExpression("->char2byte", res); 
      intres.setType(new Type("int", null)); 

      return intres; 
    } 
    else if ("gets".equals(fname) && args.size() == 1) 
    { // System_in.readLine()

      Expression fle = new BasicExpression("System_in"); 
      fle.setType(new Type("OclFile", null)); 

      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "readLine", fle); 
      res.setType(new Type("String", null)); 
      
      return res; 
    } 
    else if ("ftell".equals(fname) && args.size() == 1)
    { Expression fle = (Expression) args.get(0);
      BasicExpression res = 
          BasicExpression.newCallBasicExpression(
             "getPosition", fle); 
      res.setType(new Type("long", null)); 
      
      return res; 
    } 
    else if ("feof".equals(fname) && args.size() == 1)
    { Expression fle = (Expression) args.get(0);
      BasicExpression call = 
          BasicExpression.newCallBasicExpression(
             "getEof", fle);
      ConditionalExpression res = 
        new ConditionalExpression(call, 
                     unitExpression, zeroExpression);  
      res.setType(new Type("int", null)); 
      
      return res; 
    } 
    else if ("va_arg".equals(fname) && args.size() == 2)
    { Expression va = (Expression) args.get(0); 
      Expression vatype = (Expression) args.get(1);
      Type t = vatype.getsizeofType(); 
      Expression sq = 
        BasicExpression.newVariableBasicExpression(
                              "par_varg_sq"); 
      sq.setType(new Type("Sequence", null)); 
      Expression atvarg = 
         new BinaryExpression("->at", sq, va);  
      Expression res = 
        new BinaryExpression("->oclAsType", atvarg, 
                                new BasicExpression(t)); 
      return res; 
    } 
    else if ("modf".equals(fname) && args.size() == 2)
    { Expression x = (Expression) args.get(0); 
      Expression ip = (Expression) args.get(1); 
      x.setType(new Type("double", null)); 
      Type refdouble = new Type("Ref", null);
      refdouble.setElementType(new Type("double", null)); 
      ip.setType(refdouble); 
      Expression deref = 
        new UnaryExpression("!", ip); 
      return new BinaryExpression("-", x, deref); 
    } 
    else if ("frexp".equals(fname) && args.size() == 2) 
    { Expression x = (Expression) args.get(0); 
      Expression ip = (Expression) args.get(1); 
      x.setType(new Type("double", null)); 
      Type refint = new Type("Ref", null);
      refint.setElementType(new Type("int", null)); 
      ip.setType(refint); 
      Expression deref = 
        new UnaryExpression("!", ip); 
      deref.setBrackets(true); 
      Expression cdouble = 
        new BinaryExpression("->oclAsType", deref, 
              new BasicExpression(new Type("double", null))); 

      Expression dzero = new BasicExpression(0.0);

      Expression xdivpow = 
        new BinaryExpression("/", x, cdouble); 
      xdivpow.setType(new Type("double", null));

      BinaryExpression eqzero = 
         new BinaryExpression("=", x, dzero); 
      eqzero.setType(new Type("boolean", null)); 
      
      return new ConditionalExpression(eqzero, dzero, 
                                       xdivpow); 
    } 
    else if ("div".equals(fname) && args.size() == 2)
    { // produces div_t.newdiv_t(num div denom, 
      //                   num - denom*(num div denom))
      
      ASTTerm.introduceCStruct("div_t", ents); 

      Expression num = (Expression) args.get(0); 
      Expression denom = (Expression) args.get(1); 
      Expression quot = 
        new BinaryExpression("div", num, denom); 
      quot.setBrackets(true); 
      Expression quotcast = 
        new BinaryExpression("->oclAsType", quot, 
                            new BasicExpression(intType));  
      quotcast.setType(new Type("int", null));

      Expression rem1 = 
        new BinaryExpression("*", denom, quotcast); 
      rem1.setBrackets(true); 
      Expression rem = 
        new BinaryExpression("-", num, rem1);
      Vector pars = new Vector(); 
      pars.add(quotcast); 
      pars.add(rem);  
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                       "newdiv_t", "div_t", pars); 
      return res; 
    }    
    else if ("ldiv".equals(fname) && args.size() == 2)
    { // produces ldiv_t.newldiv_t(num div denom, 
      //                   num - denom*(num div denom))
      
      ASTTerm.introduceCStruct("ldiv_t", ents); 

      Expression num = (Expression) args.get(0); 
      Expression denom = (Expression) args.get(1); 
      Expression quot = 
        new BinaryExpression("div", num, denom);
      quot.setBrackets(true); 
      Expression quotcast = 
        new BinaryExpression("->oclAsType", quot, 
                            new BasicExpression(longType));  
      quotcast.setType(new Type("long", null));
      Expression rem1 = 
        new BinaryExpression("*", denom, quotcast); 
      rem1.setBrackets(true); 
      Expression rem = 
        new BinaryExpression("-", num, rem1);
      Vector pars = new Vector(); 
      pars.add(quotcast); 
      pars.add(rem);  
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                       "newldiv_t", "ldiv_t", pars); 
      return res; 
    }    
    else if ("strtod".equals(fname) && args.size() == 2)
    { Expression x = (Expression) args.get(0); 
      x.setType(new Type("String", null)); 
    
      Expression patt = 
        BasicExpression.newValueBasicExpression(
                   "\"[0-9]+.[0-9]+\""); 
      patt.setType(new Type("String", null)); 

      Expression firstmatch = 
        new BinaryExpression("->firstMatch", x, patt);
      firstmatch.setType(new Type("String", null)); 
      UnaryExpression xres = 
        new UnaryExpression("->toReal", firstmatch); 
      xres.setType(new Type("double", null)); 
      return xres; 
    } 
    else if (("strtol".equals(fname) || 
              "strtoul".equals(fname)) && args.size() >= 2)
    { Expression x = (Expression) args.get(0); 
      x.setType(new Type("String", null)); 
    
      Expression patt = 
        BasicExpression.newValueBasicExpression(
                   "\"0x[0-9A-F]+|0[0-7]*|[1-9][0-9]*\""); 
      patt.setType(new Type("String", null)); 

      Expression firstmatch = 
        new BinaryExpression("->firstMatch", x, patt);
      firstmatch.setType(new Type("String", null)); 
      UnaryExpression xres = 
        new UnaryExpression("->toLong", firstmatch); 
      xres.setType(new Type("long", null)); 
      return xres; 
    } 
 
      
    Entity mainC = (Entity) ModelElement.lookupByName(
                                      "FromC", ents);
    if (mainC != null) 
    { BehaviouralFeature bf = mainC.getOperation(fname); 

      if (bf != null) 
      { System.out.println(">>> Function defined in main program: " + fname + " " + bf.display() + " " + bf.isVarArg()); } 

      if (bf != null && 
          bf.hasStereotype("vararg"))
      { // Convert args to a call of args + sq arg
        Vector pars = bf.getParameters(); 
        Vector newargs = new Vector(); 
        for (int i = 0; i < pars.size() - 1; i++)
        { newargs.add(args.get(i)); } 
        SetExpression sq = new SetExpression(true); 
        for (int i = pars.size()-1; i < args.size(); i++) 
        { sq.addElement((Expression) args.get(i)); } 
        newargs.add(sq);
        Expression earg = 
          new BasicExpression(mainC); 
        earg.setElementType(new Type(mainC));  
        BasicExpression be = 
          BasicExpression.newCallBasicExpression(
                                      fname,newargs);
        be.setStatic(true);  
        be.entity = mainC; 
        return be;
      }
      else if (bf != null) 
      { Expression earg = 
          new BasicExpression(mainC); 
        earg.setElementType(new Type(mainC));  
        BasicExpression bef = 
          BasicExpression.newStaticCallBasicExpression(fname,
                                                 earg,
                                                 args);
        bef.entity = mainC;  
        return bef; 
      } 
    } 
 
    Type ftype = (Type) vartypes.get(fname); 
    if (ftype != null) 
    { // A local variable, must be of function type
      Expression call = 
        UnaryExpression.argumentsToLambdaCall(fname, args); 
      return call; 
    } 
    else 
    { Expression call = 
        UnaryExpression.argumentsToLambdaCall(arre, args); 
      return call; 
    } 

  /*
    if (arre instanceof BasicExpression)
    { BasicExpression be = (BasicExpression) arre; 
      be.setParameters(args); 
      be.setIsEvent();
      return be; 
    } */   
    // else a lambda call. 
    // Also case of *fname

    // return arre; 
  } 


  /* JavaScript abstraction: */ 

  public Vector jsprogramToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> Processing program tag " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    Vector res = new Vector(); 

    if ("sourceElements".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTCompositeTerm rr = (ASTCompositeTerm) terms.get(i); 
        Vector obj = rr.jsprogramToKM3(
           vartypes, varelemtypes, types, entities);
        res.addAll(obj);  
      } 
      return res; 
    } 

    if ("sourceElement".equals(tag) && terms.size() == 1)
    { ASTCompositeTerm t = (ASTCompositeTerm) terms.get(0); 
      Vector stats =  t.jsprogramToKM3(
                                vartypes,varelemtypes,types,
                                entities);
      return stats;
    } 

    if ("statement".equals(tag) && terms.size() == 1)
    { ASTCompositeTerm t = (ASTCompositeTerm) terms.get(0); 
      return t.jsprogramToKM3(vartypes,varelemtypes,types,
                                entities); 
    } 

    if ("functionDeclaration".equals(tag))
    { Vector bfs = jsfunctionDeclarationToKM3(
                                vartypes,varelemtypes,types,
                                entities);
 
      System.out.println(">>> Global function definition: " + bfs); 

      Entity ent = (Entity) 
        ModelElement.lookupByName("FromJavaScript", entities); 
      if (ent == null) 
      { ent = new Entity("FromJavaScript"); 
        // ent.addStereotype("unsafe"); 

        entities.add(ent); 
      }  

      for (int x = 0; x < bfs.size(); x++) 
      { ModelElement elem = (ModelElement) bfs.get(x); 

        if (elem instanceof BehaviouralFeature)
        { BehaviouralFeature bf = 
            (BehaviouralFeature) elem; 
          ent.addOperation(bf); 
          bf.setOwner(ent); 
        } 
      }

      return new Vector(); 
    } 

    if ("classDeclaration".equals(tag))
    { Vector bfs = jsclassDeclarationToKM3(
                                vartypes,varelemtypes,types,
                                entities);
 
      System.out.println(">>> Class definition: " + bfs); 
      return bfs; 
    } 

    if ("variableStatement".equals(tag) || 
        "expressionStatement".equals(tag) || 
        "importStatement".equals(tag) || 
        "exportStatement".equals(tag) ||
        "emptyStatement_".equals(tag) ||
        "ifStatement".equals(tag) ||
        "iterationStatement".equals(tag) ||
        "continueStatement".equals(tag) ||
        "breakStatement".equals(tag) ||
        "returnStatement".equals(tag) ||
        "yieldStatement".equals(tag) ||
        "withStatement".equals(tag) ||
        "labelledStatement".equals(tag) ||
        "switchStatement".equals(tag) ||
        "throwStatement".equals(tag) ||
        "tryStatement".equals(tag) ||
        "debuggerStatement".equals(tag))
    { return jsstatementToKM3(vartypes,varelemtypes,types,
                                entities); 
    } 

    if ("program".equals(tag))
    { Entity ent = (Entity) 
        ModelElement.lookupByName("FromJavaScript", entities); 
      if (ent == null) 
      { ent = new Entity("FromJavaScript"); 
        // ent.addStereotype("unsafe"); 

        entities.add(ent); 
      }  

      ASTTerm.currentClass = ent; 

      Vector pelems = new Vector(); 

      if (terms.size() == 3 && 
          (terms.get(1) instanceof ASTCompositeTerm))
      { ASTCompositeTerm contents = 
          (ASTCompositeTerm) terms.get(1); 
        pelems = contents.jsprogramToKM3(
                              vartypes, varelemtypes, 
                              types, entities); 
      } 
      else if (terms.size() == 2 && 
          (terms.get(0) instanceof ASTCompositeTerm))
      { ASTCompositeTerm contents = 
          (ASTCompositeTerm) terms.get(0); 
        pelems = contents.jsprogramToKM3(
                  vartypes, varelemtypes, types, entities); 
      } 

      Vector initialisationCode = new Vector(); 

      for (int i = 0; i < pelems.size(); i++) 
      { Object elem = pelems.get(i); 

        System.out.println(">>> Program element: " + elem); 

        if (elem instanceof BehaviouralFeature)
        { BehaviouralFeature bf = 
            (BehaviouralFeature) elem; 
          ent.addOperation(bf); 
          bf.setOwner(ent); 
        } 
        else if (elem instanceof Attribute)
        { Attribute att = 
            (Attribute) elem; 
          ent.addAttribute(att); 
          att.setOwner(ent); 
        } 
        else if (elem instanceof CreationStatement)
        { CreationStatement cs = 
            (CreationStatement) elem; 
          Attribute att = 
            new Attribute(cs.getVar(),
                          cs.getType(),ModelElement.INTERNAL);
          att.setElementType(cs.getElementType()); 
          att.setInitialisation(cs.getInitialisation());  
          ent.addAttribute(att); 
          att.setOwner(ent);

          if (cs.getInitialisation() != null)
          { initialisationCode.add(
              new AssignStatement(
                cs.getVar(),cs.getInitialisation())); 
          } 
        } 
        else if (elem instanceof Statement)
        { initialisationCode.add(elem); }
        else if (elem instanceof Entity)
        { res.add(elem); }  
      } 
   
      BehaviouralFeature cons = 
        BehaviouralFeature.newStaticConstructor(ent); 
      ent.addOperation(cons); 
      cons.setOwner(ent); 

      System.out.println(">> Initialisation code = " + 
                         initialisationCode); 

      BehaviouralFeature bfInit = 
        new BehaviouralFeature("initialise"); 
      bfInit.setParameters(new Vector()); 
      bfInit.setActivity(initialisationCode); 
      bfInit.setPrecondition(new BasicExpression(true)); 
      bfInit.setPostcondition(new BasicExpression(true)); 

      ent.addOperation(bfInit); 
      bfInit.setOwner(ent); 
      
      res.add(ent); 
      return res; 
    } 

    return res; 
  } 


  public Vector jsstatementToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsstatementToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    int sze = terms.size(); 

    if ("statement".equals(tag) && terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.jsstatementToKM3(vartypes,varelemtypes,types,
                                entities); 
    } 

    if ("sourceElement".equals(tag) && terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.jsstatementToKM3(vartypes,varelemtypes,types,
                                entities); 
    } 

    if ("functionDeclaration".equals(tag))
    { Vector bfs = jsfunctionDeclarationToKM3(
                                vartypes,varelemtypes,types,
                                entities);
 
      // nested function definition. Replace by 
      // var bf.getName() : bf.getFunctionType() ; 
      // bf.getName() := lambda ... 

      System.out.println(">>> Nested function definition: " + bfs); 

      if (bfs.size() == 0) 
      { return bfs; } 

      BehaviouralFeature bf = (BehaviouralFeature) bfs.get(0); 

      Entity fjs = 
        (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);

      if (ASTTerm.currentClass == null) 
      { ASTTerm.currentClass = fjs; } 

      Entity cclass = ASTTerm.currentClass; 
      BehaviouralFeature oper = null; 


      BasicExpression selfexpr = new BasicExpression("self"); 
      if (cclass != null) 
      { oper = cclass.getIdenticalOperation(bf.getActivity());
        if (oper == null)
        { oper = bf; 
          cclass.addOperation(bf); 
          bf.setOwner(cclass);
        }  
        selfexpr.setType(new Type(cclass)); 
      } 

      Vector fpars = oper.getParameters(); 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    oper,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, oper); 

      String localbfname = oper.getName(); 
      BasicExpression bfvar = 
        BasicExpression.newVariableBasicExpression(
                                          localbfname); 

      CreationStatement cre = 
         new CreationStatement(bfvar,oper.getFunctionType()); 
      AssignStatement asgn = 
         new AssignStatement(bfvar,res); 
      Vector cmds = new Vector(); 
      cmds.add(cre); 
      cmds.add(asgn); 
      return cmds; 
    } 

    if ("arrowFunctionBody".equals(tag) && terms.size() == 1)
    { ASTCompositeTerm fb = (ASTCompositeTerm) terms.get(0); 
      return fb.jsfunctionDeclarationToKM3(
                                vartypes,varelemtypes,types,
                                entities); 
    } 

    if ("expressionStatement".equals(tag) && terms.size() == 2)
    { ASTTerm t = (ASTTerm) terms.get(0);
      Vector pse =  
         t.jspreSideEffect(vartypes,varelemtypes,types,
                                entities); 
      Vector upd = t.jsupdateForm(vartypes,varelemtypes,types,
                                entities);
      Vector resx = new Vector(); 
      resx.addAll(pse); 
      resx.addAll(upd); 
      return resx;  
    } // t is an expression sequence

    if ("variableStatement".equals(tag) && terms.size() == 2)
    { ASTCompositeTerm vars = (ASTCompositeTerm) terms.get(0); 
      Vector vdecs = vars.jsvariableDeclarationToKM3(
                                vartypes,varelemtypes,types,
                                entities);
      // return new SequenceStatement(vdecs);
      return vdecs;  
    } 

    if ("yieldStatement".equals(tag) && terms.size() >= 2)
    { ASTCompositeTerm returnval = 
         (ASTCompositeTerm) terms.get(1); 
      Vector retval = returnval.jsexpressionListToKM3(
                                vartypes,varelemtypes,types,
                                entities);

      System.out.println("+++ Yield statement " + this); 

      Expression ee = new BasicExpression("null"); 
      ee.setType(new Type("OclAny", null)); 

      if (retval.size() > 0) 
      { ee = (Expression) retval.get(0); } 

      // if (yc < _position_) 
      // { yc := yc + 1; allsideeffects } 
      // else { presideeffects; return retval; } 

      BasicExpression yc =
        BasicExpression.newVariableBasicExpression(
                                         "_yieldCount_"); 
      yc.setType(new Type("int", null)); 
      BasicExpression pos =
        BasicExpression.newVariableBasicExpression(
                                         "_position_"); 
      pos.setType(new Type("int", null)); 


      AssignStatement incr = 
        new AssignStatement(yc,
              new BinaryExpression("+",yc,unitExpression)); 

      BinaryExpression leq = new BinaryExpression("<", 
                                                  yc,pos);
      ReturnStatement retstat = 
        new ReturnStatement(ee);
      Vector prese =  
         returnval.jspreSideEffect(
                            vartypes,varelemtypes,types,
                            entities); 
      Vector postse =  
         returnval.jspostSideEffect(
                               vartypes,varelemtypes,types,
                               entities); 

      Vector resx = new Vector(); 
      resx.addAll(prese); 
      Vector incrs = new Vector(); 
      incrs.add(incr); 
      incrs.addAll(prese); 

      if (postse != null && postse.size() > 0) 
      { // return e; postse 
        // is:   var _result_ := e; postse; return _result_
        String _resid = 
          Identifier.nextIdentifier("_result_"); 
        Attribute _result_ = 
          new Attribute(_resid, 
                        ee.getType(), 
                        ModelElement.INTERNAL); 
        BasicExpression _resbe = 
          new BasicExpression(_result_); 
        CreationStatement cs = 
          new CreationStatement(_result_); 
        AssignStatement asgns = 
          new AssignStatement(_resbe,ee); 
        ReturnStatement retf = 
          new ReturnStatement(_resbe);
        resx.add(cs); 
        resx.add(asgns); 
        resx.addAll(postse);
        resx.add(retf);  
        incrs.addAll(postse);  
      } 
      else 
      { resx.add(retstat); }  
  
      ConditionalStatement conds = 
        new ConditionalStatement(leq, incrs, resx);
      Vector ystats = new Vector(); 
      ystats.add(conds);   
      return ystats; 
    } 

    if ("withStatement".equals(tag) && terms.size() == 5)
    { // with ( vars ) stat
      ASTCompositeTerm wvars = (ASTCompositeTerm) terms.get(2); 
      java.util.Map emptyMap = new java.util.HashMap(); 
      Vector wvdecs = wvars.jsexpressionListToKM3(
                                emptyMap,emptyMap,types,
                                entities);

      Vector wvs = new Vector(); 
      java.util.Map withScopeClasses = new java.util.HashMap();
 
      System.out.println("*** With variables: " + wvdecs); 
      for (int i = 0; i < wvdecs.size(); i++) 
      { Expression wv = (Expression) wvdecs.get(i); 
        Type wvt = (Type) vartypes.get(wv + "");
        System.out.println("*** type: " + wvt);
        if (wvt != null && wvt.entity != null) 
        { wvs.add(wv + ""); 
          withScopeClasses.put(wv + "", wvt.entity);
        }  
      } 
      System.out.println("*** With scope classes: " + withScopeClasses); 

      ASTTerm codebody = (ASTTerm) terms.get(4); 
      Vector cstats = codebody.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities); 

      
      /* replace each naked feature feat in cstats by wv.feat 
         if feat /: dom(vartypes), and feat is a 
         feature of wv's class */ 

      Vector rstats = new Vector(); 
      rstats.addAll(cstats); 
      Vector excludes = new Vector(); 
      Vector existingvariables = new Vector(); 
      existingvariables.addAll(vartypes.keySet()); 
      for (int x = 0; x < existingvariables.size(); x++) 
      { excludes.add(existingvariables.get(x) + ""); } 
 
      System.out.println("*** existing variables: " + excludes); 

      for (int j = 0; j < wvs.size(); j++) 
      { String wv = (String) wvs.get(j); 
        Entity wvent = (Entity) withScopeClasses.get(wv);
        Type wvtype = new Type(wvent);  
        BasicExpression ref = 
          BasicExpression.newVariableBasicExpression(
                                              wv, 
                                              wvtype);

        Vector atts = wvent.getInstanceAttributes(); 

        for (int i = 0; i < atts.size(); i++)
        { Attribute att = (Attribute) atts.get(i);
          String var = att.getName();  
          rstats = 
            Statement.addContainerReferences(rstats,
                                        ref,var,excludes); 
        } 

        Vector opers = wvent.getInstanceOperations(); 

        for (int i = 0; i < opers.size(); i++)
        { BehaviouralFeature bf = 
              (BehaviouralFeature) opers.get(i);
          String var = bf.getName();  
          rstats = 
            Statement.addContainerReferences(rstats,
                                        ref,var,excludes); 
        } 
      } 
      return rstats;  
    } 

    if ("returnStatement".equals(tag) && terms.size() == 3 &&
        "return".equals(terms.get(0) + ""))
    { ASTTerm expr = (ASTTerm) terms.get(1); 
      Expression ee =
        expr.jsexpressionToKM3(vartypes,varelemtypes,types,
                               entities);
      Vector pse =  
         expr.jspreSideEffect(vartypes,varelemtypes,types,
                              entities); 

      Vector postse =  
         expr.jspostSideEffect(vartypes,varelemtypes,types,
                               entities); 

      Statement sx = new ReturnStatement(ee); 
      Vector res = new Vector(); 
      res.addAll(pse); 
      if (postse != null && postse.size() > 0) 
      { // return e; postse 
        // is:   var _result_ := e; postse; return _result_
        String _resid = 
          Identifier.nextIdentifier("_result_"); 
        Attribute _result_ = 
          new Attribute(_resid, ee.getType(), ModelElement.INTERNAL); 
        BasicExpression _resbe = 
          new BasicExpression(_result_);
        CreationStatement cs = 
          new CreationStatement(_result_); 
         
        AssignStatement asgns = 
          new AssignStatement(_resbe,ee); 
        ReturnStatement retf = 
          new ReturnStatement(_resbe);
        res.add(cs); 
        res.add(asgns); 
        res.addAll(postse);
        res.add(retf);   
      } 
      else 
      { res.add(sx); }  
      return res;  
    } // expr is an expression sequence

    if ("returnStatement".equals(tag) && terms.size() == 2 &&
        "return".equals(terms.get(0) + ""))
    { Statement sx = new ReturnStatement(); 
      Vector res = new Vector(); 
      res.add(sx); 
      return res; 
    } // expr is an expression sequence

    if ("continueStatement".equals(tag) && 
        terms.size() > 2 &&
        "continue".equals(terms.get(0) + ""))
    { Vector res = new Vector(); 
      String lbl = ((ASTTerm) terms.get(1)).literalForm();
      ModelElement mm = ModelElement.lookupByName(lbl,
                               ASTTerm.functionsInScope); 

      if (mm instanceof BehaviouralFeature) 
      { BehaviouralFeature bf = (BehaviouralFeature) mm; 
        BasicExpression becall = 
            new BasicExpression(bf);
        if (bf.hasReturnValue())
        { res.add(new ReturnStatement(becall)); } 
        else  
        { res.add(new InvocationStatement(becall)); } 
      } 
      else 
      { BasicExpression becall = 
          BasicExpression.newCallBasicExpression(lbl); 
        
        res.add(new InvocationStatement(becall)); 
      } 

      return res; 
    } 

    if ("continueStatement".equals(tag) && 
        terms.size() >= 2 &&
        "continue".equals(terms.get(0) + ""))
    { Statement sx = new ContinueStatement(); 
      Vector res = new Vector(); 
      res.add(sx); 
      return res; 
    } 

    if ("breakStatement".equals(tag) && 
        terms.size() > 2 &&
        "break".equals(terms.get(0) + ""))
    { Vector res = new Vector(); 
      String lbl = ((ASTTerm) terms.get(1)).literalForm();
      ModelElement mm = ModelElement.lookupByName(lbl,
                               ASTTerm.functionsInScope); 

      if (mm instanceof BehaviouralFeature) 
      { BehaviouralFeature bf = (BehaviouralFeature) mm; 
        BasicExpression becall = 
            new BasicExpression(bf);
        if (bf.hasReturnValue())
        { res.add(new ReturnStatement(becall)); } 
        else  
        { res.add(new InvocationStatement(becall)); } 
      } 
      else 
      { BasicExpression becall = 
          BasicExpression.newCallBasicExpression(lbl); 
        
        res.add(new InvocationStatement(becall)); 
      } 

      return res; 
    } 

    if ("breakStatement".equals(tag) && 
        terms.size() >= 2 &&
        "break".equals(terms.get(0) + ""))
    { Statement sx = new BreakStatement(); 
      Vector res = new Vector(); 
      res.add(sx); 
      return res; 
    } 

    if ("labelledStatement".equals(tag) && 
        terms.size() >= 2 &&
        ":".equals(terms.get(1) + ""))
    { ASTTerm content = (ASTTerm) terms.get(2); 
      return content.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
    } 

    if ("throwStatement".equals(tag) && 
        terms.size() >= 2 &&
        "throw".equals(terms.get(0) + ""))
    { ASTTerm content = (ASTTerm) terms.get(1); 
      Expression expr = content.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Statement res = new ErrorStatement(expr); 
      Vector vv = new Vector(); 
      vv.add(res); 
      return vv; 
    } 

    if ("block".equals(tag) && 
        terms.size() >= 2 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(sze - 1) + ""))
    { if (sze == 2) 
      { // Statement sx = new SequenceStatement(); 
        Vector res = new Vector(); 
        // res.add(sx); 
        return res;
      } 

      if (sze == 3) 
      { ASTTerm slist = 
          (ASTTerm) terms.get(1); 

        return slist.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      }
    }

    if ("statementList".equals(tag) || 
        "sourceElements".equals(tag))
    { 
      Vector stats = new Vector(); 
      for (int i = 0; i < sze; i++)
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ss = tt.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
        stats.addAll(ss);  
      } 
      Statement sx = new SequenceStatement(stats); 
      Vector res = new Vector(); 
      res.add(sx); 
      return res;   
    } 

    if ("functionBody".equals(tag) && 
        terms.size() >= 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + ""))
    { ASTTerm code = (ASTTerm) terms.get(1); 
      return code.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
    }  

    if ("ifStatement".equals(tag) && terms.size() == 7 && 
        "if".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "") && 
        "else".equals(terms.get(5) + ""))
    { ASTTerm cond = (ASTTerm) terms.get(2); 
      Vector pse =  
         cond.jspreSideEffect(vartypes,varelemtypes,types,
                                entities); 
      Expression test = cond.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm ifPart = (ASTTerm) terms.get(4); 
      Vector ifStats = ifPart.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm elsePart = (ASTTerm) terms.get(6); 
      Vector elseStats = elsePart.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);

      if (test.isBoolean()) { } 
      else 
      { test = new BinaryExpression(
                 "->oclAsType", test, booleanTypeExpression); 
      } 
      test.setType(booleanType); 

      Statement cstat = 
        new ConditionalStatement(test,ifStats,elseStats); 
      Vector res = new Vector(); 
      res.addAll(pse); 
      res.add(cstat); 
      return res; 
    } 

    if ("ifStatement".equals(tag) && terms.size() == 5 && 
        "if".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + ""))
    { ASTTerm cond = (ASTTerm) terms.get(2); 
      Vector pse =  
         cond.jspreSideEffect(vartypes,varelemtypes,types,
                                entities); 
      Expression test = cond.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm ifPart = (ASTTerm) terms.get(4); 
      Vector ifStats = ifPart.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector elseStats = new Vector();
      // elseStats.add(skipStatement); 

      if (test.isBoolean()) { } 
      else 
      { test.setBrackets(true); 
        test = new BinaryExpression(
                 "->oclAsType", test, booleanTypeExpression); 
      } 
      test.setType(booleanType); 

      Statement cstat = 
        new ConditionalStatement(test,ifStats,elseStats); 
      Vector res = new Vector(); 
      res.addAll(pse); 
      res.add(cstat); 
      return res; 
    } 

    if ("iterationStatement".equals(tag) && 
        terms.size() == 7 && 
        "do".equals(terms.get(0) + "") && 
        "while".equals(terms.get(2) + "") && 
        "(".equals(terms.get(3) + "") && 
        ")".equals(terms.get(5) + ""))
    { ASTTerm cond = (ASTTerm) terms.get(4); 
      Expression test = cond.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      if (test.isBoolean()) { } 
      else 
      { test.setBrackets(true); 
        test = new BinaryExpression(
                 "->oclAsType", test, booleanTypeExpression); 
      } 
      test.setType(new Type("boolean", null)); 

      ASTTerm body = (ASTTerm) terms.get(1); 
      Vector doStats = body.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector testupdate = cond.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);

      Vector whileBody = new Vector(); 
      // whileBody.addAll(testupdate); 
      whileBody.addAll(doStats); 

      
      SequenceStatement doSkip = 
        new SequenceStatement();
      if (testupdate == null || testupdate.size() == 0)
      { doSkip.addStatement(
                  new InvocationStatement("skip")); 
      } 
      else 
      { doSkip.addStatements(testupdate); } 
 
      SequenceStatement doBreak = 
        new SequenceStatement(testupdate); 
      doBreak.addStatement(new BreakStatement()); 

      ConditionalStatement cs = 
        new ConditionalStatement(test, doSkip, doBreak); 
      whileBody.add(cs); 

      BasicExpression betrue = new BasicExpression(true); 
      
      Vector res = new Vector();
      Statement whileStat = 
        new WhileStatement(betrue,whileBody); 
      res.add(whileStat);  
      return res; 
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 5 && 
        "while".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + ""))
    { ASTTerm cond = (ASTTerm) terms.get(2); 
      Expression test = cond.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      if (test.isBoolean()) { } 
      else 
      { test.setBrackets(true); 
        test = new BinaryExpression(
                 "->oclAsType", test, booleanTypeExpression); 
      } 
      test.setType(new Type("boolean", null)); 

      ASTTerm body = (ASTTerm) terms.get(4); 
      Vector whileStats = body.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector testupdate = cond.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      Vector whileBody = new Vector(); 
      whileBody.addAll(testupdate); 
      whileBody.addAll(whileStats); 
      Vector res = new Vector();
      Statement whileStat = 
        new WhileStatement(test,whileBody); 
      res.add(whileStat);  
      return res; 
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 7 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        "of".equals(((ASTTerm) terms.get(3)).literalForm()) && 
        ")".equals(terms.get(5) + ""))
    { ASTTerm loopVar = (ASTTerm) terms.get(2); 
      Expression lvar = loopVar.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopRange = (ASTTerm) terms.get(4); 
      Expression lrng = loopRange.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm body = (ASTTerm) terms.get(6); 
      Vector forStats = body.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector res = new Vector();
      Statement forStat = 
        new WhileStatement(lvar,lrng,forStats); 
      res.add(forStat);  
      return res; 
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 7 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        "in".equals(((ASTTerm) terms.get(3)).literalForm()) && 
        ")".equals(terms.get(5) + ""))
    { ASTTerm loopVar = (ASTTerm) terms.get(2); 
      Expression lvar = loopVar.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopRange = (ASTTerm) terms.get(4); 
      Expression lrng = loopRange.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      if (lrng.isMap())
      { lrng = new UnaryExpression("->keys", lrng);
        lrng.setType(new Type("Set", null)); 
        lrng.setElementType(new Type("String", null)); 
      } 
      else if (lrng.isSequence())
      { // Integer.subrange(0,lrng->size()-1)
        UnaryExpression rngsze = 
            new UnaryExpression("->size", lrng);
        rngsze.setType(new Type("int", null)); 
        // BinaryExpression szeminus = 
        //     new BinaryExpression("-", rngsze, oneExpression);  
        // szeminus.setType(new Type("int", null)); 
        Vector pars = new Vector(); 
        pars.add(oneExpression); 
        pars.add(rngsze); 
        lrng = 
          BasicExpression.newFunctionBasicExpression(
            "subrange", "Integer", pars); 
        lrng.setType(new Type("Sequence", null)); 
        lrng.setElementType(new Type("int", null)); 
      } 
      else // object
      { // lrng->oclType().getFields()
        UnaryExpression rngtype = 
          new UnaryExpression("->oclType", lrng); 
        lrng = BasicExpression.newCallBasicExpression(
                                       "getFields",rngtype);

        lrng.setType(new Type("Sequence", null)); 
        lrng.setElementType(new Type("OclAttribute", null));   
      } // or OclType.allAttributes(lrng)

      ASTTerm body = (ASTTerm) terms.get(6); 
      Vector forStats = body.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector res = new Vector();
      Statement forStat = 
        new WhileStatement(lvar,lrng,forStats); 
      res.add(forStat);  
      return res; 
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 9 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(3) + "") && 
        ";".equals(terms.get(5) + "") && 
        ")".equals(terms.get(7) + ""))
    { // for (init; test; incr) code

      ASTTerm loopInit = (ASTTerm) terms.get(2); 
      Vector linit = loopInit.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopTest = (ASTTerm) terms.get(4); 
      Expression ltest = loopTest.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopIncr = (ASTTerm) terms.get(6); 
      Vector lincr = loopIncr.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopBody = (ASTTerm) terms.get(8); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // linit ; while ltest do (lbody; lincr)

      if (ltest.isBoolean()) { } 
      else 
      { ltest.setBrackets(true); 
        ltest = new BinaryExpression(
                 "->oclAsType", ltest, booleanTypeExpression); 
      } 
      ltest.setType(booleanType); 

      Vector xbody = new Vector(); 
      xbody.addAll(lbody); 
      xbody.addAll(lincr); 

      Vector res = new Vector(); 
      res.addAll(linit); 
      WhileStatement ws = 
        new WhileStatement(ltest,xbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 8 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(3) + "") && 
        ";".equals(terms.get(5) + "") && 
        ")".equals(terms.get(6) + ""))
    { // for (init; test; ) code

      ASTTerm loopInit = (ASTTerm) terms.get(2); 
      Vector linit = loopInit.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopTest = (ASTTerm) terms.get(4); 
      Expression ltest = loopTest.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);

      if (ltest.isBoolean()) { } 
      else 
      { ltest.setBrackets(true); 
        ltest = new BinaryExpression(
                 "->oclAsType", ltest, booleanTypeExpression); 
      } 
      ltest.setType(booleanType); 

      ASTTerm loopBody = (ASTTerm) terms.get(7); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // linit ; while ltest do (lbody)

      Vector res = new Vector(); 
      res.addAll(linit); 
      WhileStatement ws = 
        new WhileStatement(ltest,lbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 8 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(3) + "") && 
        ";".equals(terms.get(4) + "") && 
        ")".equals(terms.get(6) + ""))
    { // for (init; ; incr) code

      ASTTerm loopInit = (ASTTerm) terms.get(2); 
      Vector linit = loopInit.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      
      Expression ltest = new BasicExpression(true);
      ASTTerm loopIncr = (ASTTerm) terms.get(5); 
      Vector lincr = loopIncr.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopBody = (ASTTerm) terms.get(7); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // linit ; while ltest do (lbody; lincr)

      Vector xbody = new Vector(); 
      xbody.addAll(lbody); 
      xbody.addAll(lincr); 

      Vector res = new Vector(); 
      res.addAll(linit); 
      WhileStatement ws = 
        new WhileStatement(ltest,xbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 7 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(3) + "") && 
        ";".equals(terms.get(4) + "") && 
        ")".equals(terms.get(5) + ""))
    { // for (init ; ; ) code

      ASTTerm loopInit = (ASTTerm) terms.get(2); 
      Vector linit = loopInit.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      Expression ltest = new BasicExpression(true); 
      ASTTerm loopBody = (ASTTerm) terms.get(6); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // linit ; while ltest do (lbody)

      Vector res = new Vector(); 
      res.addAll(linit); 
      WhileStatement ws = 
        new WhileStatement(ltest,lbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 8 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(2) + "") && 
        ";".equals(terms.get(4) + "") && 
        ")".equals(terms.get(6) + ""))
    { // for ( ; test; incr) code

      ASTTerm loopTest = (ASTTerm) terms.get(3); 
      Expression ltest = loopTest.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopIncr = (ASTTerm) terms.get(5); 
      Vector lincr = loopIncr.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopBody = (ASTTerm) terms.get(7); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // while ltest do (lbody; lincr)

      if (ltest.isBoolean()) { } 
      else 
      { ltest.setBrackets(true); 
        ltest = new BinaryExpression(
                 "->oclAsType", ltest, booleanTypeExpression); 
      } 
      ltest.setType(booleanType); 

      Vector xbody = new Vector(); 
      xbody.addAll(lbody); 
      xbody.addAll(lincr); 

      Vector res = new Vector(); 
      WhileStatement ws = 
        new WhileStatement(ltest,xbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 7 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(2) + "") && 
        ";".equals(terms.get(4) + "") && 
        ")".equals(terms.get(5) + ""))
    { // for ( ; test; ) code

      ASTTerm loopTest = (ASTTerm) terms.get(3); 
      Expression ltest = loopTest.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopBody = (ASTTerm) terms.get(6); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // while ltest do (lbody)

      if (ltest.isBoolean()) { } 
      else 
      { ltest.setBrackets(true); 
        ltest = new BinaryExpression(
                 "->oclAsType", ltest, booleanTypeExpression); 
      } 
      ltest.setType(booleanType); 

      Vector res = new Vector(); 
      WhileStatement ws = 
        new WhileStatement(ltest,lbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 7 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(2) + "") && 
        ";".equals(terms.get(3) + "") && 
        ")".equals(terms.get(5) + ""))
    { // for ( ; ; incr) code

      Expression ltest = new BasicExpression(true); 
      ASTTerm loopIncr = (ASTTerm) terms.get(4); 
      Vector lincr = loopIncr.jscompleteUpdateForm(
                         vartypes,varelemtypes,types,
                         entities);
      ASTTerm loopBody = (ASTTerm) terms.get(6); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // while ltest do (lbody; lincr)

      Vector xbody = new Vector(); 
      xbody.addAll(lbody); 
      xbody.addAll(lincr); 

      Vector res = new Vector(); 
      WhileStatement ws = 
        new WhileStatement(ltest,xbody); 
      res.add(ws); 
      return res;   
    } 

    if ("iterationStatement".equals(tag) && terms.size() >= 6 && 
        "for".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ";".equals(terms.get(2) + "") && 
        ";".equals(terms.get(3) + "") && 
        ")".equals(terms.get(4) + ""))
    { // for ( ; ; ) code

      Expression ltest = new BasicExpression(true); 
      ASTTerm loopBody = (ASTTerm) terms.get(5); 
      Vector lbody = loopBody.jsstatementToKM3(                         
                         vartypes,varelemtypes,types,
                         entities);

      // while ltest do (lbody)

      Vector res = new Vector(); 
      WhileStatement ws = 
        new WhileStatement(ltest,lbody); 
      res.add(ws); 
      return res;   
    } 

    if ("emptyStatement_".equals(tag) && terms.size() == 1 && 
        ";".equals(terms.get(0) + ""))
    { return new Vector(); } 

    if ("exportStatement".equals(tag))
    { return new Vector(); } 

    if ("importStatement".equals(tag))
    { return new Vector(); } 

    if ("tryStatement".equals(tag) && 
        "try".equals(terms.get(0) + "") && 
        terms.size() == 4)
    { // Try with catch & finally
      ASTTerm tryblock = (ASTTerm) terms.get(1); 
      ASTTerm catchclause = (ASTTerm) terms.get(2); 
      ASTTerm finallyclause = (ASTTerm) terms.get(3); 

      Vector tryStats = tryblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector catchStats = catchclause.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector finallyStats = finallyclause.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      TryStatement ts = new TryStatement(tryStats,catchStats,
                                         finallyStats); 

      Vector res = new Vector(); 
      res.add(ts);  
      return res; 
    } 

    if ("tryStatement".equals(tag) && 
        "try".equals(terms.get(0) + "") && 
        terms.size() == 3)
    { // Try with catch or finally
      ASTTerm tryblock = (ASTTerm) terms.get(1); 
      ASTTerm catchclause = (ASTTerm) terms.get(2); 

      Vector tryStats = tryblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      Vector catchStats = catchclause.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);

      TryStatement ts = new TryStatement(tryStats,catchStats); 

      Vector res = new Vector(); 
      res.add(ts);  
      return res; 
    } 
      
    if ("catchProduction".equals(tag) && 
        "catch".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "") && 
        terms.size() == 5)
    { // catch ( e ) { code }
      ASTTerm catchblock = (ASTTerm) terms.get(4); 
      ASTTerm catchvar = (ASTTerm) terms.get(2); 
      Expression cvar = catchvar.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);

      Vector catchStats = catchblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      CatchStatement cs = new CatchStatement(cvar,catchStats); 
      Vector res = new Vector(); 
      res.add(cs);  
      return res; 
    } 

    if ("catchProduction".equals(tag) && 
        "catch".equals(terms.get(0) + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(2) + "") && 
        terms.size() == 4)
    { // catch ( ) { code }
      ASTTerm catchblock = (ASTTerm) terms.get(3); 
      Expression cvar = 
        BasicExpression.newVariableBasicExpression("_exception",
                             new Type("OclException", null)); 
        
      Vector catchStats = catchblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      CatchStatement cs = new CatchStatement(cvar,catchStats); 
      Vector res = new Vector(); 
      res.add(cs);  
      return res; 
    } 

    if ("catchProduction".equals(tag) && 
        "catch".equals(terms.get(0) + "") && 
        terms.size() == 2)
    { // catch ( ) { code }
      ASTTerm catchblock = (ASTTerm) terms.get(1); 
      Expression cvar = 
        BasicExpression.newVariableBasicExpression("_exception",
                             new Type("OclException", null)); 
        
      Vector catchStats = catchblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      CatchStatement cs = new CatchStatement(cvar,catchStats); 
      Vector res = new Vector(); 
      res.add(cs);  
      return res; 
    } 

    if ("finallyProduction".equals(tag) && 
        "finally".equals(terms.get(0) + "") && 
        terms.size() == 2)
    { // finally { code }
      ASTTerm finallyblock = (ASTTerm) terms.get(1); 

      Vector fStats = finallyblock.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      FinalStatement fs = new FinalStatement(fStats); 
      Vector res = new Vector(); 
      res.add(fs);  
      return res; 
    } 

/* 
    if ("yieldStatement".equals(tag) && 
        "yield".equals(terms.get(0) + ""))
    { // yield 
      Vector res = new Vector(); 
      return res; 
    } 

    if ("withStatement".equals(tag) && 
        "with".equals(terms.get(0) + "") && 
        terms.size() == 5)
    { // with ( expr ) stat

      ASTTerm statterm = (ASTTerm) terms.get(4); 
 
      Vector res = statterm.jsstatementToKM3(
                         vartypes,varelemtypes,types,
                         entities);
      return res; 
    } */ 


    if ("switchStatement".equals(tag) && 
        "switch".equals(terms.get(0) + "") && 
        terms.size() == 5) 
    { // switch ( expr ) code
      ASTTerm expr = (ASTTerm) terms.get(2); 
      ASTCompositeTerm sblock = 
        (ASTCompositeTerm) terms.get(4); 

      Expression cval = expr.jsexpressionToKM3(
                         vartypes,varelemtypes,types,
                         entities);

      String cid = Identifier.nextIdentifier("_caseindex"); 
      String cvar = Identifier.nextIdentifier("_casevar"); 

      BasicExpression cidexp = 
        BasicExpression.newVariableBasicExpression(cid); 
      cidexp.setType(new Type("int", null)); 
      BasicExpression cvarexp = 
        BasicExpression.newVariableBasicExpression(cvar); 
      cvarexp.setType(cval.getType()); 
      cvarexp.setElementType(cval.getElementType()); 

      SetExpression cidrange = 
        new SetExpression(true); 
      cidrange.addElement(unitExpression); 
      cidrange.setElementType(new Type("int", null)); 

      Vector sbody = 
        sblock.jscaseStatementToKM3(cvarexp,
                         new Vector(),  
                         vartypes,varelemtypes,types,
                         entities);
      CreationStatement cs = 
        new CreationStatement(cvarexp,cval.getType()); 
      AssignStatement asgn = 
        new AssignStatement(cvarexp,cval); 
      Vector loopbody = new Vector(); 
      loopbody.add(cs); 
      loopbody.add(asgn);
      loopbody.addAll(sbody); 
      Statement floop = 
        new WhileStatement(cidexp,cidrange,loopbody); 
      Vector cmds = new Vector(); 
      cmds.add(floop); 
      return cmds; 
    } 

    if ("caseClause".equals(tag) && 
        "case".equals(terms.get(0) + "") && 
        terms.size() == 4) 
    { // case v : code
      ASTTerm code = (ASTTerm) terms.get(3); 
      Vector cstats = code.jsstatementToKM3(
                      vartypes,varelemtypes,types,entities);
      return cstats; 
    } 

    if ("caseClause".equals(tag) && 
        "case".equals(terms.get(0) + "") && 
        terms.size() == 3) 
    { return new Vector(); } 

    return new Vector(); 
  } 

  public Vector jscaseStatementToKM3(Expression casevar,
    Vector remainingCode,  
    java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jscaseStatementToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    int sze = terms.size(); 

    if ("caseBlock".equals(tag) && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(sze-1) + "") && 
        sze == 4)
    { // { cases default }
      ASTCompositeTerm cclauses = 
        (ASTCompositeTerm) terms.get(1); 
      ASTCompositeTerm dclause = 
        (ASTCompositeTerm) terms.get(2); 

      Vector res = cclauses.jscaseStatementToKM3(casevar,
                      remainingCode,
                      vartypes,varelemtypes,types,entities); 
      Vector dres = dclause.jscaseStatementToKM3(casevar,
                      remainingCode,
                      vartypes,varelemtypes,types,entities);
      res.addAll(dres); 
      return res; 
    } 

    if ("caseBlock".equals(tag) && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(sze-1) + "") && 
        sze == 3)
    { // { cases } or { default }
      ASTCompositeTerm cclauses = 
        (ASTCompositeTerm) terms.get(1); 

      Vector res = cclauses.jscaseStatementToKM3(casevar,
                      remainingCode,
                      vartypes,varelemtypes,types,entities); 
      return res; 
    } 

    if ("caseClauses".equals(tag))
    { // list of caseClause

      Vector res = new Vector(); 
      Vector tail = new Vector(); 
      
      tail.addAll(terms); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(i); 
        if (tail.size() > 0)
        { tail.remove(0); }  
        Vector cstats = tt.jscaseStatementToKM3(casevar,tail,
                      vartypes,varelemtypes,types,entities);
        // if casevar = tt.value then tt.code; remainingcode 
        // else ... other cases ...
        res.addAll(cstats); 
      } 
      return res; 
    } 

    if ("caseClause".equals(tag) && 
        "case".equals(terms.get(0) + "") && 
        terms.size() == 4) 
    { // case v : code
      // if casevar = v then cstats else skip; remainingCode

      ASTTerm val = (ASTTerm) terms.get(1); 
      ASTTerm code = (ASTTerm) terms.get(3); 
      Expression vexpr = 
        val.jsexpressionToKM3(
                      vartypes,varelemtypes,types,entities);
      Vector cstats = code.jsstatementToKM3(
                      vartypes,varelemtypes,types,entities);
        
      Expression test = 
        new BinaryExpression("=", casevar, vexpr);
      test.setType(new Type("boolean", null)); 

      Vector stats = new Vector(); 
      ConditionalStatement cs = 
        new ConditionalStatement(test,cstats,new Vector()); 
      stats.add(cs); 
      boolean endPath = false; 
      for (int i = 0; i < remainingCode.size() && !endPath; 
           i++) 
      { ASTTerm tt = (ASTTerm) remainingCode.get(i); 
        Vector remstats = tt.jsstatementToKM3(
                      vartypes,varelemtypes,types,entities);
        for (int j = 0; j < remstats.size() && !endPath; j++)
        { Statement st = (Statement) remstats.get(j);
          // System.out.println(">> Statement " + st.toAST() + " for case " + vexpr + " " + Statement.isPathEnd(st));  
          if (st instanceof BreakStatement ||
              st instanceof ReturnStatement || 
              Statement.isPathEnd(st))
          { cstats.add(st); 
            endPath = true; 
          } 
          else 
          { cstats.add(st); } 
        } 
      } 
      return stats; 
    } 

    if ("caseClause".equals(tag) && 
        "case".equals(terms.get(0) + "") && 
        terms.size() == 3) 
    { // case v :
      ASTTerm val = (ASTTerm) terms.get(1); 
      Expression vexpr = 
        val.jsexpressionToKM3(
                      vartypes,varelemtypes,types,entities);
      Vector cstats = new Vector(); 
      boolean endPath = false; 
      for (int i = 0; i < remainingCode.size() && !endPath;
           i++) 
      { ASTTerm tt = (ASTTerm) remainingCode.get(i); 
        Vector remstats = tt.jsstatementToKM3(
                      vartypes,varelemtypes,types,entities);
        for (int j = 0; j < remstats.size() && !endPath; j++)
        { Statement st = (Statement) remstats.get(j); 
          // System.out.println(">> Statement " + st.toAST() + " for case " + vexpr + " " + Statement.isPathEnd(st));  
          if (st instanceof BreakStatement ||
              st instanceof ReturnStatement || 
              Statement.isPathEnd(st))
          { cstats.add(st); 
            endPath = true; 
          } 
          else 
          { cstats.add(st); } 
        } 
      } 

      Expression test = 
        new BinaryExpression("=", casevar, vexpr);
      test.setType(new Type("boolean", null)); 

      Vector stats = new Vector(); 
      ConditionalStatement cs = 
        new ConditionalStatement(test,cstats,new Vector()); 
      stats.add(cs); 
      return stats; 
    } 

    if ("defaultClause".equals(tag) && 
        "default".equals(terms.get(0) + "") && 
        terms.size() == 3) 
    { // default : code
      ASTTerm code = (ASTTerm) terms.get(2);
      Vector cstats = code.jsstatementToKM3(
                      vartypes,varelemtypes,types,entities);
      return cstats; 
    }  

    if ("defaultClause".equals(tag) && 
        "default".equals(terms.get(0) + "") && 
        terms.size() == 2) 
    { // default : code
      Vector cstats = new Vector(); 
      return cstats; 
    }  

    return new Vector(); 
  } 

  public Vector jsvariableDeclarationToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsvariableDeclarationToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("variableDeclarationList".equals(tag) && 
        terms.size() > 1)
    { Vector res = new Vector(); 

      ASTTerm mod = (ASTTerm) terms.get(0);
      String mods = mod.literalForm(); 
      // var, let or const
      for (int i = 1; i < terms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) terms.get(i);

        if (vbl instanceof ASTSymbolTerm) {} 
        else  
        { 
          Vector stats = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          res.addAll(stats);
        } 
      }
      return res;    
    }

    if ("formalParameterList".equals(tag))
    { Vector res = new Vector(); 

      // ASTTerm mod = (ASTTerm) terms.get(0);
      // String mods = mod.literalForm(); 
      // var, let or const
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) terms.get(i);

        if (vbl instanceof ASTSymbolTerm) {} 
        else  
        { 
          Vector stats = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          res.addAll(stats);
        } 
      }
      return res;    
    }

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      ASTTerm rhs = (ASTTerm) terms.get(2);
      String var = lhs.literalForm(); 

      Expression vexp = lhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities); 

      Expression expr = rhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities); 
      
      Vector upds = rhs.jspostSideEffect(vartypes,
                              varelemtypes,types,entities); 

      System.out.println("=== Post side effect of " + rhs + " is " + upds); 

      Type tt = new Type("OclAny", null);
      if (expr != null && expr.getType() != null)
      { tt = expr.getType(); }  

      if (vexp instanceof SetExpression && 
          vexp.isSequence()) // [v1,v2] = expr
      { Vector resx = new Vector(); 
        SetExpression sexpr = (SetExpression) vexp; 
        Vector assignedTo = sexpr.getElements(); 
        for (int i = 0; i < assignedTo.size(); i++) 
        { Expression avar = (Expression) assignedTo.get(i); 
          CreationStatement csi = 
             new CreationStatement(avar + "",
                                   tt.getElementType());
          AssignStatement asgni = 
            new AssignStatement(avar,
                  new BinaryExpression("->at", expr, 
                         new BasicExpression(i+1)));  
          vartypes.put(avar + "", tt.getElementType()); 
          resx.add(csi); 
          resx.add(asgni); 
          resx.addAll(upds); 
        } 
        return resx; 
      } 

      CreationStatement cs = 
        new CreationStatement(var,tt); 
      // cs.setInitialisation(expr);
      AssignStatement asgn = new AssignStatement(vexp,expr);  
      Vector res = new Vector(); 
      res.add(cs); 
      res.add(asgn); 
      res.addAll(upds); 
      vartypes.put(var, tt); 
      if (expr != null)
      { varelemtypes.put(var, expr.getElementType()); } 
      ASTTerm.setType(lhs, tt.getName()); 
      return res; 
    } // lhs could be (arrayLiteral [ elementList ] )

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      String var = lhs.literalForm(); 

      Type tt = new Type("OclAny", null);
 
      CreationStatement cs = 
        new CreationStatement(var,tt); 
      Vector res = new Vector(); 
      vartypes.put(var, tt); 
      varelemtypes.put(var, tt); 
      res.add(cs); 
      return res; 
    } 

    if ("formalParameterArg".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      ASTTerm rhs = (ASTTerm) terms.get(2);
      String var = lhs.literalForm(); 

      Expression expr = rhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities); 
      Type tt = expr.getType(); 
      if (tt == null) 
      { tt = new Type("OclAny", null); } 
  
      Attribute att = 
        new Attribute(var,tt,ModelElement.INTERNAL); 
      att.setElementType(expr.getElementType()); 
      vartypes.put(var, tt); 
      varelemtypes.put(var, expr.getElementType()); 
      ASTTerm.setType(lhs, tt.getName());
      Vector res = new Vector(); 
      res.add(att); 
      return res; 
    } 

    if ("formalParameterArg".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      String var = lhs.literalForm(); 

      Type tt = new Type("OclAny", null);
 
      Attribute att = 
        new Attribute(var,tt,ModelElement.INTERNAL); 
      vartypes.put(var, tt); 
      varelemtypes.put(var, new Type("OclAny", null)); 
      Vector res = new Vector(); 
      res.add(att); 
      return res; 
    } 

    if ("lastFormalParameterArg".equals(tag) && 
        terms.size() == 2)
    { ASTTerm lhs = (ASTTerm) terms.get(1); 
      String var = lhs.literalForm(); 

      Type tt = new Type("Sequence", null);
      tt.setElementType(new Type("OclAny", null)); 

      Attribute att = 
        new Attribute(var,tt,ModelElement.INTERNAL); 
      vartypes.put(var, tt); 
      varelemtypes.put(var, new Type("Sequence", null)); 
      Vector res = new Vector(); 
      res.add(att); 
      return res; 
    } 

    return new Vector();  
  } 

  public Vector jsfunctionDeclarationToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsfunctionDeclarationToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("functionDeclaration".equals(tag) && 
        "function".equals(terms.get(0) + "") &&
        "*".equals(terms.get(1) + "") && 
        "(".equals(terms.get(3) + "") &&
        ")".equals(terms.get(4) + "") &&
        terms.size() >= 6)
    { // Generator function; returns 
      // an OclIterator for the function. 

      Vector res = new Vector(); 
      Vector fpars = new Vector(); 

      ASTTerm name = (ASTTerm) terms.get(2);
      String fname = name.literalForm(); 

      ASTTerm body = (ASTTerm) terms.get(5);

      java.util.Map vtps = new java.util.HashMap(); 
      vtps.putAll(vartypes); 
      java.util.Map vetps = new java.util.HashMap(); 
      vetps.putAll(varelemtypes); 

      ASTTerm.functionsInScope = new Vector(); 
      Vector labelfunctions = 
         ((ASTCompositeTerm) body).jsLabelFunctions(
                              vtps,vetps,
                              types,entities);
      System.out.println(">>> Operation " + fname + "* has label functions " + labelfunctions);
      // ASTTerm.functionsInScope.addAll(labelfunctions);   
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      BasicExpression yc =
        BasicExpression.newVariableBasicExpression(
                                         "_yieldCount_"); 
      yc.setType(new Type("int", null)); 
      AssignStatement yc0 = 
        new AssignStatement(yc,zeroExpression); 
      ReturnStatement retF = 
        new ReturnStatement(nullExpression); 

      stats.add(0,yc0); 
      stats.add(retF); 
      bf.setActivity(stats); 

      Attribute pos =
        new Attribute("_position_",  
                      new Type("int", null), 
                      ModelElement.INTERNAL); 
      bf.addParameter(pos);
      bf.addStereotype("generator");   

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType); 
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("OclAny", null)); }
 

      bf.setPost(trueExpression);  
      // deduce return type from stat 

      Type bftype = bf.getFunctionType(); 
      vartypes.put(fname,bftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      System.out.println(">> Variable types = " + vartypes); 
      System.out.println(">> Variable element types = " + varelemtypes); 

      res.add(bf); 
      return res;    
    } // But it actually returns an OclIterator. 

    if ("functionDeclaration".equals(tag) && 
        "function".equals(terms.get(0) + "") &&
        "(".equals(terms.get(2) + "") &&
        ")".equals(terms.get(4) + "") &&
        terms.size() >= 6)
    { Vector res = new Vector(); 
      Vector fpars = new Vector(); 

      ASTTerm name = (ASTTerm) terms.get(1);
      String fname = name.literalForm(); 

      ASTTerm pars = (ASTTerm) terms.get(3); 
      ASTTerm body = (ASTTerm) terms.get(5);

      Vector parterms = pars.getTerms(); 
      for (int i = 0; i < parterms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) parterms.get(i);
        
        if (vbl instanceof ASTSymbolTerm) { } 
        else  
        { 
          Vector fpar = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          fpars.addAll(fpar);
        } 
      }

      // Type functype = 
      //   BehaviouralFeature.buildFunctionType(fpars); 
      // vartypes.put(fname,functype); 

      java.util.Map vtps = new java.util.HashMap(); 
      vtps.putAll(vartypes); 
      java.util.Map vetps = new java.util.HashMap(); 
      vetps.putAll(varelemtypes); 
      ASTTerm.functionsInScope = new Vector(); 
      Vector labelfunctions = 
        ((ASTCompositeTerm) body).jsLabelFunctions(
                            vtps,vetps,types,entities);
      System.out.println(">>> Operation " + fname + 
              " has label functions " + labelfunctions);
      // ASTTerm.functionsInScope.addAll(labelfunctions);   
          
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Function " + fname + " return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("OclAny", null)); }
 
      // deduce return type from stat 

      Type bftype = bf.getFunctionType(); 
      vartypes.put(fname,bftype); 
      varelemtypes.put(fname,bf.getReturnType()); 
      bf.setPost(trueExpression); 

      System.out.println("Variable types = " + vartypes); 
      System.out.println("Variable element types = " + varelemtypes); 

      res.add(bf); 
      return res;    
    }

    if ("functionDeclaration".equals(tag) && 
        "function".equals(terms.get(0) + "") &&
        "(".equals(terms.get(2) + "") &&
        ")".equals(terms.get(3) + "") &&
        terms.size() >= 5)
    { Vector res = new Vector(); 
      Vector fpars = new Vector(); 

      ASTTerm name = (ASTTerm) terms.get(1);
      String fname = name.literalForm(); 

      ASTTerm body = (ASTTerm) terms.get(4);

      java.util.Map vtps = new java.util.HashMap(); 
      vtps.putAll(vartypes); 
      java.util.Map vetps = new java.util.HashMap(); 
      vetps.putAll(varelemtypes); 

      ASTTerm.functionsInScope = new Vector(); 
      Vector labelfunctions = 
         ((ASTCompositeTerm) body).jsLabelFunctions(
                              vtps,vetps,
                              types,entities);
      System.out.println(">>> Operation " + fname + " has label functions " + labelfunctions);
      // ASTTerm.functionsInScope.addAll(labelfunctions);   
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType); 
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("OclAny", null)); }
 

      bf.setPost(trueExpression);  
      // deduce return type from stat 

      Type bftype = bf.getFunctionType(); 
      vartypes.put(fname,bftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      System.out.println("Variable types = " + vartypes); 
      System.out.println("Variable element types = " + varelemtypes); 

      res.add(bf); 
      return res;    
    }

    if ("singleExpression".equals(tag)) // for vars => expr
    { Vector res = new Vector(); 
      Expression expr = jsexpressionToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      expr.setBrackets(true); 
      Statement retstat = 
        new ReturnStatement(expr); 
      res.add(retstat); 
      return res; 
    } 

    if ("functionBody".equals(tag) && terms.size() == 2) // for vars => expr
    { Vector res = new Vector(); 
      return res; 
    } 

    if ("functionBody".equals(tag) && terms.size() == 3) // for vars => expr
    { Vector res = new Vector(); 
      ASTTerm body = (ASTTerm) terms.get(1); 
      res = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      return res; 
    } 
      

    return null; 
  }

  public Vector jsclassDeclarationToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsclassDeclarationToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if ("classDeclaration".equals(tag) && 
        "class".equals(terms.get(0) + "") &&
        terms.size() >= 3)
    { Vector res = new Vector(); 
      Vector ccontents = new Vector(); 

      ASTTerm name = (ASTTerm) terms.get(1);
      String cname = name.literalForm(); 

      Entity e = (Entity) ModelElement.lookupByName(
                                         cname,entities);
      if (e == null && Entity.validEntityName(cname)) 
      { e = new Entity(cname); 
        entities.add(e); 
        res.add(e); 
      } 

      Entity oldclass = ASTTerm.currentClass; 
      ASTTerm.currentClass = e; 

      ASTCompositeTerm body = (ASTCompositeTerm) terms.get(2);
      String sup = body.jsgetSuperclass();  
      if (sup != null) 
      { Entity esup = (Entity) ModelElement.lookupByName(
                                         sup,entities); 
        if (esup == null && Entity.validEntityName(sup)) 
        { esup = new Entity(sup); 
          entities.add(esup); 
          res.add(esup); 
        } 

        e.setSuperclass(esup); 
        esup.addSubclass(e); 
      } 

      ccontents = body.jsclassDeclarationToKM3(vartypes, 
                             varelemtypes,types,entities); 
      e.addModelElements(ccontents); 

      Vector pars = new Vector(); 

      ModelElement consmethod = 
        ModelElement.lookupByName("constructor", ccontents); 
      if (consmethod != null && 
          consmethod instanceof BehaviouralFeature)
      { BehaviouralFeature bfcons = 
            (BehaviouralFeature) consmethod; 
        pars.addAll(bfcons.getParameters()); 
      } 

      BehaviouralFeature cons = 
        BehaviouralFeature.newStaticConstructor(e);
      cons.setParameters(pars);  
      e.addOperation(cons); 
      cons.setOwner(e); 

      Vector initialisationCode = new Vector(); 
      System.out.println(">> Initialisation code = " + 
                         initialisationCode); 

      BehaviouralFeature bfInit = 
        new BehaviouralFeature("initialise"); 
      bfInit.setParameters(new Vector()); 
      bfInit.setActivity(initialisationCode); 
      bfInit.setPrecondition(new BasicExpression(true)); 
      bfInit.setPostcondition(new BasicExpression(true)); 

      e.addOperation(bfInit); 
      bfInit.setOwner(e); 

      ASTTerm.currentClass = oldclass; 

      return res; 
    } 

    if ("classTail".equals(tag) && 
        terms.size() > 2 &&  
        "extends".equals(terms.get(0) + "") && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(terms.size()-1) + ""))
    { Vector contents = new Vector(); 

      for (int i = 3; i < terms.size()-1; i++) 
      { ASTTerm cterm = (ASTTerm) terms.get(i); 
        Vector celems = cterm.jsclassDeclarationToKM3(
                             vartypes, 
                             varelemtypes,types,entities);
        contents.addAll(celems); 
      } 
      return contents; 
    } 

    if ("classTail".equals(tag) && 
        terms.size() > 1 &&  
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(terms.size()-1) + ""))
    { Vector contents = new Vector(); 

      for (int i = 1; i < terms.size()-1; i++) 
      { ASTTerm cterm = (ASTTerm) terms.get(i); 
        Vector celems = cterm.jsclassDeclarationToKM3(
                             vartypes, 
                             varelemtypes,types,entities);
        contents.addAll(celems); 
      } 
      return contents; 
    } 

    if ("classElement".equals(tag) && terms.size() == 1 && 
        (terms.get(0) instanceof ASTCompositeTerm))
    { ASTCompositeTerm t0 = (ASTCompositeTerm) terms.get(0); 
      Vector bfs = t0.jsclassDeclarationToKM3(
                             vartypes, 
                             varelemtypes,types,entities);
      if (bfs.size() > 0 && 
          bfs.get(0) instanceof BehaviouralFeature)
      { BehaviouralFeature bf = 
                        (BehaviouralFeature) bfs.get(0); 
        if ("constructor".equals(bf.getName()))
        { // derive attributes from it
          Vector atts = jsderiveAttributes(bf,vartypes, 
                             varelemtypes,types,entities); 
          bfs.addAll(atts); 
        } 
      } // method definition
      return bfs; 
    }
 
    if ("classElement".equals(tag) && terms.size() == 2 &&
        "static".equals(((ASTTerm) 
                          terms.get(0)).literalForm()) &&  
        (terms.get(1) instanceof ASTCompositeTerm))
    { ASTCompositeTerm t0 = (ASTCompositeTerm) terms.get(1); 
      Vector bfs = t0.jsclassDeclarationToKM3(
                             vartypes, 
                             varelemtypes,types,entities);
      if (bfs.size() > 0 && 
          bfs.get(0) instanceof BehaviouralFeature)
      { BehaviouralFeature bf = 
                        (BehaviouralFeature) bfs.get(0); 
        bf.setStatic(true);
        Vector bfxs = new Vector(); 
        bfxs.add(bf);  
        return bfxs; 
      } 
      return bfs; 
    } // static method definition

    if ("classElement".equals(tag) && terms.size() > 2 &&
        "=".equals(terms.get(terms.size()-2) + ""))
    { // attribute definition # att = expr or att = expr

      Vector res = new Vector(); 
      int attindex = 0; 
      int valindex = 2; 
      if ("#".equals(terms.get(0) + ""))
      { attindex++; 
        valindex++; 
      } 
      ASTTerm att = (ASTTerm) terms.get(attindex); 
      ASTTerm val = (ASTTerm) terms.get(valindex);
      
      Expression attexpr = att.jsexpressionToKM3(                             
                             vartypes, 
                             varelemtypes,types,entities);
      if (attexpr instanceof BasicExpression) 
      { String prop = ((BasicExpression) attexpr).getData(); 
        Expression expr = val.jsexpressionToKM3(                             
                             vartypes, 
                             varelemtypes,types,entities);
        Attribute attr = new Attribute(prop,expr.getType(),
                                     ModelElement.INTERNAL); 
        attr.setElementType(expr.getElementType()); 
        attr.setInitialisation(expr); 
        res.add(attr);
      }  
      return res; 
    }

    if ("methodDefinition".equals(tag) && terms.size() > 3 &&
        "(".equals(terms.get(terms.size()-3) + "") && 
        ")".equals(terms.get(terms.size()-2) + ""))
    { // operation definition # op() def or op() def

      Vector res = new Vector(); 
      int nmeindex = 0; 
      if ("*".equals(terms.get(0) + ""))
      { nmeindex++; 
        if ("#".equals(terms.get(1) + ""))
        { nmeindex++; } 
      } 
      else if ("#".equals(terms.get(0) + ""))
      { nmeindex++; } 

      ASTTerm fname = (ASTTerm) terms.get(nmeindex); 
      ASTTerm defn = (ASTTerm) terms.get(terms.size()-1); 
      Expression fexpr = fname.jsexpressionToKM3(                             
                             vartypes, 
                             varelemtypes,types,entities);
      String f = fexpr + "";  
      Vector code = defn.jsstatementToKM3(                             
                             vartypes, 
                             varelemtypes,types,entities);
      BehaviouralFeature bf = 
        new BehaviouralFeature(f); 
      // attr.setElementType(expr.getElementType()); 
      bf.setActivity(code); 
      bf.setPost(new BasicExpression(true)); 
      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
      res.add(bf); 
      return res; 
    }

    if ("methodDefinition".equals(tag) && terms.size() > 4 &&
        "(".equals(terms.get(terms.size()-4) + "") && 
        ")".equals(terms.get(terms.size()-2) + ""))
    { // operation definition # op(p) def or op(p) def

      Vector res = new Vector(); 
      int nmeindex = 0; 
      if ("*".equals(terms.get(0) + ""))
      { nmeindex++; 
        if ("#".equals(terms.get(1) + ""))
        { nmeindex++; } 
      } 
      else if ("#".equals(terms.get(0) + ""))
      { nmeindex++; } 

      ASTTerm fname = (ASTTerm) terms.get(nmeindex);
      ASTTerm pars = (ASTTerm) terms.get(terms.size()-3);  
      ASTTerm defn = (ASTTerm) terms.get(terms.size()-1); 

      Expression fexp = fname.jsexpressionToKM3(vartypes, 
                             varelemtypes,types,entities);
      String f = fexp + ""; 

      Vector fpars = new Vector(); 

      Vector code = defn.jsstatementToKM3(                             
                             vartypes, 
                             varelemtypes,types,entities);

      Vector parterms = pars.getTerms(); 
      for (int i = 0; i < parterms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) parterms.get(i);
        
        if (vbl instanceof ASTSymbolTerm) { } 
        else  
        { 
          Vector fpar = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          fpars.addAll(fpar);
        } 
      }

      BehaviouralFeature bf = 
        new BehaviouralFeature(f,fpars,code); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      res.add(bf); 
      return res; 
    }

    return new Vector(); 
  }

  public String jsgetSuperclass()
  { if ("classTail".equals(tag) &&
        terms.size() > 2 &&  
        "extends".equals(terms.get(0) + ""))
    { ASTTerm t1 = (ASTTerm) terms.get(1); 
      return t1.literalForm(); 
    } 
    return null; 
  } 

  public Vector jsderiveAttributes(BehaviouralFeature bf, 
    java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsderiveAttributes for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 
    
    Vector res = new Vector(); 
    Statement act = bf.getActivity(); 
    // identify all the top-level this.att = val
    // assign statements.

    Vector assigns = Statement.getAssignments(act); 

    for (int i = 0; i < assigns.size(); i++) 
    { AssignStatement asgn = (AssignStatement) assigns.get(i); 
      Expression lhs = asgn.getLeft(); 
      if (lhs instanceof BasicExpression) 
      { BasicExpression be = (BasicExpression) lhs; 
        if (be.getObjectRef() != null &&
            "self".equals(be.getObjectRef() + ""))
        { // self.att = value
          Expression rhs = asgn.getRight(); 
          String attname = be.getData();
          Attribute att = 
            (Attribute) ModelElement.lookupByName(attname,res);
          if (att == null)   
          { att = 
              new Attribute(attname, rhs.getType(), 
                          ModelElement.INTERNAL); 
            att.setElementType(rhs.getElementType()); 
            att.setInitialisation(rhs); 
            if (att.getType() == null) 
            { att.setType(new Type("OclAny", null)); } 
            res.add(att); // if not already in there
          } 
        }
      } 
    } 

    return res;  
  } 

  public Vector jscompleteUpdateForm(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { Vector r1 = jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
    Vector r2 = jsupdateForm(vartypes,
                                varelemtypes,types,entities);
    Vector res = new Vector(); 
    res.addAll(r1); 
    res.addAll(r2); 
    return res; 
  } 

  public boolean jsPrototypeAccess(ASTTerm t)
  { System.out.println("+++ jsPrototypeAccess for " + t); 

    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm lhs = (ASTTerm) tt.terms.get(0); 
        ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        if (jsPrototype(lhs) && 
            rhs.hasTag("identifierName"))
        { return true; } 
      } 
    } 
    return false; 
  } 

  public boolean jsPrototype(ASTTerm t)
  { System.out.println("+++ jsPrototype for " + t); 

    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        // System.out.println("+++ " + rhs.literalForm()); 

        if (rhs.literalForm().equals("prototype"))
        { return true; } 
      } 
    } 
    return false; 
  } 

  public boolean jsClassAccess(ASTTerm t, Vector entities)
  { if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm lhs = (ASTTerm) tt.terms.get(0); 
        ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        if (jsClassName(lhs,entities) && 
            rhs.hasTag("identifierName"))
        { return true; } 
      } 
    } 
    return false; 
  } 


  public boolean jsClassName(ASTTerm t, Vector entities)
  { String pclass = t.literalForm(); 

    Entity ent = (Entity)
          ModelElement.lookupByName(pclass, entities);
    if (ent != null)
    { return true; } 

    Entity fromJS = 
            (Entity) ModelElement.lookupByName(
                                        "FromJavaScript",
                                        entities); 
    if (fromJS == null) 
    { fromJS = ASTTerm.currentClass; } 

    if (fromJS != null) 
    { BehaviouralFeature oldclass = 
                 fromJS.getOperation(pclass); 
      if (oldclass != null) 
      { return true; } 
    } 
       
    return false;  
  } 

  public String jsPrototypeAccessClass(ASTTerm t)
  { 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm lhs = (ASTTerm) tt.terms.get(0); 
        if (jsPrototype(lhs))
        { return jsPrototypeClass(lhs); } 
      } 
    } 
    return null; 
  } 

  public String jsPrototypeClass(ASTTerm t)
  { 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
    
        if (rhs.literalForm().equals("prototype"))
        { ASTTerm lhs = (ASTTerm) tt.terms.get(0);
          return lhs.literalForm(); 
        } 
      } 
    } 
    return null; 
  } 

  public String jsClassAccessClass(ASTTerm t, Vector entities)
  { if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm lhs = (ASTTerm) tt.terms.get(0); 
        ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        if (jsClassName(lhs,entities) && 
            rhs.hasTag("identifierName"))
        { return lhs.literalForm(); } 
      } 
    } 
    return null; 
  } 

  public String jsPrototypeAccessFeature(ASTTerm t)
  { 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        return rhs.literalForm();  
      } 
    } 
    return null; 
  } 

  public String jsClassAccessFeature(ASTTerm t, Vector entities)
  { if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if (tt.tag.equals("singleExpression") && 
          tt.terms.size() == 3 && 
          ".".equals(tt.terms.get(1) + ""))
      { ASTTerm lhs = (ASTTerm) tt.terms.get(0); 
        ASTTerm rhs = (ASTTerm) tt.terms.get(2); 
        if (jsClassName(lhs,entities) && 
            rhs.hasTag("identifierName"))
        { return rhs.literalForm(); } 
      } 
    } 
    return null; 
  } 

  public Vector jsupdateForm(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsupdateForm for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 2 && 
        "singleExpression".equals(tag) && 
        "alert".equals(
           ((ASTTerm) terms.get(0)).literalForm())) 
    { ASTTerm arg = (ASTTerm) terms.get(1); 
      Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      expr.setBrackets(true); 
      Expression disp = 
        new UnaryExpression("->display", expr); 
      Statement st = 
        new ImplicitInvocationStatement(disp); 
      Vector res = new Vector(); 
      res.add(st); 
      return res; 
    } 

    if (terms.size() == 3 && 
        "=".equals(terms.get(1) + "") && 
        jsPrototypeAccess((ASTTerm) terms.get(0)))
    { System.out.println(">++> JS prototype access: " + terms.get(0));
      // C.prototype.f = value
      ASTTerm arg = (ASTTerm) terms.get(2); 
      String feat = 
        jsPrototypeAccessFeature((ASTTerm) terms.get(0));
      Expression value = 
          arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      String pclass = 
        jsPrototypeAccessClass((ASTTerm) terms.get(0)); 
      // create class for pclass if not already existing; 
      // add feature f with initialisation value. 
      if (pclass != null) 
      { Entity ent = (Entity)
          ModelElement.lookupByName(pclass, entities);
        if (ent == null)
        { ent = new Entity(pclass); 
          entities.add(ent);
          Entity fromJS = 
            (Entity) ModelElement.lookupByName(
                                        "FromJavaScript",
                                        entities); 
          if (fromJS == null) 
          { fromJS = ASTTerm.currentClass; } 

          if (fromJS != null) 
          { BehaviouralFeature oldclass = 
                 fromJS.getOperation(pclass); 
            if (oldclass != null) 
            { oldclass.jsClassFromConstructor(
                                   ent,fromJS,new Vector(),
                                   entities);
              fromJS.removeOperation(oldclass); 
              oldclass.setType(new Type(ent));
              oldclass.setName("new" + pclass);
              oldclass.setStatic(true);  
              oldclass.setOwner(ent); 
              ent.addOperation(oldclass); 
            }
          }  
        }
        Type ftype = value.getType(); 
        Attribute attr = 
          new Attribute(feat, ftype, 
                        ModelElement.INTERNAL); 
        attr.setInitialisation(value); 
        ent.addAttribute(attr);
        BehaviouralFeature creatr = 
          ent.getOperation("new" + pclass); 
        if (creatr != null) 
        { creatr.addBeforeActivityEnd(ent,attr,value); }  
        System.out.println(">> New class from prototype assignment: " + ent.getKM3());  
      }
      return new Vector(); 
    } 

    if (terms.size() == 3 && 
        "=".equals(terms.get(1) + "") && 
        jsClassAccess((ASTTerm) terms.get(0), entities))
    { System.out.println(">++> JS class feature: " + terms.get(0));
      // C.prototype.f = value
      ASTTerm arg = (ASTTerm) terms.get(2); 
      String feat = 
        jsClassAccessFeature((ASTTerm) terms.get(0),entities);
      Expression value = 
          arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      String pclass = 
        jsClassAccessClass((ASTTerm) terms.get(0),entities); 
      // create class for pclass if not already existing; 
      // add feature f with initialisation value. 
      if (pclass != null) 
      { Entity ent = (Entity)
          ModelElement.lookupByName(pclass, entities);
        if (ent == null)
        { ent = new Entity(pclass); 
          entities.add(ent);
          Entity fromJS = 
            (Entity) ModelElement.lookupByName(
                                        "FromJavaScript",
                                        entities); 
          if (fromJS == null) 
          { fromJS = ASTTerm.currentClass; } 

          if (fromJS != null) 
          { BehaviouralFeature oldclass = 
                 fromJS.getOperation(pclass); 
            if (oldclass != null) 
            { oldclass.jsClassFromConstructor(
                                   ent,fromJS,new Vector(),
                                   entities);
              fromJS.removeOperation(oldclass); 
              oldclass.setType(new Type(ent));
              oldclass.setName("new" + pclass);
              oldclass.setStatic(true);  
              oldclass.setOwner(ent); 
              ent.addOperation(oldclass); 
            }
          }  
        }

        if ("prototype".equals(feat))
        { Type vtype = value.getType(); 
          if (vtype != null && 
              vtype.isEntity())
          { // vtype.entity is a superclass of ent 
            ent.setSuperclass(vtype.getEntity()); 
            return new Vector(); 
          } 
        } 

        Type ftype = value.getType(); 
        Attribute attr = 
          new Attribute(feat, ftype, 
                        ModelElement.INTERNAL); 
        attr.setInitialisation(value);
        attr.setStatic(true);  
        ent.addAttribute(attr);
        BehaviouralFeature creatr = 
          ent.getOperation("new" + pclass); 
        if (creatr != null) 
        { creatr.addBeforeActivityEnd(ent,attr,value); }  
        System.out.println(">> New class from class feature assignment: " + ent.getKM3());  
      }
      return new Vector(); 
    } 

    if ("yieldStatement".equals(tag) && terms.size() >= 2)
    { ASTCompositeTerm returnval = 
         (ASTCompositeTerm) terms.get(1); 
      Vector retval = returnval.jsexpressionListToKM3(
                                vartypes,varelemtypes,types,
                                entities);

      System.out.println("+++>> Yield statement " + this); 

      Expression ee = new BasicExpression("null"); 
      ee.setType(new Type("OclAny", null)); 

      if (retval.size() > 0) 
      { ee = (Expression) retval.get(0); } 

      // if (yc < _position_) 
      // { yc := yc + 1; allsideeffects } 
      // else { presideeffects; return retval; } 

      BasicExpression yc =
        BasicExpression.newVariableBasicExpression(
                                         "_yieldCount_"); 
      yc.setType(new Type("int", null)); 
      BasicExpression pos =
        BasicExpression.newVariableBasicExpression(
                                         "_position_"); 
      pos.setType(new Type("int", null)); 


      AssignStatement incr = 
        new AssignStatement(yc,
              new BinaryExpression("+",yc,unitExpression)); 

      BinaryExpression leq = new BinaryExpression("<", 
                                                  yc,pos);
      ReturnStatement retstat = 
        new ReturnStatement(ee);
      Vector prese =  
         returnval.jspreSideEffect(
                               vartypes,varelemtypes,types,
                               entities); 
      Vector postse =  
         returnval.jspostSideEffect(
                               vartypes,varelemtypes,types,
                               entities); 

      Vector resx = new Vector(); 
      resx.addAll(prese); 
      Vector incrs = new Vector(); 
      incrs.add(incr); 
      incrs.addAll(prese); 

      if (postse != null && postse.size() > 0) 
      { // return e; postse 
        // is:   var _result_ := e; postse; return _result_
        String _resid = 
          Identifier.nextIdentifier("_result_"); 
        Attribute _result_ = 
          new Attribute(_resid, 
                        ee.getType(), 
                        ModelElement.INTERNAL); 
        BasicExpression _resbe = 
          new BasicExpression(_result_); 
        CreationStatement cs = 
          new CreationStatement(_result_);         
        AssignStatement asgns = 
          new AssignStatement(_resbe,ee); 
        ReturnStatement retf = 
          new ReturnStatement(_resbe);
        resx.add(cs); 
        resx.add(asgns); 
        resx.addAll(postse);
        resx.add(retf);  
        incrs.addAll(postse);  
      } 
      else 
      { resx.add(retstat); }  
  
      ConditionalStatement conds = 
        new ConditionalStatement(leq, incrs, resx);
      Vector ystats = new Vector(); 
      ystats.add(conds);   
      return ystats; 
    } 

    if ("variableDeclarationList".equals(tag) && terms.size() >= 2)
    { Vector res = new Vector(); 
      for (int i = 1; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jsupdateForm(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      ASTTerm rhs = (ASTTerm) terms.get(2); 
      Expression var = lhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities); 
      Expression val = rhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities);
      Type tt = val.getType(); 
      if (tt == null) 
      { tt = new Type("OclAny", null); } 
      CreationStatement cs = 
         new CreationStatement(var,tt); 
      AssignStatement asgn = 
         new AssignStatement(var,val); 
      Vector res = new Vector(); 
      res.add(cs); 
      res.add(asgn);  
      return res; 
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      Expression var = lhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities);
      Type rt = new Type("OclAny", null); 
      CreationStatement cs = new CreationStatement(var,rt); 
      Vector res = new Vector(); 
      res.add(cs); 
      return res; 
    } 

    if ("expressionSequence".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jsupdateForm(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("singleExpression".equals(tag))
    { Vector res = new Vector(); 

      if (terms.size() == 0)
      { return res; } 

      if (terms.size() == 1)
      { ASTTerm t1 = (ASTTerm) terms.get(0); 
        return t1.jsupdateForm(
           vartypes, varelemtypes, types, entities); 
      } 

      ASTTerm firstTerm = (ASTTerm) terms.get(0); 
      ASTTerm lastTerm = (ASTTerm) terms.get(terms.size()-1); 

      if (terms.size() == 3 && "(".equals(firstTerm + "") &&
                             ")".equals(lastTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector expr = arg.jsupdateForm(vartypes,
                                varelemtypes,types,entities); 
        // expr.setBrackets(true); 
        return expr; 
      }

      if (terms.size() == 2 && 
            ("--".equals(firstTerm + "") ||
             "++".equals(firstTerm + "")) )
      { /* ASTTerm arg = (ASTTerm) terms.get(1); 
        String op = "" + terms.get(0); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        String oper = "" + op.charAt(0); 

        BinaryExpression minusexpr = 
          new BinaryExpression(oper, expr, unitExpression); 
        minusexpr.setType(expr.getType());  
        Statement sx = new AssignStatement(expr,minusexpr);
        res.add(sx); */  
        return res;  
      } // Handled by jspreSideEffect

      if (terms.size() == 2 && 
            ("--".equals(lastTerm + "") ||
             "++".equals(lastTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(0); 
        String op = "" + terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        
        String oper = "" + op.charAt(0); 

        BinaryExpression minusexpr = 
          new BinaryExpression(oper, expr, unitExpression); 
        minusexpr.setType(expr.getType());  
        Statement sx = new AssignStatement(expr,minusexpr); 
        res.add(sx); 
        return res;  
      } // Update form

      if (terms.size() == 2 && 
          "void".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector expr = arg.jsupdateForm(vartypes,
                                varelemtypes,types,entities); 
        return expr; 
      } 

      if (terms.size() == 2 && 
          "delete".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        if (expr instanceof BasicExpression) 
        { BasicExpression be = (BasicExpression) expr; 
          Expression obj = be.getObjectRef();
          Expression indx = be.getArrayIndex(); 
          if (indx == null && obj != null && obj.isObject())
          { // OclType.removeAttribute(obj,be.data)
            Vector dpars = new Vector(); 
            dpars.add(obj); 
            dpars.add(new BasicExpression("\"" + be.data + "\"")); 
            Expression dx = 
              BasicExpression.newStaticCallBasicExpression(
                "removeAttribute", "OclType", dpars); 
            Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                               dx,dpars);
            res.add(sdel); 
            return res; 
          } 

          if (indx != null) // sequence
          { // sq := sq->excludingAt(indx+1)
            BasicExpression sq = 
              new BasicExpression(be.data); 
            sq.setType(new Type("Sequence", null)); 
            sq.setElementType(expr.getType()); 
            Expression sqdel = 
              new BinaryExpression("->excludingAt", sq, indx);
            AssignStatement asgn = 
              new AssignStatement(sq,sqdel); 
            res.add(asgn); 
            return res; 
          } 

        }  

        if (expr instanceof BinaryExpression)
        { // delete m->at(x); is m := m->excludingAt(x)
          BinaryExpression mm = (BinaryExpression) expr; 
          if ("->at".equals(mm.getOperator()) && 
              mm.getLeft().isMap())
          { Expression sq = mm.getLeft(); 
            Expression indp = mm.getRight(); 
            Expression mdel = 
              new BinaryExpression("->excludingAt", sq, indp);
            AssignStatement asgn = 
              new AssignStatement(sq,mdel); 
            res.add(asgn); 
            return res; 
          } 
        } 
 
        expr.setBrackets(true); 
        UnaryExpression minusexpr = 
          new UnaryExpression("->isDeleted", expr); 
        Statement sx = 
           new ImplicitInvocationStatement(minusexpr);
        res.add(sx); 
        return res;   
      } 

      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()) && 
          lastTerm.arity() == 2)
      { ASTCompositeTerm oper = 
            (ASTCompositeTerm) terms.get(0); 
        Vector pars = new Vector(); 
        return oper.jsfeatureAccessUpdateForm(
                        pars,
                        vartypes,
                        varelemtypes,types,entities);
      } 

      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()))
      { ASTTerm oper = (ASTTerm) terms.get(0); 
        Vector pars = 
          ((ASTCompositeTerm) lastTerm).jsexpressionListToKM3(
                 vartypes,varelemtypes,types,entities);
        Expression opexpr = 
          oper.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
       
        System.out.println("**>> Update form of *>> " + opexpr + " " + pars); 

        // if (lastTerm.isJSspreadExpression())
        // { opexpr = jsspreadExpressionCall(opexpr, lastTerm,
        //                 vartypes,varelemtypes,types,entities);
        // } else       
        if (opexpr.isFunctionType())
        { opexpr = Expression.convertToApply(opexpr, pars); }
        else if (opexpr instanceof BasicExpression)
        { BasicExpression be = (BasicExpression) opexpr; 
          if (be.objectRef == null) 
          { be.setParameters(pars); }
          else 
          { return jsfeatureAccessUpdateForm(
                        be.objectRef,be.data,pars,
                        vartypes,
                        varelemtypes,types,entities);
          }  
        }
        else 
        { opexpr = Expression.convertToApply(opexpr, pars); }    

        // Expression opcall = 
        //   BasicExpression.newCallBasicExpression(opexpr, 
        //                                            pars);

       Statement sx = 
           InvocationStatement.newInvocationStatement(
                                              opexpr,pars); 
       res.add(sx); 
       return res;  
     } 

  /* 
     if (terms.size() == 3 &&
          ".".equals(terms.get(1) + "") &&  
          "identifierName".equals(lastTerm.getTag()))
     { // obj.f is obj.f unless obj is a map: obj["f"]

        Expression feature = 
          lastTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Expression obj = firstTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
          
        return jsfeatureAccessUpdateForm(
                               obj,feature + "",new Vector(),
                               vartypes,
                               varelemtypes,types,entities); 
      } */ 

    /* 
      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()))
      { ASTTerm oper = (ASTTerm) terms.get(0); 
        Vector pars = 
          ((ASTCompositeTerm) lastTerm).jsexpressionListToKM3(
                 vartypes,varelemtypes,types,entities);
        Expression opexpr = 
          oper.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);

        if ("Array".equals(oper.literalForm()))
        { SetExpression res = new SetExpression(pars,true); 
          return res; 
        } 
 
        if (opexpr instanceof BasicExpression)
        { BasicExpression be = (BasicExpression) opexpr; 
          if (be.objectRef == null) 
          { be.setParameters(pars); 
            return be; 
          }
          return jsfeatureAccess(be.objectRef,be.data,pars,
                                 vartypes,
                                 varelemtypes,types,entities); 
        } 
        else 
        { opexpr = Expression.convertToApply(opexpr, pars); }    

        // Expression opcall = 
        //   BasicExpression.newCallBasicExpression(opexpr, 
        //                                            pars);

        return opexpr; 
      } */ 


      if (terms.size() == 2 &&
          "new".equals(firstTerm + ""))
      { // new C is C.newC() in the case of class C

        ASTTerm cname = (ASTTerm) terms.get(1); 
        Expression cls = cname.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        String constr = "new" + cls;
        String cnme = cname.literalForm(); 
  
        Vector pars = new Vector(); 
        BasicExpression classexpr = 
          BasicExpression.newStaticCallBasicExpression(constr,
                                                    cls,pars); 
        Statement sx = 
          InvocationStatement.newInvocationStatement(
                                             classexpr,pars);
        res.add(sx); 
        return res;   
      } 

      if (terms.size() == 3 && "=".equals(terms.get(1) + ""))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 

        if (lhsexpr instanceof BasicExpression)
        { BasicExpression lbe = (BasicExpression) lhsexpr; 
          if (lbe.data.equals("length") && 
              lbe.objectRef != null && 
              lbe.objectRef.isSequence())
          { // resize of sequence
            Vector spars = new Vector(); 
            spars.add(unitExpression); 
            spars.add(rhsexpr); 
            BasicExpression shrink = 
              BasicExpression.newFunctionBasicExpression(
                                "subrange", lbe.objectRef,
                                spars); 
            Statement asgn = 
              new AssignStatement(lbe.objectRef, shrink); 
            res.add(asgn); 
            return res; 
          }

          if (lbe.data.equals("getAttributeValue") && 
              lbe.objectRef != null && 
              "OclType".equals(lbe.objectRef + ""))
          { // assign to attribute by name
            Vector bpars = lbe.getParameters(); 
            Vector spars = new Vector(); 
            spars.addAll(bpars); 
            spars.add(rhsexpr); 
            BasicExpression updateField = 
              BasicExpression.newStaticCallBasicExpression(
                                "setAttributeValue", 
                                lbe.objectRef,
                                spars); 
            Statement asgn = 
              InvocationStatement.newInvocationStatement(
                                     updateField,spars); 
            res.add(asgn); 
            return res; 
          }

          if (lbe.objectRef != null && lbe.objectRef.isObject()) 
          { Type etype = lbe.objectRef.getType(); 
            if (etype != null && etype.getEntity() != null) 
            { Entity ee = etype.getEntity(); 
              if (ee.hasOperation(lbe.data))
              { BasicExpression opexpr = 
                  BasicExpression.newCallBasicExpression(
                     lbe.data + "", lbe.objectRef, rhsexpr); 
                Statement asgn = 
                  InvocationStatement.newInvocationStatement(
                                        opexpr, rhsexpr); 
                res.add(asgn); 
                return res; 
              } 
            } 
          } // setter

        } 
        else if (lhsexpr instanceof UnaryExpression) 
        { UnaryExpression lbe = (UnaryExpression) lhsexpr;
          String lbeop = lbe.getOperator();  
          Expression obj = lbe.getArgument(); 
          if (lbeop.equals("->size") && 
              obj.isSequence())
          { // resize of sequence
            Vector spars = new Vector(); 
            spars.add(unitExpression); 
            spars.add(rhsexpr); 
            BasicExpression shrink = 
              BasicExpression.newFunctionBasicExpression(
                                "subrange", obj,
                                spars); 
            shrink.setType(obj.getType());
            shrink.setElementType(obj.getElementType());

            Statement asgn = 
              new AssignStatement(obj, shrink); 
            res.add(asgn); 
            return res; 
          }
        } 


        Statement sx = new AssignStatement(lhsexpr, rhsexpr); 
        res.add(sx); 
        return res;  
      } 

      if (terms.size() == 3 && 
          "+=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsplus = 
          new BinaryExpression("+", lhsexpr, rhsexpr);  
        Statement sx = new AssignStatement(lhsexpr, lhsplus);
        res.add(sx); 
        return res;   
      }  

      if (terms.size() == 3 && 
          "-=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsminus = 
          new BinaryExpression("-", lhsexpr, rhsexpr);  
        Statement sx = new AssignStatement(lhsexpr, lhsminus);
        res.add(sx); 
        return res;   
      } // really a statement. 

      if (terms.size() == 3 && 
          "*=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsplus = 
          new BinaryExpression("*", lhsexpr, rhsexpr);  
        Statement sx = new AssignStatement(lhsexpr, lhsplus);
        res.add(sx); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "/=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsdiv = 
          new BinaryExpression("/", lhsexpr, rhsexpr);  
        Statement sx = new AssignStatement(lhsexpr, lhsdiv);
        res.add(sx); 
        return res;   
      } // really a statement. 
 
      if (terms.size() == 3 && 
          "%=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsdiv = 
          new BinaryExpression("mod", lhsexpr, rhsexpr);  
        Statement sx = new AssignStatement(lhsexpr, lhsdiv);
        res.add(sx); 
        return res;   
      } // really a statement. 

      if (terms.size() == 3 && 
          "^=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseXor", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        Statement sx = new AssignStatement(lhsexpr, lhsdiv);
        res.add(sx); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "|=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseOr", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        Statement sx = new AssignStatement(lhsexpr, lhsdiv);
        res.add(sx); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "&=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseAnd", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        Statement sx = new AssignStatement(lhsexpr, lhsdiv);
        res.add(sx); 
        return res;   
      } 

    } 

    return new Vector(); 
  } 

  public Vector jspreSideEffect(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jspreSideEffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 2 && 
        "singleExpression".equals(tag) && 
        "alert".equals(
           ((ASTTerm) terms.get(0)).literalForm())) 
    { ASTTerm arg = (ASTTerm) terms.get(1); 
      Vector res = arg.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
      return res; 
    } 

    if ("variableDeclarationList".equals(tag) && terms.size() >= 2)
    { Vector res = new Vector(); 
      for (int i = 1; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jspreSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      ASTTerm rhs = (ASTTerm) terms.get(2); 
      Vector res = rhs.jspreSideEffect(vartypes,
                              varelemtypes,types,entities);
      return res; 
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      Vector res = lhs.jspreSideEffect(vartypes,
                              varelemtypes,types,entities);
      return res; 
    } 

    if ("expressionSequence".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jspreSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("singleExpression".equals(tag))
    { Vector res = new Vector(); 

      if (terms.size() == 0)
      { return res; } 

      if (terms.size() == 1)
      { ASTTerm t1 = (ASTTerm) terms.get(0); 
        return t1.jspreSideEffect(
           vartypes, varelemtypes, types, entities); 
      } 

      ASTTerm firstTerm = (ASTTerm) terms.get(0); 
      ASTTerm lastTerm = (ASTTerm) terms.get(terms.size()-1); 

      if (terms.size() == 3 && "(".equals(firstTerm + "") &&
                             ")".equals(lastTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        return vect; 
      }

      if (terms.size() == 2 && 
            ("--".equals(firstTerm + "") ||
             "++".equals(firstTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        String op = "" + terms.get(0); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        String oper = "" + op.charAt(0); 

        BinaryExpression minusexpr = 
          new BinaryExpression(oper, expr, unitExpression); 
        minusexpr.setType(expr.getType());  
        Statement sx = new AssignStatement(expr,minusexpr);
        res.add(sx); 
        return res;  
      } 

      if (terms.size() == 2 && 
            ("--".equals(lastTerm + "") ||
             "++".equals(lastTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(0); 
        Vector vect = arg.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        
        return vect;  
      } 

      if (terms.size() == 4 &&
          "[".equals(terms.get(1) + "") &&  
          "]".equals(lastTerm + ""))
      { // x[f] is x[f+1] unless x is a map: x[f] or x["f"]
        ASTTerm indterm = (ASTTerm) terms.get(2); 
        Vector indx = 
          indterm.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        return indx; 
      } 

      if (terms.size() == 2 && 
          "void".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        return vect; 
      } 

      if (terms.size() == 2 && 
          "delete".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        return vect;   
      } 

   
      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()) && 
          lastTerm.arity() == 2)
      { // ASTCompositeTerm oper = 
        //     (ASTCompositeTerm) terms.get(0); 
        Vector pars = new Vector(); 
        // return oper.jsfeatureAccessUpdateForm(
        //                 pars,
        //                 vartypes,
        //                 varelemtypes,types,entities);
        return pars; 
      } // Specialised presideEffect for this case.

      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()))
      { Vector pars = 
         ((ASTCompositeTerm) 
             lastTerm).jsexpressionListPreSideEffect(
                 vartypes,varelemtypes,types,entities);
        return pars;  
      } 


      if (terms.size() == 2 &&
          "new".equals(firstTerm + ""))
      { // new C is C.newC() in the case of class C

        return res;   
      } 

      if (terms.size() == 3 && "=".equals(terms.get(1) + ""))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 

        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;  
      } 

      if (terms.size() == 3 && 
          "+=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      }  

      if (terms.size() == 3 && 
          "-=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "*=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "/=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 
 
      if (terms.size() == 3 && 
          "%=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "^=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "|=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "&=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspreSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

    } 

    return new Vector(); 
  } 

  public Vector jspostSideEffect(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jspostSideEffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() == 2 && 
        "singleExpression".equals(tag) && 
        "alert".equals(
           ((ASTTerm) terms.get(0)).literalForm())) 
    { ASTTerm arg = (ASTTerm) terms.get(1); 
      Vector res = arg.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
      return res; 
    } 

    if ("variableDeclarationList".equals(tag) && terms.size() >= 2)
    { Vector res = new Vector(); 
      for (int i = 1; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jspostSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      ASTTerm rhs = (ASTTerm) terms.get(2); 
      Vector res = rhs.jspostSideEffect(vartypes,
                              varelemtypes,types,entities);
      return res; 
    } 

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      Vector res = lhs.jspostSideEffect(vartypes,
                              varelemtypes,types,entities);
      return res; 
    } 

    if ("expressionSequence".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector par = 
            arg.jspostSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.addAll(par); } 
        } 
      } 
      return res;
    } 

    if ("singleExpression".equals(tag))
    { Vector res = new Vector(); 

      if (terms.size() == 0)
      { return res; } 

      if (terms.size() == 1)
      { ASTTerm t1 = (ASTTerm) terms.get(0); 
        return t1.jspostSideEffect(
           vartypes, varelemtypes, types, entities); 
      } 

      ASTTerm firstTerm = (ASTTerm) terms.get(0); 
      ASTTerm lastTerm = (ASTTerm) terms.get(terms.size()-1); 

      if (terms.size() == 3 && "(".equals(firstTerm + "") &&
                             ")".equals(lastTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        return vect; 
      }

      if (terms.size() == 2 && 
            ("--".equals(lastTerm + "") ||
             "++".equals(lastTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(0); 
        String op = "" + lastTerm; 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        String oper = "" + op.charAt(0); 

        BinaryExpression minusexpr = 
          new BinaryExpression(oper, expr, unitExpression); 
        minusexpr.setType(expr.getType());  
        Statement sx = new AssignStatement(expr,minusexpr);
        res.add(sx); 
        return res;  
      } 

      if (terms.size() == 2 && 
            ("--".equals(firstTerm + "") ||
             "++".equals(firstTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        
        return vect;  
      } 

      if (terms.size() == 4 &&
          "[".equals(terms.get(1) + "") &&  
          "]".equals(lastTerm + ""))
      { // x[f] is x[f+1] unless x is a map: x[f] or x["f"]
        ASTTerm indterm = (ASTTerm) terms.get(2); 
        Vector indx = 
          indterm.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        return indx; 
      } 

      if (terms.size() == 2 && 
          "void".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        return vect; 
      } 

      if (terms.size() == 2 && 
          "delete".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Vector vect = arg.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        return vect;   
      } 

   
      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()) && 
          lastTerm.arity() == 2)
      { // ASTCompositeTerm oper = 
        //     (ASTCompositeTerm) terms.get(0); 
        Vector pars = new Vector(); 
        // return oper.jsfeatureAccessUpdateForm(
        //                 pars,
        //                 vartypes,
        //                 varelemtypes,types,entities);
        return pars; 
      } // Specialised presideEffect for this case.

      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()))
      { Vector pars = 
         ((ASTCompositeTerm) 
             lastTerm).jsexpressionListToKM3(
                 vartypes,varelemtypes,types,entities);

        if ("Object.assign".equals(firstTerm.literalForm()) && 
            pars.size() == 2)
        { Expression par1 = (Expression) pars.get(0);
          Expression par2 = (Expression) pars.get(1);
          AssignStatement asgn = null; 
          if ("null".equals(par1 + ""))  
          { asgn = new AssignStatement(par1,par2); } 
          else if ("null".equals(par2 + ""))  
          { return new Vector(); }
          else  
          { par1.setBrackets(true);
            Expression expr = 
              new BinaryExpression("->union", par1, par2);  
            expr.setType(par1.getType());  
            expr.setElementType(par1.getElementType()); 
            asgn = 
              new AssignStatement(par1,expr);
          }  
          Vector cmds = new Vector(); 
          cmds.add(asgn); 
          return cmds; 
        }  // map union; par1 := par1->union(par2)

        if ("Object.defineProperty".equals(
                       firstTerm.literalForm()) && 
            pars.size() == 3)
        { Expression par1 = (Expression) pars.get(0);
          Expression par2 = (Expression) pars.get(1);
          Expression par3 = (Expression) pars.get(2);

          par1.setBrackets(true);

          SetExpression newfeat = new SetExpression(); 
          newfeat.setType(new Type("Map", null)); 
          newfeat.setElementType(new Type("OclAny", null)); 
          newfeat.addElement(
            new BinaryExpression("|->", par2, 
               new BinaryExpression("->at", par3, 
                  BasicExpression.newValueBasicExpression(
                                      "\"value\"")))); 

          Expression expr = 
             new BinaryExpression("->union", par1, newfeat);  
          expr.setType(par1.getType());  
          expr.setElementType(par1.getElementType()); 
          AssignStatement asgn = 
             new AssignStatement(par1,expr);
          Vector cmds = new Vector(); 
          cmds.add(asgn); 
          return cmds; 
        }  // map union; par1 := par1->union(Map{par2 |-> par3->at("value")})

        return new Vector();  
      } 


      if (terms.size() == 2 &&
          "new".equals(firstTerm + ""))
      { // new C is C.newC() in the case of class C

        return res;   
      } 

      if (terms.size() == 3 && "=".equals(terms.get(1) + ""))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 

        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;  
      } 

      if (terms.size() == 3 && 
          "+=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      }  

      if (terms.size() == 3 && 
          "-=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "*=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "/=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 
 
      if (terms.size() == 3 && 
          "%=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "^=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "|=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

      if (terms.size() == 3 && 
          "&=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { ASTTerm lhs = (ASTTerm) terms.get(0); 
        Vector lhsvect = lhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Vector rhsvect = rhs.jspostSideEffect(vartypes,
                                varelemtypes,types,entities);
        res.addAll(lhsvect); 
        res.addAll(rhsvect); 
        return res;   
      } 

    } 

    return new Vector(); 
  } 

  public Vector jsexpressionListToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsexpressionListToKM3 for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    Vector res = new Vector(); 

    if ("arguments".equals(tag) || 
        "expressionSequence".equals(tag))
    { for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Expression par = 
            arg.jsexpressionToKM3(vartypes,varelemtypes,types,
                                  entities); 
          if (par != null) 
          { res.add(par); } 
        } 
      } 
    } 
    return res; 
  } 

  public Vector jsexpressionListPreSideEffect(
    java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsexpressionListPreSideEffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    Vector res = new Vector(); 

    if ("arguments".equals(tag))
    { for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector pars = 
            arg.jspreSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (pars != null) 
          { res.addAll(pars); } 
        } 
      } 
    } 
    return res; 
  } 

  public Vector jsexpressionListPostSideEffect(
    java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsexpressionListPostSideEffect for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    Vector res = new Vector(); 

    if ("arguments".equals(tag))
    { for (int i = 0; i < terms.size(); i++)
      { ASTTerm arg = (ASTTerm) terms.get(i); 
        if (arg instanceof ASTSymbolTerm)
        { } 
        else 
        { Vector pars = 
            arg.jspostSideEffect(vartypes,varelemtypes,types,
                                  entities); 
          if (pars != null) 
          { res.addAll(pars); } 
        } 
      } 
    } 
    return res; 
  } 

  public Vector jsfeatureAccessUpdateForm(Vector pars,
                      java.util.Map vartypes, 
                      java.util.Map varelemtypes, 
                      Vector types, Vector entities)
  { System.out.println(">> jsfeatureAccessUpdateForm for " + tag + " with " + terms.size() + " terms"); 
    System.out.println(); 

    if (terms.size() < 3) 
    { return new Vector(); } 

    ASTTerm firstTerm = (ASTTerm) terms.get(0); 
    ASTTerm lastTerm = (ASTTerm) terms.get(terms.size()-1); 


    if (terms.size() == 3 &&
          ".".equals(terms.get(1) + "") &&  
          "identifierName".equals(lastTerm.getTag()))
    { // obj.f is obj.f unless obj is a map: obj["f"]

      Expression feature = 
          lastTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      Expression obj = firstTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
          
      return jsfeatureAccessUpdateForm(
                               obj,feature + "",new Vector(),
                               vartypes,
                               varelemtypes,types,entities); 
     } // What about pars? 

     return new Vector(); 
   } 


  public Vector jsfeatureAccessUpdateForm(Expression obj, 
                      String feature, Vector pars,
                      java.util.Map vartypes, 
                      java.util.Map varelemtypes, 
                      Vector types, Vector entities)
  { System.out.println(">> jsfeatureAccessUpdateForm for " + tag + " with " + terms.size() + " terms " + obj + "." + feature + pars); 
    System.out.println(); 

    

    if ("console".equals(obj + "") && 
        ("log".equals(feature) || 
         "info".equals(feature)) && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      par1.setBrackets(true); 
      Expression res = 
        new UnaryExpression("->display", par1); 
      Vector cmds = new Vector(); 
      cmds.add(new ImplicitInvocationStatement(res));
      return cmds;  
    } 

    if ("Atomics".equals(obj + ""))
    { if ("add".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.add(arr,ind,val) does 
        // arr->at(ind+1) := arr->at(ind+1) + val 

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression sumarr = 
          new BinaryExpression("+", arr, p3);
        AssignStatement asgn = 
          new AssignStatement(arr, sumarr);  
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds; 
      }

      if ("sub".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.sub(arr,ind,val) does
        // arr->at(ind+1) := arr->at(ind+1) - val 

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression sumarr = 
          new BinaryExpression("-", arr, p3);
        AssignStatement asgn = 
          new AssignStatement(arr, sumarr);  
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds; 
      }

      if ("and".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.and(arr,ind,val) uses bitwiseAnd
        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        Vector parsx = new Vector(); 
        parsx.add(arr); 
        parsx.add(p3); 
        Expression sumarr = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseAnd", "MathLib", parsx);
        AssignStatement asgn = 
          new AssignStatement(arr, sumarr);  
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds; 
      }

      if ("or".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.or(arr,ind,val) uses bitwiseOr

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        Vector parsx = new Vector(); 
        parsx.add(arr); 
        parsx.add(p3); 
        Expression sumarr = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseOr", "MathLib", parsx);
        AssignStatement asgn = 
          new AssignStatement(arr, sumarr);  
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds; 
      }

      if ("xor".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.xor(arr,ind,val) uses bitwiseXor

       Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        Vector parsx = new Vector(); 
        parsx.add(arr); 
        parsx.add(p3); 
        Expression sumarr = 
          BasicExpression.newStaticCallBasicExpression(
            "bitwiseXor", "MathLib", parsx);
        AssignStatement asgn = 
          new AssignStatement(arr, sumarr);  
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds; 
      }

      if ("compareExchange".equals(feature) &&
          pars.size() > 3) 
      { // Atomics.compareExchange(arr,ind,oldval,val) 
        // if oldval = arr->at(ind+1) 
        // then arr->at(ind+1) := val else skip

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
        Expression p4 = (Expression) pars.get(3); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        BinaryExpression eqold = 
          new BinaryExpression("=", arr, p3); 
        AssignStatement asgn = 
          new AssignStatement(arr,p4); 
        ConditionalStatement cs = 
          new ConditionalStatement(
                 eqold, asgn, skipStatement); 
        Vector cmds = new Vector(); 
        cmds.add(cs);
        return cmds;
      }

   
      if ("exchange".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.exchange(arr,ind,val) 
        // arr->at(ind+1) := val

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        AssignStatement asgn = 
          new AssignStatement(arr,p3); 
        Vector cmds = new Vector(); 
        cmds.add(asgn);
        return cmds;
      }

      if ("store".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.store(arr,ind,val) is arr[ind+1] := val

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
     
        Vector cmds = new Vector(); 
        cmds.add(new AssignStatement(arr,p3)); 
        return cmds; 
      } 

      if ("notify".equals(feature) &&
          pars.size() >= 2) 
      { // Atomics.notify(arr,ind,val) is 
        // OclProcess.notify(arr->at(ind+1))

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        Expression call = 
          BasicExpression.newStaticCallBasicExpression(
                            "notify",
                            "OclProcess", arr);
        Vector cmds = new Vector(); 
        cmds.add(
           InvocationStatement.newInvocationStatement(
                                       call,arr));   
        return cmds; 
      } // update form only.

  
      if (("wait".equals(feature) || 
           "waitAsync".equals(feature)) &&
          pars.size() == 3) 
      { // Atomics.wait(arr,ind,val) is 
        // OclProcess.wait(arr->at(ind+1) /= val,0)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2);

        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression neq = 
          new BinaryExpression("/=", arr, p3); 
        Vector argsx = new Vector(); 
        argsx.add(neq); 
        argsx.add(zeroExpression); 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression("wait",
                            "OclProcess", argsx);  
        Vector cmds = new Vector(); 
        cmds.add(
           InvocationStatement.newInvocationStatement(
                                       call,argsx));   
        return cmds; 
      } // update form only.

      if (("wait".equals(feature) || 
           "waitAsync".equals(feature)) &&
          pars.size() == 4) 
      { // Atomics.wait(arr,ind,val,t) is 
        // OclProcess.wait(arr->at(ind+1) /= val,t)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2);
        Expression p4 = (Expression) pars.get(3);

        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression neq = 
          new BinaryExpression("/=", arr, p3); 
        Vector argsx = new Vector(); 
        argsx.add(neq); 
        argsx.add(p4); 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression("wait",
                            "OclProcess", argsx);

        Vector cmds = new Vector(); 
        cmds.add(
           InvocationStatement.newInvocationStatement(
                                       call,argsx));   
        return cmds;  
      } // update form only.
    }  

    if ("Reflect".equals(obj + ""))
    { 
      if ("defineProperty".equals(feature) && 
          pars.size() == 3) 
      { Expression par1 = (Expression) pars.get(0);
        Expression par2 = (Expression) pars.get(1);
        Expression par3 = (Expression) pars.get(2);

        Vector dpars = new Vector(); 
        dpars.add(par1); 
        dpars.add(par2);
        dpars.add(
            BasicExpression.newAttributeBasicExpression(
                    "value",par3));  
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "setAttributeValue", "OclType", dpars); 
        Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                                dx,dpars);
        Vector cmds = new Vector(); 
        cmds.add(sdel); 
        return cmds;  
      } // only update form

      if ("deleteProperty".equals(feature) && 
          pars.size() == 2) 
      { Expression par1 = (Expression) pars.get(0);
        Expression par2 = (Expression) pars.get(1);
        Vector dpars = new Vector(); 
        dpars.add(par1); 
        dpars.add(par2); 
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "removeAttribute", "OclType", dpars); 
        Statement sdel = 
                InvocationStatement.newInvocationStatement(
                                                dx,dpars);
        Vector cmds = new Vector(); 
        cmds.add(sdel); 
        return cmds; 
      } // only update form

      if ("set".equals(feature) && 
          pars.size() == 3) 
      { Expression par1 = (Expression) pars.get(0);
        Expression par2 = (Expression) pars.get(1);
        Expression par3 = (Expression) pars.get(2);

        Vector dpars = new Vector(); 
        dpars.add(par1); 
        dpars.add(par2);
        dpars.add(par3);   
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "setAttributeValue", "OclType", dpars); 
        Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                               dx,dpars);
        Vector cmds = new Vector(); 
        cmds.add(sdel); 
        return cmds; 
      } // update form

    } 

    if ("apply".equals(feature + "") && 
        pars.size() >= 1 && 
        obj instanceof BasicExpression)
    { // 2 parameters 
      Expression targ = null; 
      Expression oppars = (Expression) pars.get(0); 
      if (pars.size() > 1)
      { targ = (Expression) pars.get(0); 
        oppars = (Expression) pars.get(1);
      } 

      String mname = ((BasicExpression) obj).getData(); 
      Expression mobj = 
         ((BasicExpression) obj).getObjectRef();

      BehaviouralFeature mm = 
        Entity.findOperation(mname, entities);
 
      if (mm != null) 
      { int n = mm.getArity(); 
        Vector actualpars = new Vector(); 
        for (int i = 0; i < n; i++) 
        { Expression actualpar = 
            new BinaryExpression("->at", oppars,
                                 new BasicExpression(i+1));
          actualpars.add(actualpar); 
        } 
  
        if ("null".equals(targ + ""))
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                  mname,mobj,actualpars); 
          res.setType(mm.getResultType());  
          Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                        res,actualpars);
          Vector cmds = new Vector(); 
          cmds.add(sdel); 
          return cmds;  
        }
        else 
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                  mname,targ,actualpars); 
          res.setType(mm.getResultType());  
          Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                  res,actualpars);
          Vector cmds = new Vector(); 
          cmds.add(sdel); 
          return cmds; 
        }
      } 
    }

    if ("Object".equals(obj + "") && 
        "assign".equals(feature) && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      AssignStatement asgn = null; 
      if ("null".equals(par1 + ""))  
      { asgn = new AssignStatement(par1,par2); } 
      else if ("null".equals(par2 + ""))  
      { return new Vector(); }
      else  
      { par1.setBrackets(true);
        Expression expr = 
          new BinaryExpression("->union", par1, par2);  
        expr.setType(par1.getType());  
        expr.setElementType(par1.getElementType()); 
        asgn = 
          new AssignStatement(par1,expr);
      }  
      Vector cmds = new Vector(); 
      cmds.add(asgn); 
      return cmds; 
    }  // map union; par1 := par1->union(par2)

    if ("Object".equals(obj + "") && 
        "defineProperty".equals(feature) && 
        pars.size() == 3)
    { Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      Expression par3 = (Expression) pars.get(2);

      par1.setBrackets(true);

      SetExpression newfeat = new SetExpression(); 
      newfeat.setType(new Type("Map", null)); 
      newfeat.setElementType(new Type("OclAny", null)); 
      newfeat.addElement(
        new BinaryExpression("|->", par2, 
           new BinaryExpression("->at", par3, 
              BasicExpression.newValueBasicExpression(
                                      "\"value\"")))); 

      Expression expr = 
          new BinaryExpression("->union", par1, newfeat);  
      expr.setType(par1.getType());  
      expr.setElementType(par1.getElementType()); 
      AssignStatement asgn = 
          new AssignStatement(par1,expr);
      Vector cmds = new Vector(); 
      cmds.add(asgn); 
      return cmds; 
    }  // map union; par1 := par1->union(Map{par2 |-> par3->at("value")})

    if ("Object".equals(obj + "") && 
        "defineProperties".equals(feature) && 
        pars.size() == 2)
    { // par1->union(par2->collect(x | x->at("value")))
 
      Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      
      par1.setBrackets(true);
      par2.setBrackets(true); 

      Type maptype = new Type("Map", null); 
      maptype.setKeyType(new Type("String", null));
      maptype.setElementType(new Type("OclAny", null));

      par2.setElementType(maptype); 

   /* 
      BasicExpression $k = 
        BasicExpression.newVariableBasicExpression("$k"); 
      $k.setType(new Type("String", null)); 
      $k.setElementType(new Type("String", null)); 

      BasicExpression acc = 
        BasicExpression.newVariableBasicExpression("$acc"); 
      
      acc.setType(maptype);
      acc.setElementType(new Type("OclAny", null)); 
 
      SetExpression emptyMap = new SetExpression(); 
      emptyMap.setType(maptype); 
      emptyMap.setElementType(new Type("OclAny", null));
 
      Attribute accatt = 
        new Attribute("$acc", maptype, ModelElement.INTERNAL); 
      accatt.setInitialExpression(emptyMap); 
      accatt.setElementType(new Type("OclAny", null)); 

      Expression getk = 
        new BinaryExpression("->at", par2, $k);  
      getk.setType(maptype); 
      getk.setElementType(new Type("OclAny", null));

      Expression castgetk = 
        new BinaryExpression("->oclAsType", getk, mapTypeExpression); 
      castgetk.setType(maptype); 
      castgetk.setElementType(new Type("OclAny", null));

      Expression newfeat =        
           new BinaryExpression("->at", 
               castgetk, 
               BasicExpression.newValueBasicExpression(
                                      "\"value\""));
      newfeat.setType(new Type("OclAny", null));
      newfeat.setElementType(new Type("OclAny", null)); 

      SetExpression newmap = new SetExpression(); 
      newmap.setType(maptype); 
      newmap.addMapElement($k, newfeat); 
      newmap.setElementType(new Type("OclAny", null)); 
 
      UnaryExpression keys = 
        new UnaryExpression("->keys", par2); 
      keys.setType(new Type("Set",null)); 
      keys.setElementType(new Type("String", null)); 

      Expression newfeats = 
        new BinaryExpression("->union", acc, newmap); 
      newfeats.setType(maptype); 
      newfeats.setElementType(new Type("OclAny", null)); 

      BinaryExpression expr = 
          new BinaryExpression("->iterate", keys, newfeats);
      expr.setAccumulator(accatt); 
      expr.setIteratorVariable("$k"); */ 

      BasicExpression varx = 
        BasicExpression.newVariableBasicExpression("_x"); 
      varx.setType(new Type("Map", null)); 
      varx.setElementType(new Type("OclAny", null)); 

      Expression valexpr = 
               BasicExpression.newValueBasicExpression(
                                      "\"value\""); 
      Expression par2dom = 
        new BinaryExpression(":", varx, par2); 
      Expression collrng =        
           new BinaryExpression("->at", 
                                varx, valexpr);
      collrng.setType(new Type("OclAny", null)); 
      collrng.setElementType(new Type("OclAny", null)); 

      Expression testexpr = 
        new BinaryExpression("->includes", 
          new UnaryExpression("->keys", varx),valexpr); 
      testexpr.setType(new Type("boolean", null)); 
 
      Expression condexpr = 
        new ConditionalExpression(testexpr,
                                  collrng,nullExpression); 
      condexpr.setType(new Type("OclAny", null)); 

      BinaryExpression mapcollect = 
        new BinaryExpression("|C", par2dom, condexpr); 
      mapcollect.setType(maptype);  
      mapcollect.setElementType(new Type("OclAny", null)); 

      BinaryExpression expr = 
        new BinaryExpression("->union", par1, mapcollect); 
  
      expr.setType(maptype);  
      expr.setElementType(new Type("OclAny", null)); 
      AssignStatement asgn = 
          new AssignStatement(par1,expr);
      Vector cmds = new Vector(); 
      cmds.add(asgn); 
      return cmds; 
    }  
       // par1 := par2->keys()->iterate($k; acc = par1 | acc->union(Map{ $k |-> par2->at($k)->at("value") } ) )

    if ("call".equals(feature + "") && 
        obj instanceof BasicExpression)
    { Expression targ = null; 
      Vector oppars = new Vector(); 
      if (pars.size() > 0)
      { targ = (Expression) pars.get(0); 
        oppars.addAll(pars); 
        oppars.remove(0);
      } 

      String mname = ((BasicExpression) obj).getData(); 
      Expression mobj = 
         ((BasicExpression) obj).getObjectRef();

      BehaviouralFeature mm = 
        Entity.findOperation(mname, entities);
 
      if (mm != null) 
      { if ("null".equals(targ + ""))
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,mobj,oppars); 
          res.setType(mm.getResultType());  
          Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                      res,oppars);
          Vector cmds = new Vector(); 
          cmds.add(sdel); 
          return cmds; 
        }
        else 
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,targ,oppars); 
          res.setType(mm.getResultType());  
          Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                        res,oppars);
          Vector cmds = new Vector(); 
          cmds.add(sdel); 
          return cmds; 
        }
      } 
      else 
      { Entity mclass = 
          (Entity) ModelElement.lookupByName(mname, entities);
        if (mclass != null)
        { // we are in subclass, calling superclass mname 
          // constructor on self. 
          Expression res = 
            BasicExpression.newCallBasicExpression(
                       "initialise" + mname,targ,oppars); 
          Statement sdel = 
               InvocationStatement.newInvocationStatement(
                                        res,oppars);
          Vector cmds = new Vector(); 
          cmds.add(sdel); 
          return cmds; 
        }
      } 
    }

    if ("setFullYear".equals(feature) && 
        obj.isOclDate() && pars.size() == 1)
    { Expression par = (Expression) pars.get(0); 
      Expression yr =
        BasicExpression.newCallBasicExpression(
                                 "setYear",obj,par);
      Statement sdel = 
        InvocationStatement.newInvocationStatement(
                                        yr,par);
      Vector cmds = new Vector(); 
      cmds.add(sdel); 
      return cmds; 
    } 

    if ("next".equals(feature) && 
        obj.isOclIterator() && pars.size() == 0)
    { // itr.nextResult() returns OclIteratorResult object
      Expression res =
        BasicExpression.newCallBasicExpression("nextResult", obj); 
      res.setType(new Type("OclIteratorResult", null)); 
      Vector cmds = new Vector(); 
      cmds.add(
           InvocationStatement.newInvocationStatement(res));   
      return cmds;  
    } 

    if ("fill".equals(feature) &&
        obj.isSequence()) 
    { Expression par1 = (Expression) pars.get(0);     
          
      if (pars.size() == 1)
      { Expression expr = 
                new BinaryExpression("->collect", 
                                     obj,par1); 
        // Statement stat = 
                new AssignStatement(obj, expr); 
        expr.setType(obj.getType()); 
        expr.setElementType(par1.getType()); 
        Vector cmds = new Vector(); 
        cmds.add(
           new AssignStatement(obj,expr));   
        return cmds; 
      } 

      if (pars.size() == 2) 
      { Expression lowind = (Expression) pars.get(1); 
        Expression highind = 
          new UnaryExpression("->size",obj);
        Expression elem = (Expression) pars.get(0);
            
        Vector pars1 = new Vector(); 
        pars1.add(unitExpression); 
        pars1.add(lowind); 

        Expression subrange1 = 
          BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars1); 

        Vector pars2 = new Vector(); 
        pars2.add(new BinaryExpression("+",
                     lowind,unitExpression)); 
        pars2.add(highind); 

        Expression subrange2 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars2); 
 
        subrange2 = 
           new BinaryExpression("->collect", subrange2, elem); 
        subrange2.setBrackets(true); 

        Expression expr = 
              new BinaryExpression("^", subrange1, subrange2); 
        expr.setType(new Type("Sequence", null)); 
        Vector cmds = new Vector(); 
        cmds.add(
           new AssignStatement(obj,expr));   
        return cmds; 
      }  

      if (pars.size() == 3) 
      { Expression lowind = (Expression) pars.get(1); 
        Expression highind = (Expression) pars.get(2);
        Expression elem = (Expression) pars.get(0);
            
        Vector pars1 = new Vector(); 
        pars1.add(unitExpression); 
        pars1.add(lowind); 

        Expression subrange1 = 
          BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars1); 

        Vector pars2 = new Vector(); 
        pars2.add(new BinaryExpression("+",
                     lowind,unitExpression)); 
        pars2.add(highind); 

        Expression subrange2 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars2); 
 
        subrange2 = 
           new BinaryExpression("->collect", subrange2, elem); 
        subrange2.setBrackets(true); 

        Vector pars3 = new Vector(); 
        pars3.add(new BinaryExpression("+",
                            highind,unitExpression)); 
        pars3.add(
           new UnaryExpression("->size",obj)); 

        Expression subrange3 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars3); 

        Expression cat1 = 
              new BinaryExpression("^", subrange2, subrange3); 
        Expression expr = 
              new BinaryExpression("^", subrange1, cat1); 
        expr.setType(new Type("Sequence", null)); 
        Vector cmds = new Vector(); 
        cmds.add(
           new AssignStatement(obj,expr));   
        return cmds; 
      }  
    } 

    if ("copyWithin".equals(feature) && 
        obj.isSequence() && 
        pars.size() >= 2)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par3 = new UnaryExpression("->size", obj); 
      if (pars.size() >= 3) 
      { par3 = (Expression) pars.get(2); } 
      
      // obj.subrange(1,par1) ^ obj.subrange(par2+1,par3) ^
      // obj.subrange(par1+1+par3-par2,obj.size)

      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Expression par2x = 
        new BinaryExpression("+", par2, unitExpression);
      Expression par3x = 
        new BinaryExpression("+", par1x, 
          new BinaryExpression("-", par3, par2)); 
  
      Vector pars1 = new Vector(); 
      pars1.add(unitExpression); 
      pars1.add(par1); 
      Expression res1 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars1);
      res1.setType(obj.getType()); 
      res1.setElementType(obj.getElementType());

      Vector pars2 = new Vector(); 
      pars2.add(par2x); 
      pars2.add(par3); 
      Expression res2 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars2);
      res2.setType(obj.getType()); 
      res2.setElementType(obj.getElementType());

      Vector pars3 = new Vector(); 
      pars3.add(par3x); 
      pars3.add(new UnaryExpression("->size", obj)); 
      Expression res3 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars3);
      res3.setType(obj.getType()); 
      res3.setElementType(obj.getElementType());

      Expression res = 
        new BinaryExpression("^", res1, 
                new BinaryExpression("^", res2, res3)); 
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      Vector cmds = new Vector(); 
      cmds.add(new AssignStatement(obj, res)); 
      return cmds; 
    } 


    if (("setInt8".equals(feature) ||
         "setUint8".equals(feature) ||
         "setInt16".equals(feature) ||
         "setUint16".equals(feature) || 
         "setInt32".equals(feature) ||
         "setUint32".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 1)
    { Expression p0 = (Expression) pars.get(0); 
      Expression p1 = (Expression) pars.get(1); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("int", null));   
      AssignStatement asgn = 
        new AssignStatement(res,p1); 
      Vector cmds = new Vector(); 
      cmds.add(asgn);    
      return cmds;  
    } 

    if (("setFloat32".equals(feature) ||
         "setFloat64".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 1)
    { Expression p0 = (Expression) pars.get(0); 
      Expression p1 = (Expression) pars.get(1); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("double", null));   
      AssignStatement asgn = 
        new AssignStatement(res,p1); 
      Vector cmds = new Vector(); 
      cmds.add(asgn);    
      return cmds; 
    } 

    if (("setBigInt64".equals(feature) ||
         "setBigUint64".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 1)
    { Expression p0 = (Expression) pars.get(0); 
      Expression p1 = (Expression) pars.get(1); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("long", null));   
      AssignStatement asgn = 
        new AssignStatement(res,p1); 
      Vector cmds = new Vector(); 
      cmds.add(asgn);    
      return cmds; 
    } 


    if ("push".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { SetExpression extsn = 
        new SetExpression(pars,true); 
      Expression rhs = 
        new BinaryExpression("^", obj, extsn);
      rhs.setType(obj.getType()); 
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj := obj^Sequence{pars}

    if ("unshift".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { SetExpression extsn = 
        new SetExpression(pars,true); 
      Expression rhs = 
        new BinaryExpression("^", extsn, obj);
      rhs.setType(obj.getType()); 
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;   
    } // side effect is  obj := parsx^obj

    if ("pop".equals(feature) && 
        // obj.isSequence() && 
        pars.size() == 0)
    { Expression rhs = 
        new UnaryExpression("->front", obj);
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;   
    } // Side-effect obj := obj->front()

    if ("shift".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression rhs = 
        new UnaryExpression("->tail", obj);
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;
    } // Side-effect obj := obj->tail()

    if ("reverse".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression rhs = 
        new UnaryExpression("->reverse", obj);
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds; 
    } 

    if ("sort".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression rhs = 
        new UnaryExpression("->sort", obj);
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;
    } 

    if ("sort".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      // Expression rhs = 
      //  new BinaryExpression("->sortedWith", obj, par1);
      Vector spars = new Vector(); 
      spars.add(obj); 
      spars.add(par1); 
      Expression rhs = 
        BasicExpression.newStaticCallBasicExpression("sortWith", 
          "OclComparable", spars); 
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;
    } 

    if ("splice".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Expression par2x = 
        new BinaryExpression("+", par1x, par2);  
      Vector rempars = new Vector(); 
      rempars.addAll(pars); 
      rempars.remove(0); 
      rempars.remove(0); 
      SetExpression inserted = 
        new SetExpression(rempars,true); 
      inserted.setType(obj.getType()); 
      inserted.setElementType(obj.getElementType());

      Vector pars1x = new Vector(); 
      pars1x.add(unitExpression); 
      pars1x.add(par1);
      Expression subrange1 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars1x);
      
      Vector pars2x = new Vector(); 
      pars2x.add(par2x); 
      pars2x.add(new UnaryExpression("->size", obj));
      
      Expression subrange2 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars2x);
      Expression res = 
        new BinaryExpression("^", subrange1, inserted); 
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      Expression rhs = 
        new BinaryExpression("^", res, subrange2); 
      rhs.setType(obj.getType()); 
      rhs.setElementType(obj.getElementType());
      AssignStatement assgn = 
        new AssignStatement(obj, rhs); 
      Vector cmds = new Vector(); 
      cmds.add(assgn); 
      return cmds; 
    } 

    if ("set".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { // obj := par1 ^ obj.subrange(par1.size+1,obj.size)

      Expression par1 = (Expression) pars.get(0);
      Expression par1size = 
         new UnaryExpression("->size", par1);  
      Expression par1sizex = 
        new BinaryExpression("+", par1size, unitExpression);  
      Expression par2x = 
        new UnaryExpression("->size", obj);  
      Vector rempars = new Vector(); 
      rempars.add(par1sizex); 
      rempars.add(par2x); 

      Expression tailobj = 
        BasicExpression.newFunctionBasicExpression("subrange", 
                           obj, rempars); 

      Expression inserted = 
        new BinaryExpression("^", par1, tailobj); 
      inserted.setType(obj.getType()); 
      inserted.setElementType(obj.getElementType());

      AssignStatement assgn = 
        new AssignStatement(obj, inserted); 
      Vector cmds = new Vector(); 
      cmds.add(assgn); 
      return cmds; 
    } 

    if ("set".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 2)
    { // obj := obj.subrange(1,par2) ^ par1 ^ 
      //        obj.subrange(par1.size+par2+1,obj.size)

      Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);

      Vector parsx1 = new Vector(); 
      parsx1.add(unitExpression); 
      parsx1.add(par2); 
      Expression frontobj = 
        BasicExpression.newFunctionBasicExpression("subrange", 
                           obj, parsx1); 

      Expression par1size = 
         new UnaryExpression("->size", par1);  
      Expression par1sizex = 
        new BinaryExpression("+", par1size, unitExpression);  
      Expression par2x = 
        new UnaryExpression("->size", obj);  

      Vector rempars = new Vector(); 
      rempars.add(new BinaryExpression("+", par1sizex, par2)); 
      rempars.add(par2x); 

      Expression tailobj = 
        BasicExpression.newFunctionBasicExpression("subrange", 
                           obj, rempars); 

      Expression inserted = 
        new BinaryExpression("^", frontobj, 
          new BinaryExpression("^", par1, tailobj)); 
      inserted.setType(obj.getType()); 
      inserted.setElementType(obj.getElementType());

      AssignStatement assgn = 
        new AssignStatement(obj, inserted); 
      Vector cmds = new Vector(); 
      cmds.add(assgn); 
      return cmds; 
    } 

    if ("forEach".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Argument is an anonymous function
      Expression par = (Expression) pars.get(0);
      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 
      if (pars.size() > 1) 
      { targ = (Expression) pars.get(1); } 

      // lambda e : T in f->apply(e)
      if ((par instanceof UnaryExpression) && 
          ((UnaryExpression) par).isLambdaExpression())
      { UnaryExpression lam = (UnaryExpression) par; 
        Attribute e = lam.getAccumulator(); 
        Expression call = lam.getArgument(); 
        Expression v = new BasicExpression(e); 
        Vector bodypars = new Vector(); 
        bodypars.add(v); 
        Statement invoc = 
          InvocationStatement.newInvocationStatement(
                                           call,bodypars); 
        WhileStatement ws = new WhileStatement(v,obj,invoc); 
        Vector cmds = new Vector(); 
        cmds.add(ws); 
        return cmds; 
      } 
      else // function name
      { String vv = Identifier.nextIdentifier("_var"); 
        BasicExpression pf = 
          BasicExpression.newVariableBasicExpression(vv);
        pf.setType(obj.getElementType());  
        Expression call = 
          new BinaryExpression("->apply", par, pf);
        if (par instanceof BasicExpression)
        { ((BasicExpression) par).addParameter(pf); 
          ((BasicExpression) par).setObjectRef(targ); 
          call = par; 
        }  
        Vector bodypars = new Vector(); 
        bodypars.add(pf); 
        Statement invoc = 
          InvocationStatement.newInvocationStatement(
                                           call,bodypars); 
        WhileStatement ws = new WhileStatement(pf,obj,invoc); 
        Vector cmds = new Vector(); 
        cmds.add(ws); 
        return cmds; 
      } 
    } 

    if ("set".equals(feature) && 
        obj.isMap() && 
        pars.size() > 1)
    { Expression indx = (Expression) pars.get(0); 
      Expression val = (Expression) pars.get(1); 

      Expression extsn = 
        BasicExpression.newIndexedBasicExpression(obj,indx);
      extsn.setType(obj.getElementType()); 
 
      AssignStatement stat = 
        new AssignStatement(extsn,val); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj[indx] := val

    if ("delete".equals(feature) && 
        obj.isMap() && 
        pars.size() > 0)
    { Expression indx = (Expression) pars.get(0); 
      SetExpression indexset = new SetExpression(); 
      indexset.addElement(indx); 
      Expression restriction = 
        new BinaryExpression("->antirestrict",       
                             obj, indexset);
      restriction.setType(obj.getType()); 
      restriction.setElementType(obj.getElementType()); 
 
      AssignStatement stat = 
        new AssignStatement(obj,restriction); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj := obj->antirestrict(Set{indx})

    if ("clear".equals(feature) && 
        obj.isMap() && 
        pars.size() == 0)
    { SetExpression restriction = new SetExpression();
      
      restriction.setType(obj.getType()); 
      restriction.setElementType(obj.getElementType()); 
 
      AssignStatement stat = 
        new AssignStatement(obj,restriction); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj := Map{}

    if ("add".equals(feature) && 
        obj.isSet() && 
        pars.size() > 0)
    { Expression val = (Expression) pars.get(0); 

      Expression rhs = 
        new BinaryExpression("->including", obj, val); 
      rhs.setType(obj.getType()); 
      rhs.setElementType(obj.getElementType()); 

      AssignStatement stat = 
        new AssignStatement(obj,rhs); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj := obj->including(val)

    if ("delete".equals(feature) && 
        obj.isSet() && 
        pars.size() > 0)
    { Expression indx = (Expression) pars.get(0); 
      Expression restriction = 
        new BinaryExpression("->excluding",       
                             obj, indx);
      restriction.setType(obj.getType()); 
      restriction.setElementType(obj.getElementType()); 
 
      AssignStatement stat = 
        new AssignStatement(obj,restriction); 
      Vector cmds = new Vector(); 
      cmds.add(stat); 
      return cmds;  
    } // obj := obj->excluding(indx)

    // else, it is an operation call. 

    BasicExpression call = 
      BasicExpression.newCallBasicExpression(
                             feature,obj,pars); 
    InvocationStatement cmd = 
      InvocationStatement.newInvocationStatement(
                               call,pars); 
    Vector cmds = new Vector(); 
    cmds.add(cmd); 
    return cmds;  
  } 

  public Expression jsfeatureAccess(Expression obj, 
                      String feature,
                      java.util.Map vartypes, 
                      java.util.Map varelemtypes, 
                      Vector types, Vector entities)
  { System.out.println(">> jsfeatureAccess for " + tag + " with " + terms.size() + " terms " + obj + "." + feature); 
    System.out.println(); 

    if ("Number".equals(obj + "") && 
        "MAX_VALUE".equals(feature))
    { Expression expr = 
        new BasicExpression(1.7976931348623157E308); 
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "MIN_VALUE".equals(feature))
    { Expression expr = 
        new BasicExpression(5E-324);
      return expr;  
    } 

    if ("Number".equals(obj + "") && 
        "NaN".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                           "Math_NaN");
      expr.setType(new Type("double", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "EPSILON".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        new BasicExpression(
              2.220446049250313E-16);
      expr.setType(new Type("double", null));  
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "POSITIVE_INFINITY".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                     "Math_PINFINITY");
      expr.setType(new Type("double", null));  
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "NEGATIVE_INFINITY".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                     "Math_NINFINITY");
      expr.setType(new Type("double", null));  
      return expr; 
    } 

    if ("Number".equals(obj + "") && 
        "MIN_SAFE_INTEGER".equals(feature))
    { // ASTTerm.setType(this, "long"); 
      Expression expr = 
        new BasicExpression(
              -9007199254740991L);
      expr.setType(new Type("long", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "MAX_SAFE_INTEGER".equals(feature))
    { // ASTTerm.setType(this, "long"); 
      Expression expr = 
        new BasicExpression(
              9007199254740991L);
      expr.setType(new Type("long", null));  
      return expr; 
    }

    if ("Math".equals(obj + "") || "MathLib".equals(obj + ""))
    { if ("PI".equals(feature))
      { Expression res = 
          new BasicExpression(3.1415926535897); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("LN10".equals(feature))
      { Expression res = 
          new UnaryExpression("->log", 
                              new BasicExpression(10)); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("LN2".equals(feature))
      { Expression res = 
          new UnaryExpression("->log", 
                              new BasicExpression(2)); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("LOG10E".equals(feature))
      { Expression res = 
          new UnaryExpression("->log10", 
                              new UnaryExpression("->exp",
                                new BasicExpression(1))); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("SQRT1_2".equals(feature))
      { Expression res = 
          new UnaryExpression("->sqrt", 
                              new BasicExpression(0.5)); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("SQRT2".equals(feature))
      { Expression res = 
          new UnaryExpression("->sqrt", 
                              new BasicExpression(2)); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

    } 

    if ("lastIndex".equals(feature) && 
        obj.getType() != null && 
        "OclRegex".equals(obj.getType().getName()))
    { // reg.lastIndex  is  reg.endpos
      Expression res = 
        BasicExpression.newAttributeBasicExpression(
           "endpos", obj);
      
      res.setType(new Type("int", null)); 
      res.setElementType(new Type("int", null));  
      return res; 
    } 

    if (obj.isSequence() && "buffer".equals(feature))
    { return obj; } 

    if (obj.isMap() && "size".equals(feature))
    { Expression res = 
        new UnaryExpression("->size", obj); 
      res.setType(new Type("int", null)); 
      return res; 
    } 

    if (obj.isSet() && "size".equals(feature))
    { Expression res = 
        new UnaryExpression("->size", obj); 
      res.setType(new Type("int", null)); 
      return res; 
    } 

    if (obj.isObject()) 
    { Type etype = obj.getType(); 
      if (etype != null && etype.getEntity() != null) 
      { Entity ee = etype.getEntity(); 
        if (ee.hasOperation(feature))
        { BasicExpression opexpr = 
            BasicExpression.newCallBasicExpression(
                             feature + "", obj); 
          return opexpr; 
        } 
      } 
    } // getter

    BasicExpression classexpr = 
          BasicExpression.newAttributeBasicExpression(
                            feature + "",obj); 
    return classexpr;
  }

  public boolean isGeneratorFunction(Expression opexpr,
                      java.util.Map vartypes,
                      java.util.Map varelemtypes,
                      Vector types, Vector entities)
  { String opname = opexpr + ""; 
    
    System.out.println(">>> Testing if " + opexpr + " is a generator function"); 
 
    
    for (int i = 0; i < entities.size(); i++) 
    { Entity ee = (Entity) entities.get(i);

      System.out.println(">> Entity " + ee + " Operations: " + ee.getOperations()); 
 
      if (ee.hasOperation(opname))
      { BehaviouralFeature bf = ee.getOperation(opname); 
        if (bf.isGenerator())
        { return true; }
      }  
    } 

    return false; 
  } 

  public boolean isJSMathFunction(String feature)
  { return "sin".equals(feature) || "cos".equals(feature) || 
           "tan".equals(feature)|| "asin".equals(feature) ||
           "acos".equals(feature) || "exp".equals(feature) ||
           "log10".equals(feature) ||
           "random".equals(feature) || 
           "abs".equals(feature) || 
           "fround".equals(feature) ||
           "trunc".equals(feature) || 
           "sign".equals(feature) ||
           "log2".equals(feature) ||
           "atan".equals(feature) || "sinh".equals(feature) ||
           "cosh".equals(feature) || "tanh".equals(feature) ||
           "sqrt".equals(feature) || "cbrt".equals(feature) ||
           "asinh".equals(feature) || 
           "acosh".equals(feature) || 
           "atanh".equals(feature) ||
           "floor".equals(feature) ||
           "ceil".equals(feature) || 
           "round".equals(feature) ||
           "pow".equals(feature) ||
           "hypot".equals(feature) ||  
           "min".equals(feature) || "max".equals(feature); 
  } 

  
  public Expression jsMathFunctionExpression(String feature, Vector pars)
  { if ("PI".equals(feature))
    { Expression res = 
        BasicExpression.newStaticCallBasicExpression(
               "piValue", "MathLib", new Vector()); 
      res.setType(new Type("double", null)); 
      return res; 
    } 

    if ("random".equals(feature))
    { Expression res = 
          BasicExpression.newStaticCallBasicExpression(
               "random", "MathLib", new Vector()); 
      res.setType(new Type("double", null)); 
      return res; 
    } 

    if ("abs".equals(feature) && pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      par1.setBrackets(true); 
      Expression res = 
          new UnaryExpression("->abs", par1);
        res.setType(par1.getType()); 
        return res; 
      }  

      if ("fround".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression res = 
          new UnaryExpression("->round", par1);
        Expression resx = 
          new BinaryExpression(
                "->oclAsType", res, doubleTypeExpression);  
        resx.setType(new Type("double", null)); 
        return resx; 
      }  

      if ("trunc".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression resx = 
          new BinaryExpression(
                "->oclAsType", par1, intTypeExpression);  
        resx.setType(new Type("int", null)); 
        return resx; 
      }  

      if ("sign".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0);
        Expression lZero = 
          new BinaryExpression("<", par1, zeroExpression); 
        Expression gZero = 
          new BinaryExpression(">", par1, zeroExpression); 

        Expression condNeg = 
          new ConditionalExpression(lZero, minusOneExpr,
                                    zeroExpression);  
        condNeg.setType(new Type("int", null)); 
        Expression res = 
          new ConditionalExpression(gZero, unitExpression,
                                    condNeg);
        res.setType(new Type("int", null)); 
        return res; 
      }  

      
      if ("log2".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0);
        par1.setBrackets(true); 
        Expression logx = new UnaryExpression("->log", par1); 
        Expression log2 = new UnaryExpression("->log", 
                               new BasicExpression(2)); 

        Expression log2x = 
          new BinaryExpression("/", logx, log2);
        log2x.setBrackets(true);
        log2x.setType(new Type("double", null)); 
        return log2x; 
      }   

      if (("sin".equals(feature) || "cos".equals(feature) ||
           "tan".equals(feature) || "asin".equals(feature) ||
           "acos".equals(feature) || "exp".equals(feature) ||
           "log10".equals(feature) ||  
           "atan".equals(feature) || "sinh".equals(feature) ||
           "cosh".equals(feature) || "tanh".equals(feature) ||
           "sqrt".equals(feature) || "cbrt".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression res = 
          new UnaryExpression("->" + feature, par1);
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("asinh".equals(feature) || 
           "acosh".equals(feature) || "atanh".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        Expression res = 
          BasicExpression.newStaticCallBasicExpression(
               feature, "MathLib", par1); 
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("floor".equals(feature) ||
           "ceil".equals(feature) || "round".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true);  
        Expression res = 
          new UnaryExpression("->" + feature, par1);
        res.setType(new Type("int", null)); 
        return res; 
      }  

      if ("pow".equals(feature) && pars.size() == 2)
      { Expression par1 = (Expression) pars.get(0); 
        Expression par2 = (Expression) pars.get(1);
        par1.setBrackets(true);  
        Expression res = 
          new BinaryExpression("->pow", par1, par2);
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("min".equals(feature) || "max".equals(feature)) 
          && pars.size() >= 2)
      { Expression res = 
          new SetExpression(pars);
        Expression resx = 
          new UnaryExpression("->" + feature, res); 
        resx.setType(res.getElementType()); 
        return resx; 
      }

      if ("hypot".equals(feature) && pars.size() >= 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression sqr1 =
          new UnaryExpression("->sqr", par1); 
        Expression res = sqr1; 
        for (int i = 1; i < pars.size(); i++) 
        { Expression pari = (Expression) pars.get(i);
          pari.setBrackets(true); 
          Expression sqri =
            new UnaryExpression("->sqr", pari);
          res = new BinaryExpression("+", res, sqri); 
        }  
        
        res.setBrackets(true);  
        res.setType(new Type("double", null)); 
        Expression resx = 
          new UnaryExpression("->sqrt", res);
        resx.setType(new Type("double", null)); 
        return resx; 
      }  
    
    Expression defaultResult = 
      BasicExpression.newCallBasicExpression(feature,pars); 
    return defaultResult;    
  }

  public Expression jsfeatureAccess(Expression obj, 
                      String feature, Vector pars,
                      java.util.Map vartypes, 
                      java.util.Map varelemtypes, 
                      Vector types, Vector entities)
  { System.out.println(">> jsfeatureAccess for " + tag + " with " + terms.size() + " terms " + obj + "." + feature + pars); 
    System.out.println(); 

    if ("Number".equals(obj + "") && 
        "MAX_VALUE".equals(feature))
    { Expression expr = 
        new BasicExpression(1.7976931348623157E308); 
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "MIN_VALUE".equals(feature))
    { Expression expr = 
        new BasicExpression(5E-324);
      return expr;  
    } 

    if ("Number".equals(obj + "") && 
        "NaN".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                           "Math_NaN");
      expr.setType(new Type("double", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "EPSILON".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        new BasicExpression(
              2.220446049250313E-16);
      expr.setType(new Type("double", null));  
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "POSITIVE_INFINITY".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                     "Math_PINFINITY");
      expr.setType(new Type("double", null));  
      return expr; 
    }
 
    if ("Number".equals(obj + "") && 
        "NEGATIVE_INFINITY".equals(feature))
    { // ASTTerm.setType(this, "double"); 
      Expression expr = 
        BasicExpression.newValueBasicExpression(
                                     "Math_NINFINITY");
      expr.setType(new Type("double", null));  
      return expr; 
    } 

    if ("Number".equals(obj + "") && 
        "MIN_SAFE_INTEGER".equals(feature))
    { // ASTTerm.setType(this, "long"); 
      Expression expr = 
        new BasicExpression(
              -9007199254740991L);
      expr.setType(new Type("long", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "MAX_SAFE_INTEGER".equals(feature))
    { // ASTTerm.setType(this, "long"); 
      Expression expr = 
        new BasicExpression(
              9007199254740991L);
      expr.setType(new Type("long", null));  
      return expr; 
    }

    if ("lastIndex".equals(feature) && 
        obj.getType() != null && 
        "OclRegex".equals(obj.getType().getName()))
    { // reg.lastIndex  is  reg.endpos
      Expression res = 
        BasicExpression.newAttributeBasicExpression(
           "endpos", obj);
      
      res.setType(new Type("int", null)); 
      res.setElementType(new Type("int", null));  
      return res; 
    } 

    if ("Object".equals(obj + "") && 
        "create".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0);
      if ("null".equals(par1 + ""))  
      { Expression eres = 
          new SetExpression(); 
        eres.setType(new Type("Map", null)); 
        return eres; 
      } 
      par1.setBrackets(true);
      Expression expr = 
        new UnaryExpression("->copy", par1);  
      expr.setType(par1.getType());  
      return expr; 
    }

    if ("Object".equals(obj + "") && 
        "assign".equals(feature) && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      if ("null".equals(par1 + ""))  
      { return par2; } 
      if ("null".equals(par2 + ""))  
      { return par1; } 
      par1.setBrackets(true);
      Expression expr = 
        new BinaryExpression("->union", par1, par2);  
      expr.setType(par1.getType());  
      expr.setElementType(par1.getElementType()); 
      return expr; 
    }  // map union; par1 := par1->union(par2)

    if ("Object".equals(obj + "") && 
        "defineProperty".equals(feature) && 
        pars.size() == 3)
    { Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      Expression par3 = (Expression) pars.get(2);

      par1.setBrackets(true);

      SetExpression newfeat = new SetExpression(); 
      newfeat.setType(new Type("Map", null)); 
      newfeat.setElementType(new Type("OclAny", null)); 
      newfeat.addElement(
        new BinaryExpression("|->", par2, 
           new BinaryExpression("->at", par3, 
              BasicExpression.newValueBasicExpression(
                                      "\"value\"")))); 

      Expression expr = 
          new BinaryExpression("->union", par1, newfeat);  
      expr.setType(par1.getType());  
      expr.setElementType(par1.getElementType()); 
      return expr; 
    }  // map union; par1 := par1->union(Map{par2 |-> par3->at("value")})

    if ("Number".equals(obj + "") && 
        "isFinite".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0);
      par1.setBrackets(true);  
      Expression exprNaN = 
        new UnaryExpression("->oclIsInvalid", par1);  
      Expression isvalid = 
        new UnaryExpression("not", exprNaN); 
      Expression exprNInf = 
        BasicExpression.newValueBasicExpression(
                                     "Math_NINFINITY");
      Expression exprPInf = 
        BasicExpression.newValueBasicExpression(
                                     "Math_PINFINITY");
      Expression neq1 = new BinaryExpression("/=", par1,
                                             exprNInf); 

      Expression neq2 = new BinaryExpression("/=", par1,
                                             exprPInf); 

      Expression expr1 = 
        new BinaryExpression("&", neq1, neq2);
      Expression expr = 
        new BinaryExpression("&", expr1, isvalid);
      expr.setBrackets(true); 
      expr.setType(new Type("boolean", null));  
      return expr; 
    }

    if ("Object".equals(obj + "") && 
        "defineProperties".equals(feature) && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0);
      Expression par2 = (Expression) pars.get(1);
      
      par1.setBrackets(true);
      par2.setBrackets(true); 

      Type maptype = new Type("Map", null); 
      maptype.setKeyType(new Type("String", null));
      maptype.setElementType(new Type("OclAny", null));

      par2.setElementType(maptype); 

      BasicExpression varx = 
        BasicExpression.newVariableBasicExpression("_x"); 
      varx.setType(new Type("Map", null)); 
      varx.setElementType(new Type("OclAny", null)); 

      Expression valexpr = 
               BasicExpression.newValueBasicExpression(
                                      "\"value\""); 
      Expression par2dom = 
        new BinaryExpression(":", varx, par2); 
      Expression collrng =        
           new BinaryExpression("->at", 
                                varx, valexpr);
      collrng.setType(new Type("OclAny", null)); 
      collrng.setElementType(new Type("OclAny", null)); 

      Expression testexpr = 
        new BinaryExpression("->includes", 
          new UnaryExpression("->keys", varx),valexpr); 
      testexpr.setType(new Type("boolean", null)); 
 
      Expression condexpr = 
        new ConditionalExpression(testexpr,
                                  collrng,nullExpression); 
      condexpr.setType(new Type("OclAny", null)); 

      BinaryExpression mapcollect = 
        new BinaryExpression("|C", par2dom, condexpr); 
      mapcollect.setType(maptype);  
      mapcollect.setElementType(new Type("OclAny", null)); 

      BinaryExpression expr = 
        new BinaryExpression("->union", par1, mapcollect); 
  
      expr.setType(maptype);  
      expr.setElementType(new Type("OclAny", null)); 
      return expr; 
    }

    if ("entries".equals(feature) && 
        "Object".equals(obj + "") && 
        pars.size() == 1)
    { 
      // par1->keys()->collect( _k | 
      //                       Sequence{ _k, par1->at(_k)})
      Expression par1 = (Expression) pars.get(0); 

      BasicExpression indx = 
        BasicExpression.newVariableBasicExpression("_k"); 
      Expression dmnset = 
        new UnaryExpression("->keys", par1); 
      Expression dmn = new BinaryExpression(":", indx, dmnset); 
      SetExpression rng = new SetExpression(true); 
      rng.addElement(indx); 
      rng.addElement(new BinaryExpression("->at", par1, indx));  
            
      Expression objentries = 
        new BinaryExpression("|C", dmn, rng); 
      objentries.setType(new Type("Sequence", null)); 
      objentries.setElementType(
                         new Type("Sequence", null)); 
      return objentries; 
    } // But actually the sequence of pairs (i,par1[i])

    if ("freeze".equals(feature) && 
        "Object".equals(obj + "") && 
        pars.size() == 1)
    { 
      Expression par1 = (Expression) pars.get(0); 
      return par1; 
    } 

    if ("fromEntries".equals(feature) && 
        "Object".equals(obj + "") && 
        pars.size() == 1)
    { // if pars1 is a sequence: 
      // par1->collect( _k | _k->at(1) |-> _k->at(2))
      Expression par1 = (Expression) pars.get(0); 

      if (par1.isMap())
      { return par1; } 

      // if (par1.isSequence())
      Type maptype = new Type("Map", null); 
      maptype.setKeyType(new Type("String", null)); 
      maptype.setElementType(
                         new Type("OclAny", null));
 
      BasicExpression indx = 
          BasicExpression.newVariableBasicExpression(
                                                 "_x"); 
      indx.setType(par1.getElementType()); 
            
      BasicExpression acc = 
        BasicExpression.newVariableBasicExpression(
                                                   "_acc"); 
      acc.setType(maptype); 
      acc.setElementType(
                         new Type("OclAny", null));
      Attribute accatt = 
                new Attribute("_acc", maptype, 
                              ModelElement.INTERNAL); 
      accatt.setElementType(
                            new Type("OclAny", null));
      Expression k = new BinaryExpression(
                                          "->at", indx, 
                                          unitExpression);  
      Expression v = new BinaryExpression(
                                          "->at", indx, 
                                          twoExpression);  
      Expression rng = 
                new BinaryExpression("|->", k, v); 
      SetExpression sexpr = 
                new SetExpression(); 
      sexpr.setType(maptype); 
      sexpr.addElement(rng); 
      BinaryExpression expr = 
                new BinaryExpression("->union", acc, sexpr); 
      expr.setType(maptype); 
              
      BinaryExpression objentries = 
                new BinaryExpression("->iterate", par1, expr); 
      objentries.setVariable("_x"); 
      objentries.setAccumulator(accatt);
      objentries.setType(maptype); 
      objentries.setElementType(
                         new Type("OclAny", null)); 
      return objentries; 
    } 

    if (("getOwnPropertyNames".equals(feature) || 
         "keys".equals(feature)) && 
        "Object".equals(obj + "") && 
        pars.size() == 1)
    { // par1->keys()
      Expression par1 = (Expression) pars.get(0); 

      Expression objentries = 
        new UnaryExpression("->keys", par1); 
      objentries.setType(new Type("Set", null)); 
      objentries.setElementType(
                         new Type("String", null)); 
      return objentries; 
    } 

    if (("hasOwn".equals(feature) || 
         "hasOwnProperty".equals(feature)) && 
        "Object".equals(obj + "") && 
        pars.size() == 2)
    { // par1->keys()->includes(par2)
      Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1); 

      Expression objentries = 
        new UnaryExpression("->keys", par1); 
      objentries.setType(new Type("Set", null)); 
      objentries.setElementType(
                         new Type("String", null));
      Expression expr = 
        new BinaryExpression("->includes", objentries, par2); 
      expr.setType(new Type("boolean", null));  
      return expr; 
    } 

    if ("is".equals(feature) && 
        "Object".equals(obj + "") && 
        pars.size() == 2)
    { // (par1 = par2)
      Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1); 

      par1.setBrackets(true); 
      par2.setBrackets(true); 
      Expression expr = 
        new BinaryExpression("=", par1, par2); 
      expr.setType(new Type("boolean", null)); 
      expr.setBrackets(true);  
      return expr; 
    } 

    if ("values".equals(feature) && 
        "Object".equals(obj + "") && 
        pars.size() == 1)
    { // par1->values()
      Expression par1 = (Expression) pars.get(0); 

      Expression objentries = 
        new UnaryExpression("->values", par1); 
      objentries.setType(new Type("Set", null)); 
      objentries.setElementType(
                         new Type("OclAny", null)); 
      return objentries; 
    } // or with duplicates included? 

    if ("Number".equals(obj + "") && 
        "isInteger".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression convPar1 = 
        new BinaryExpression("->oclAsType", par1, 
                             intTypeExpression);  
      Expression expr = new BinaryExpression("=", par1,
                                             convPar1);
      expr.setBrackets(true);  
      expr.setType(new Type("boolean", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "isNaN".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new UnaryExpression("->oclIsInvalid", par1);  
      expr.setType(new Type("boolean", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "isSafeInteger".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr1 = 
        new BinaryExpression("<=", par1, 
               new BasicExpression(9007199254740991L)); 
      Expression expr2 = 
        new BinaryExpression(">=", par1, 
               new BasicExpression(-9007199254740991L)); 
      Expression expr = 
        new BinaryExpression("&", expr1, expr2);
       
      expr.setType(new Type("boolean", null));  
      return expr; 
    } 

    if ("Number".equals(obj + "") && 
        "parseFloat".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0);
      par1.setBrackets(true);  
      Expression expr = 
        new UnaryExpression("->toReal", par1);  
      expr.setType(new Type("double", null));  
      return expr; 
    }

    if ("Number".equals(obj + "") && 
        "parseInt".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0);
      par1.setBrackets(true);  
      Expression expr = 
        new UnaryExpression("->toInteger", par1);  
      expr.setType(new Type("int", null));  
      return expr; 
    }

    if ("Math".equals(obj + "") || "MathLib".equals(obj + ""))
    { // jsMathFunctionExpression

      if ("PI".equals(feature))
      { Expression res = 
          BasicExpression.newStaticCallBasicExpression(
               "piValue", "MathLib", new Vector()); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("random".equals(feature))
      { Expression res = 
          BasicExpression.newStaticCallBasicExpression(
               "random", "MathLib", new Vector()); 
        res.setType(new Type("double", null)); 
        return res; 
      } 

      if ("abs".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression res = 
          new UnaryExpression("->abs", par1);
        res.setType(par1.getType()); 
        return res; 
      }  

      if ("fround".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression res = 
          new UnaryExpression("->round", par1);
        Expression resx = 
          new BinaryExpression(
                "->oclAsType", res, doubleTypeExpression);  
        resx.setType(new Type("double", null)); 
        return resx; 
      }  

      if ("trunc".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression resx = 
          new BinaryExpression(
                "->oclAsType", par1, intTypeExpression);  
        resx.setType(new Type("int", null)); 
        return resx; 
      }  

      if ("sign".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0);
        Expression lZero = 
          new BinaryExpression("<", par1, zeroExpression); 
        Expression gZero = 
          new BinaryExpression(">", par1, zeroExpression); 

        Expression condNeg = 
          new ConditionalExpression(lZero, minusOneExpr,
                                    zeroExpression);  
        condNeg.setType(new Type("int", null)); 
        Expression res = 
          new ConditionalExpression(gZero, unitExpression,
                                    condNeg);
        res.setType(new Type("int", null)); 
        return res; 
      }  

      
      if ("log2".equals(feature) && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0);
        par1.setBrackets(true); 
        Expression logx = new UnaryExpression("->log", par1); 
        Expression log2 = new UnaryExpression("->log", 
                               new BasicExpression(2)); 

        Expression log2x = 
          new BinaryExpression("/", logx, log2);
        log2x.setBrackets(true);
        log2x.setType(new Type("double", null)); 
        return log2x; 
      }   

      if (("sin".equals(feature) || "cos".equals(feature) ||
           "tan".equals(feature) || "asin".equals(feature) ||
           "acos".equals(feature) || "exp".equals(feature) ||
           "log10".equals(feature) ||  
           "atan".equals(feature) || "sinh".equals(feature) ||
           "cosh".equals(feature) || "tanh".equals(feature) ||
           "sqrt".equals(feature) || "cbrt".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression res = 
          new UnaryExpression("->" + feature, par1);
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("asinh".equals(feature) || 
           "acosh".equals(feature) || "atanh".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        Expression res = 
          BasicExpression.newStaticCallBasicExpression(
               feature, "MathLib", par1); 
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("floor".equals(feature) ||
           "ceil".equals(feature) || "round".equals(feature))
           && pars.size() == 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true);  
        Expression res = 
          new UnaryExpression("->" + feature, par1);
        res.setType(new Type("int", null)); 
        return res; 
      }  

      if ("pow".equals(feature) && pars.size() == 2)
      { Expression par1 = (Expression) pars.get(0); 
        Expression par2 = (Expression) pars.get(1);
        par1.setBrackets(true);  
        Expression res = 
          new BinaryExpression("->pow", par1, par2);
        res.setType(new Type("double", null)); 
        return res; 
      }  

      if (("min".equals(feature) || "max".equals(feature)) 
          && pars.size() >= 2)
      { Expression res = 
          new SetExpression(pars);
        Expression resx = 
          new UnaryExpression("->" + feature, res); 
        resx.setType(res.getElementType()); 
        return resx; 
      }  

      if ("hypot".equals(feature) && pars.size() >= 1)
      { Expression par1 = (Expression) pars.get(0); 
        par1.setBrackets(true); 
        Expression sqr1 =
          new UnaryExpression("->sqr", par1); 
        Expression res = sqr1; 
        for (int i = 1; i < pars.size(); i++) 
        { Expression pari = (Expression) pars.get(i);
          pari.setBrackets(true); 
          Expression sqri =
            new UnaryExpression("->sqr", pari);
          res = new BinaryExpression("+", res, sqri); 
        }  
        
        res.setBrackets(true);  
        res.setType(new Type("double", null)); 
        Expression resx = 
          new UnaryExpression("->sqrt", res);
        resx.setType(new Type("double", null)); 
        return resx; 
      }  
    } 

    if ("deref".equals(feature) && 
        obj.isRef())
    { Expression resx = 
          new UnaryExpression("!", obj);
      resx.setType(obj.getElementType()); 
      return resx; 
    } 

    if ("apply".equals(feature + "") && 
        pars.size() >= 1 && 
        obj instanceof BasicExpression)
    { // 2 parameters 
      Expression targ = null; 
      Expression oppars = (Expression) pars.get(0); 
      if (pars.size() > 1)
      { targ = (Expression) pars.get(0); 
        oppars = (Expression) pars.get(1);
      } 

      String mname = ((BasicExpression) obj).getData(); 
      Expression mobj = 
         ((BasicExpression) obj).getObjectRef();

      BehaviouralFeature mm = 
        Entity.findOperation(mname, entities);
 
      if (mm != null) 
      { int n = mm.getArity(); 
        Vector actualpars = new Vector(); 
        for (int i = 0; i < n; i++) 
        { Expression actualpar = 
            new BinaryExpression("->at", oppars,
                                 new BasicExpression(i+1));
          actualpars.add(actualpar); 
        } 
  
        if ("null".equals(targ + ""))
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,mobj,actualpars); 
          res.setType(mm.getResultType());  
          return res; 
        }
        else 
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,targ,actualpars); 
          res.setType(mm.getResultType());  
          return res; 
        }
      } 
    }

    if ("call".equals(feature + "") && 
        obj instanceof BasicExpression)
    { Expression targ = null; 
      Vector oppars = new Vector(); 
      if (pars.size() > 0)
      { targ = (Expression) pars.get(0); 
        oppars.addAll(pars); 
        oppars.remove(0);
      } 

      String mname = ((BasicExpression) obj).getData(); 
      Expression mobj = 
         ((BasicExpression) obj).getObjectRef();

      BehaviouralFeature mm = 
        Entity.findOperation(mname, entities);
 
      if (mm != null) 
      { if ("null".equals(targ + ""))
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,mobj,oppars); 
          res.setType(mm.getResultType());  
          return res; 
        }
        else 
        { Expression res = 
            BasicExpression.newCallBasicExpression(
                                        mname,targ,oppars); 
          res.setType(mm.getResultType());  
          return res; 
        }
      } 
    }

    if ("getFullYear".equals(feature) && 
        obj.isOclDate())
    { Expression yr =
        BasicExpression.newQueryCallBasicExpression(
                                 "getYear",obj);
      yr.setType(new Type("int", null)); 
      return yr; 
    } 

    if ("at".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression indx = 
        new BinaryExpression("+", par1, unitExpression);  
      BinaryExpression indof = 
        new BinaryExpression("->at", obj, indx); 
      indof.setType(obj.getElementType()); 
      Expression endindx = 
        new BinaryExpression("+", 
              new UnaryExpression("->size", obj), indof);  
      BinaryExpression indend = 
        new BinaryExpression("->at", obj, endindx); 
      indend.setType(obj.getElementType()); 
 
      BinaryExpression geq = 
        new BinaryExpression(">=", par1, zeroExpression); 
      Expression condexpr =
        new ConditionalExpression(geq, indof, indend);
      condexpr.setType(obj.getElementType()); 
      return condexpr;  
    } // if par1 < 0 then obj->at(obj.size+1+par1) else 
      //   obj->at(par1+1) 

    if ("find".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      String var = 
        Identifier.nextIdentifier("_var_"); 
      Expression varexpr = 
        BasicExpression.newVariableBasicExpression(var); 
      varexpr.setType(obj.getElementType()); 
      Expression findApply = 
         Expression.simplifyApply( 
                          par1, varexpr);
      BinaryExpression dmn = 
        new BinaryExpression(":", varexpr, obj); 
      Expression indof = 
        new UnaryExpression("->any", 
          new BinaryExpression("|", dmn, findApply)); 
      indof.setType(obj.getElementType()); 
      return indof;  
    } // obj->any(v | f->apply(v))

    if ("findLast".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      String var = 
        Identifier.nextIdentifier("_var_"); 
      Expression varexpr = 
        BasicExpression.newVariableBasicExpression(var); 
      varexpr.setType(obj.getElementType()); 
      Expression findApply = 
         Expression.simplifyApply( 
                          par1, varexpr);
      BinaryExpression dmn = 
        new BinaryExpression(":", varexpr, 
          new UnaryExpression("->reverse", obj)); 
      Expression indof = 
        new UnaryExpression("->any", 
          new BinaryExpression("|", dmn, findApply)); 
      indof.setType(obj.getElementType()); 
      return indof;  
    } // obj->reverse()->any(v | f->apply(v))

    if ("findIndex".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      String var = 
        Identifier.nextIdentifier("_var_"); 
      Expression varexpr = 
        BasicExpression.newVariableBasicExpression(var); 
      varexpr.setType(obj.getElementType()); 
      Expression findApply = 
         Expression.simplifyApply( 
                          par1, varexpr);
      BinaryExpression dmn = 
        new BinaryExpression(":", varexpr, obj); 
      Expression indof = 
        new UnaryExpression("->any", 
          new BinaryExpression("|", dmn, findApply)); 
      indof.setType(obj.getElementType()); 
      BinaryExpression findx = 
        new BinaryExpression("->indexOf", obj, indof); 
      BinaryExpression resx = 
        new BinaryExpression("-", findx, unitExpression); 
      resx.setType(new Type("int", null)); 
      return resx; 
    } // obj->indexOf(obj->any(v | f->apply(v))) - 1

    if ("findLastIndex".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      String var = 
        Identifier.nextIdentifier("_var_"); 
      Expression varexpr = 
        BasicExpression.newVariableBasicExpression(var); 
      varexpr.setType(obj.getElementType()); 
      Expression findApply = 
         Expression.simplifyApply( 
                          par1, varexpr);
      BinaryExpression dmn = 
        new BinaryExpression(":", varexpr, 
          new UnaryExpression("->reverse", obj)); 

      Expression indof = 
        new UnaryExpression("->any", 
          new BinaryExpression("|", dmn, findApply)); 
      indof.setType(obj.getElementType()); 
      BinaryExpression findx = 
        new BinaryExpression("->lastIndexOf", obj, indof); 
      BinaryExpression resx = 
        new BinaryExpression("-", findx, unitExpression); 
      resx.setType(new Type("int", null)); 
      return resx; 
    } // obj->lastIndexOf(obj->reverse()->any(v | f->apply(v))) - 1


    if (("Array".equals(obj + "") || 
         "Int8Array".equals(obj + "") || 
         "Int16Array".equals(obj + "") || 
         "Int32Array".equals(obj + "") || 
         "Uint8Array".equals(obj + "") || 
         "Uint8ClampedArray".equals(obj + "") || 
         "Uint16Array".equals(obj + "") || 
         "Uint32Array".equals(obj + "") || 
         "BigInt64Array".equals(obj + ""))
        && "of".equals(feature) &&
        pars.size() > 0) 
    { SetExpression arr = new SetExpression(pars,true); 
      Type seqtype = new Type("Sequence", null); 
      seqtype.setElementType(
          ((Expression) pars.get(0)).getType()); 
      arr.setType(seqtype); 
      return arr; 
    } 

    if (("Array".equals(obj + "") ||
         "Int8Array".equals(obj + "") || 
         "Int16Array".equals(obj + "") || 
         "Int32Array".equals(obj + "") || 
         "Uint8Array".equals(obj + "") || 
         "Uint8ClampedArray".equals(obj + "") || 
         "Uint16Array".equals(obj + "") || 
         "Uint32Array".equals(obj + "") || 
         "BigInt64Array".equals(obj + "")) && 
        "from".equals(feature) &&
        pars.size() == 1) 
    { Expression par1 = (Expression) pars.get(0); 
      if (par1.isString())
      { Expression res = 
          new UnaryExpression("->characters", par1); 
        Type seqstrings = new Type("Sequence", null); 
        seqstrings.setElementType(new Type("String", null)); 
        res.setType(seqstrings); 
        return res; 
      } 
      return par1; 
    } 

    if (("Array".equals(obj + "") ||
         "Int8Array".equals(obj + "") || 
         "Int16Array".equals(obj + "") || 
         "Int32Array".equals(obj + "") || 
         "BigInt64Array".equals(obj + "")) 
        && "from".equals(feature) &&
        pars.size() == 2) 
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
 
      Expression res = par1;  
        
      if (par1.isString())
      { res = 
          new UnaryExpression("->characters", par1); 
        Type seqstrings = new Type("Sequence", null); 
        seqstrings.setElementType(new Type("String", null)); 
        res.setType(seqstrings); 
      } 

      BasicExpression be = 
        BasicExpression.newVariableBasicExpression("_x"); 
      BinaryExpression dmn = 
        new BinaryExpression(":", be, res); 
      // BinaryExpression rng = 
      //   new BinaryExpression("->apply", par2, be); 
      Expression rng = 
         Expression.simplifyApply(par2, be);

      return new BinaryExpression("|C", dmn, rng); 
    } 

    if ("ArrayBuffer".equals(obj + "") && 
        "isView".equals(feature) &&
        pars.size() > 0) 
    { Expression p1 = (Expression) pars.get(0); 
      BinaryExpression arr = 
         new BinaryExpression("->oclIsTypeOf", p1, 
                              sequenceTypeExpression); 
      return arr; 
    } 

    if ("Atomics".equals(obj + ""))
    { if (("add".equals(feature) || 
           "sub".equals(feature)) &&
          pars.size() >= 3) 
      { // Atomics.sub(arr,ind,val) returns arr->at(ind+1)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        return arr; 
      }

      if (("and".equals(feature) || "or".equals(feature) ||
           "xor".equals(feature)) &&
          pars.size() >= 3) 
      { // Atomics.xor(arr,ind,val) returns arr->at(ind+1)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        return arr; 
      }

      if (("compareExchange".equals(feature) || 
           "exchange".equals(feature)) &&
          pars.size() >= 3) 
      { // Atomics.exchange(arr,ind,val) 
        // returns arr->at(ind+1)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        return arr; 
      }

      if ("load".equals(feature) &&
          pars.size() >= 2) 
      { // Atomics.load(arr,ind,val) returns arr->at(ind+1)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression)); 
        return arr; 
      }

      if ("store".equals(feature) &&
          pars.size() >= 3) 
      { // Atomics.store(arr,ind,val) returns val

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2); 
 
        return p3; 
      }

      if ("notify".equals(feature) &&
          pars.size() >= 2) 
      { // Atomics.notify(arr,ind,val) is 
        // OclProcess.notify(arr->at(ind+1)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
 
        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        Expression call = 
          BasicExpression.newStaticCallBasicExpression(
                            "notify",
                            "OclProcess", arr);  
        return call; 
      } // update form only.

      if (("wait".equals(feature) || 
           "waitAsync".equals(feature)) &&
          pars.size() == 3) 
      { // Atomics.wait(arr,ind,val) is 
        // OclProcess.wait(arr->at(ind+1) /= val,0)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2);

        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression neq = 
          new BinaryExpression("/=", arr, p3); 
        Vector argsx = new Vector(); 
        argsx.add(neq); 
        argsx.add(zeroExpression); 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression("wait",
                            "OclProcess", argsx);  
        return call; 
      } // update form only.

      if (("wait".equals(feature) || 
           "waitAsync".equals(feature)) &&
          pars.size() == 4) 
      { // Atomics.wait(arr,ind,val,t) is 
        // OclProcess.wait(arr->at(ind+1) /= val,t)

        Expression p1 = (Expression) pars.get(0); 
        Expression p2 = (Expression) pars.get(1); 
        Expression p3 = (Expression) pars.get(2);
        Expression p4 = (Expression) pars.get(3);

        BinaryExpression arr = 
          new BinaryExpression("->at", p1, 
            new BinaryExpression("+", p2, unitExpression));
        BinaryExpression neq = 
          new BinaryExpression("/=", arr, p3); 
        Vector argsx = new Vector(); 
        argsx.add(neq); 
        argsx.add(p4); 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression("wait",
                            "OclProcess", argsx);  
        return call; 
      } // update form only.


    }  

    if ("Reflect".equals(obj + ""))
    { if ("construct".equals(feature) &&
          pars.size() >= 2) 
      { // Reflect.construct(Cls,args) is
        // OclType["Cls"].newInstance()
        Expression par1 = (Expression) pars.get(0);
        Entity cent = 
          (Entity) ModelElement.lookupByName(par1 + "", 
                                             entities); 
        Expression clsent = 
          BasicExpression.newTypeBasicExpression("OclType"); 
        if (cent != null) 
        { clsent = new BasicExpression(cent); }   
        Expression cls = 
          BasicExpression.newValueBasicExpression("\"" + 
                                 par1 + "\""); 
        Expression clstyp =
          BasicExpression.newIndexedBasicExpression(
                            clsent, cls); 
        Expression res = 
          BasicExpression.newCallBasicExpression(
                     "newInstance", clstyp);
        if (cent != null) 
        { res.setType(new Type(cent)); }  
        return res;   
      } 

      if ("get".equals(feature) && 
          pars.size() >= 2) 
      { Expression par1 = (Expression) pars.get(0);
        Expression par2 = (Expression) pars.get(1);
        Vector dpars = new Vector(); 
        dpars.add(par1); 
        dpars.add(par2); 
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "getAttributeValue", "OclType", dpars); 
        // Statement sdel = 
        //        InvocationStatement.newInvocationStatement(
        //                                        dx,dpars);
        return dx; 
      } 


      if ("has".equals(feature) && 
          pars.size() >= 2) 
      { Expression par1 = (Expression) pars.get(0);
        Expression par2 = (Expression) pars.get(1);
        Vector dpars = new Vector(); 
        dpars.add(par1); 
        dpars.add(par2); 
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "hasAttribute", "OclType", dpars); 
        // Statement sdel = 
        //        InvocationStatement.newInvocationStatement(
        //                                        dx,dpars);
        dx.setType(new Type("boolean", null)); 
        return dx; 
      } 

      if ("ownKeys".equals(feature) && 
          pars.size() == 1) 
      { Expression par1 = (Expression) pars.get(0);
        // Expression par1type = 
        //   new UnaryExpression("->oclType", par1); 
        Expression dx = 
          BasicExpression.newStaticCallBasicExpression(
                "allAttributes", "OclType", par1);
        String idx = Identifier.nextIdentifier("_var"); 
        BasicExpression vv = 
          BasicExpression.newVariableBasicExpression(idx);
        vv.setType(new Type("OclAttribute", null)); 
        Expression dxdom = 
          new BinaryExpression(":", vv, dx);   
        Expression nmefld = 
          BasicExpression.newAttributeBasicExpression(
                                        "name", vv);
        nmefld.setType(new Type("String", null)); 
 
        Expression fieldnames = 
          new BinaryExpression("|C", dxdom, nmefld); 

        fieldnames.setType(new Type("Sequence", null)); 
        fieldnames.setElementType(new Type("String", null));  
        return fieldnames; 
      } 
    } 

    if ("exec".equals(feature) && 
        obj.getType() != null && 
        "OclRegex".equals(obj.getType().getName()))
    { // reg.exec(tx)  is  reg.allMatches(tx)
      Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        BasicExpression.newCallBasicExpression(
           "allMatches", obj, par1);
      
      res.setType(new Type("Sequence", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("test".equals(feature) && 
        obj.getType() != null && 
        "OclRegex".equals(obj.getType().getName()))
    { // reg.test(tx)  is  reg.findNext(tx)
      Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        BasicExpression.newCallBasicExpression(
           "findNext", obj, par1);
      
      res.setType(new Type("boolean", null)); 
      res.setElementType(new Type("boolean", null));  
      return res; 
    } 
      
    if ("toString".equals(feature) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("+", obj, emptyString);
      res.setBrackets(true); 
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 


    if ("console".equals(obj + "") && 
        ("log".equals(feature) || 
         "info".equals(feature)) && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      par1.setBrackets(true); 
      Expression res = 
        new UnaryExpression("->display", par1); 
      return res; 
    } 

    if ("next".equals(feature) && 
        obj.isOclIterator() && pars.size() == 0)
    { // itr.nextResult() returns OclIteratorResult object
      Expression res =
        BasicExpression.newCallBasicExpression("nextResult", obj); 
      res.setType(new Type("OclIteratorResult", null)); 
      return res; 
    } 

    if ("match".equals(feature) && 
        obj.isString() && pars.size() == 1) 
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
         new BinaryExpression("->firstMatch", obj, par1); 
      res.setType(new Type("String", null));
      res.setElementType(new Type("String", null));
      return res; 
    } // But could be allMatches if par1 ends with "g"

    if ("matchAll".equals(feature) && 
        obj.isString() && pars.size() == 1) 
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
         new BinaryExpression("->allMatches", obj, par1); 
      res.setType(new Type("Sequence", null));
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("search".equals(feature) && 
        obj.isString() && pars.size() == 1) 
    { Expression par1 = (Expression) pars.get(0); 
      Expression res1 = 
         new BinaryExpression("->firstMatch", obj, par1); 
      Expression indexExpr = 
         new BinaryExpression("->indexOf", obj, res1); 
      indexExpr = 
         new BinaryExpression("-", indexExpr, unitExpression); 
      Expression res = 
        new ConditionalExpression(
              new UnaryExpression("->oclIsUndefined", res1), 
              minusOneExpr, indexExpr); 
      res.setType(new Type("int", null));
      res.setElementType(new Type("int", null));
      return res; 
    } 


    if ("replace".equals(feature) && 
        obj.isString() && pars.size() == 2) 
    { Expression res = 
        BasicExpression.newFunctionBasicExpression(
           "replace", obj, pars);  
      res.setType(new Type("String", null));
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("replaceAll".equals(feature) && 
        obj.isString() && pars.size() == 2) 
    { Expression res = 
        BasicExpression.newFunctionBasicExpression(
           "replaceAllMatches", obj, pars);  
      res.setType(new Type("String", null));
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("split".equals(feature) && 
        obj.isString() && pars.size() == 1) 
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->split", obj, par1); 
      res.setType(new Type("Sequence", null));
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("hasOwnProperty".equals(feature) && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Vector args = new Vector(); 
      args.add(obj); 
      args.add(par1); 
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
          "hasAttribute", "OclType", args); 
      res.setType(new Type("boolean", null)); 
      return res; 
    } 

    if ("has".equals(feature) && 
        obj.isMap() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Expression keys = new UnaryExpression("->keys", obj); 
      Expression res = 
        new BinaryExpression("->includes", keys, par1);  
      res.setType(new Type("boolean", null)); 
      return res; 
    } 

    if ("has".equals(feature) && 
        obj.isSet() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->includes", obj, par1);  
      res.setType(new Type("boolean", null)); 
      return res; 
    } 

    if ("get".equals(feature) && 
        obj.isMap() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->at", obj, par1);  
      res.setType(obj.getElementType()); 
      return res; 
    } 
  
    if ("concat".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("^", obj, par1);
      res.setBrackets(true); 
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());  
      return res; 
    } 

    if ("join".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Vector parsx = new Vector(); 
      parsx.add(obj); 
      parsx.add(
        BasicExpression.newValueBasicExpression("\",\"")); 
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                   "separatorSum", "StringLib", parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("join".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Vector parsx = new Vector(); 
      parsx.add(obj); 
      parsx.add((Expression) pars.get(0)); 
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                   "separatorSum", "StringLib", parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("keys".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Vector parsx = new Vector(); 
      parsx.add(zeroExpression); 
      parsx.add(new BinaryExpression("-", 
                  new UnaryExpression("->size", obj), 
                  unitExpression)); 
      Expression indexes = 
        BasicExpression.newFunctionBasicExpression(
                   "subrange", 
                   "Integer", parsx);
      
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                   "newOclIterator_Sequence", 
                   "OclIterator", indexes);
      res.setType(new Type("OclIterator", null)); 
      return res; 
    } 

    if ("values".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression res = 
        BasicExpression.newStaticCallBasicExpression(
                   "newOclIterator_Sequence", 
                   "OclIterator", obj);
      res.setType(new Type("OclIterator", null)); 
      return res; 
    } 

    if ("concat".equals(feature) && 
        obj.isString() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("+", obj, par1);
      res.setBrackets(true); 
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("trim".equals(feature) && 
        obj.isString() && 
        pars.size() == 0)
    { Expression res = 
        new UnaryExpression("->trim", obj);
      
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("repeat".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { // (1..par1)->collect(obj)->sum()

      Expression par1 = (Expression) pars.get(0);
      Vector args = new Vector(); 
      args.add(unitExpression); 
      args.add(par1);  
      Expression domr =
        BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", args); 
 
      Expression colexpr = 
         new BinaryExpression("->collect", domr, obj);
      colexpr.setType(new Type("Sequence", null)); 
      colexpr.setElementType(new Type("String", null));  
      
      Expression res = 
        new UnaryExpression("->sum", colexpr);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("match".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression test = 
        new BinaryExpression("->hasMatch", obj, par1);  
      Expression fm = 
        new BinaryExpression("->firstMatch", obj, par1);
      SetExpression res1 = new SetExpression(true); 
      res1.addElement(
            new BinaryExpression("->firstMatch", obj, par1));
      
      SetExpression res2 = new SetExpression(true); 
      Expression res = 
        new ConditionalExpression(test,res1,res2); 
      res.setType(new Type("Sequence", null)); 
      res.setElementType(new Type("String", null));  
      return res; 
    } 

    if ("search".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0);
      Expression test = 
        new BinaryExpression("->hasMatch", obj, par1);  
      Expression fm = 
        new BinaryExpression("->firstMatch", obj, par1);
      Expression indx = 
        new BinaryExpression("->indexOf", obj, fm); 
      Expression indmx = 
        new BinaryExpression("-", indx, unitExpression); 
      Expression res = 
        new ConditionalExpression(test,indmx,minusOne); 
      res.setType(new Type("int", null)); 
      return res; 
    } // index of first match if there is one, or -1

    if (("getInt8".equals(feature) ||
         "getUint8".equals(feature) ||
         "getInt16".equals(feature) ||
         "getUint16".equals(feature) || 
         "getInt32".equals(feature) ||
         "getUint32".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression p0 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("int", null));   
      return res; 
    } 

    if (("getFloat32".equals(feature) ||
         "getFloat64".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression p0 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("double", null));   
      return res; 
    } 

    if (("getBigInt64".equals(feature) ||
         "getBigUint64".equals(feature)) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression p0 = (Expression) pars.get(0); 
      Expression res = 
        new BinaryExpression("->at", obj,
              new BinaryExpression("+", p0, unitExpression)); 
      res.setType(new Type("long", null));   
      return res; 
    } 

    
    if ("push".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Vector parsx = new Vector(); 
      // (Expression) pars.get(0); 
      // Expression res = 
      //   new BinaryExpression("->append", obj, par1);
      // res.setType(obj.getType()); 
      // res.setElementType(obj.getElementType());
      int incr = pars.size(); 
      Expression res = 
        new BinaryExpression("+", 
              new UnaryExpression("->size", obj), 
              new BasicExpression(incr)); 
      res.setType(new Type("int", null));   
      return res; 
    } // obj := obj^parsx

    if ("unshift".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression par1 = (Expression) pars.get(0); 
      // Expression res = 
      //   new BinaryExpression("^", parsx, obj);
      // res.setType(obj.getType()); 
      // res.setElementType(obj.getElementType());
      int incr = pars.size(); 
      Expression res = 
        new BinaryExpression("+", 
              new UnaryExpression("->size", obj), 
              new BasicExpression(incr)); 
      res.setType(new Type("int", null));   
      return res; 
    } // side effect is  obj := parsx^obj

    if ("pop".equals(feature) && 
        // obj.isSequence() && 
        pars.size() == 0)
    { Expression res = 
        new UnaryExpression("->last", obj);
      res.setType(obj.getElementType());  
      return res; 
    } // also side-effect obj := obj->front()

    if ("shift".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression res = 
        new UnaryExpression("->first", obj);
      res.setType(obj.getElementType());  
      return res; 
    } // also side-effect obj := obj->tail()

    if ("reverse".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression res = 
        new UnaryExpression("->reverse", obj);
      res.setType(obj.getType());  
      res.setElementType(obj.getElementType());
      return res; 
    } // also update form

    if ("sort".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { Expression res = 
        new UnaryExpression("->sort", obj);
      res.setType(obj.getType());  
      res.setElementType(obj.getElementType());
      return res; 
    } // also case of comparable. ->sortedWith

    if ("sort".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      // Expression rhs = 
      //   new BinaryExpression("->sortedWith", obj, par1);
      Vector spars = new Vector(); 
      spars.add(obj); 
      spars.add(par1); 
      Expression rhs = 
        BasicExpression.newStaticCallBasicExpression("sortWith", 
          "OclComparable", spars); 
      
      rhs.setType(obj.getType());  
      rhs.setElementType(obj.getElementType());
      return rhs;
    } 

    if ("entries".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 0)
    { // OclIterator.newOclIterator_Sequence(
      //    Integer.subrange(1,obj.size)->collect(i | 
      //                         Sequence{i-1, obj->at(i)}))

      BasicExpression indx = 
        BasicExpression.newVariableBasicExpression("_indx"); 
      Vector dmnargs = new Vector(); 
      dmnargs.add(unitExpression); 
      dmnargs.add(new UnaryExpression("->size", obj)); 
      Expression dmnset = 
        BasicExpression.newFunctionBasicExpression("subrange",
            "Integer", dmnargs); 
      Expression dmn = new BinaryExpression(":", indx, dmnset); 
      SetExpression rng = new SetExpression(true); 
      rng.addElement(
           new BinaryExpression("-", indx, unitExpression)); 
      rng.addElement(new BinaryExpression("->at", obj, indx));  
            
      Expression objentries = 
        new BinaryExpression("|C", dmn, rng); 
      Expression res = 
        BasicExpression.newStaticCallBasicExpression(
          "newOclIterator_Sequence", "OclIterator", objentries);
      res.setType(new Type("OclIterator", null));  
      return res; 
    } // But actually the sequence of pairs (i,obj[i+1])

    if ("copyWithin".equals(feature) && 
        obj.isSequence() && 
        pars.size() >= 2)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par3 = new UnaryExpression("->size", obj); 
      if (pars.size() >= 3) 
      { par3 = (Expression) pars.get(2); } 
      
      // obj.subrange(1,par1) ^ obj.subrange(par2+1,par3) ^
      // obj.subrange(par1+1+par3-par2,obj.size)

      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Expression par2x = 
        new BinaryExpression("+", par2, unitExpression);
      Expression par3x = 
        new BinaryExpression("+", par1x, 
          new BinaryExpression("-", par3, par2)); 
  
      Vector pars1 = new Vector(); 
      pars1.add(unitExpression); 
      pars1.add(par1); 
      Expression res1 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars1);
      res1.setType(obj.getType()); 
      res1.setElementType(obj.getElementType());

      Vector pars2 = new Vector(); 
      pars2.add(par2x); 
      pars2.add(par3); 
      Expression res2 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars2);
      res2.setType(obj.getType()); 
      res2.setElementType(obj.getElementType());

      Vector pars3 = new Vector(); 
      pars3.add(par3x); 
      pars3.add(new UnaryExpression("->size", obj)); 
      Expression res3 = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, pars3);
      res3.setType(obj.getType()); 
      res3.setElementType(obj.getElementType());

      Expression res = 
        new BinaryExpression("^", res1, 
                new BinaryExpression("^", res2, res3)); 
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      return res; 
    } 

    if ("fill".equals(feature) &&
        obj.isSequence()) 
    { Expression par1 = (Expression) pars.get(0);     
          
      if (pars.size() == 1)
      { Expression expr = 
                new BinaryExpression("->collect", 
                                     obj,par1); 
        // Statement stat = 
                new AssignStatement(obj, expr); 
        expr.setType(obj.getType()); 
        expr.setElementType(par1.getType()); 
        return expr; 
      } 

      if (pars.size() == 2) 
      { Expression lowind = (Expression) pars.get(1); 
        Expression highind = 
          new UnaryExpression("->size",obj);
        Expression elem = (Expression) pars.get(0);
            
        Vector pars1 = new Vector(); 
        pars1.add(unitExpression); 
        pars1.add(lowind); 

        Expression subrange1 = 
          BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars1); 

        Vector pars2 = new Vector(); 
        pars2.add(new BinaryExpression("+",
                     lowind,unitExpression)); 
        pars2.add(highind); 

        Expression subrange2 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars2); 
 
        subrange2 = 
           new BinaryExpression("->collect", subrange2, elem); 
        subrange2.setBrackets(true); 

        Expression expr = 
              new BinaryExpression("^", subrange1, subrange2); 
        expr.setType(new Type("Sequence", null)); 
        return expr;
      }  

      if (pars.size() == 3) 
      { Expression lowind = (Expression) pars.get(1); 
        Expression highind = (Expression) pars.get(2);
        Expression elem = (Expression) pars.get(0);
            
        Vector pars1 = new Vector(); 
        pars1.add(unitExpression); 
        pars1.add(lowind); 

        Expression subrange1 = 
          BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars1); 

        Vector pars2 = new Vector(); 
        pars2.add(new BinaryExpression("+",
                     lowind,unitExpression)); 
        pars2.add(highind); 

        Expression subrange2 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars2); 
 
        subrange2 = 
           new BinaryExpression("->collect", subrange2, elem); 
        subrange2.setBrackets(true); 

        Vector pars3 = new Vector(); 
        pars3.add(new BinaryExpression("+",
                            highind,unitExpression)); 
        pars3.add(
           new UnaryExpression("->size",obj)); 

        Expression subrange3 = 
           BasicExpression.newFunctionBasicExpression(
                "subrange", obj, pars3); 

        Expression cat1 = 
              new BinaryExpression("^", subrange2, subrange3); 
        Expression expr = 
              new BinaryExpression("^", subrange1, cat1); 
        expr.setType(new Type("Sequence", null)); 
        return expr;
      }  
    } 

    if ("slice".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() > 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      parsx.add(par2); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      return res; 
    } 

    if ("slice".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      return res; 
    } 

    if ("substring".equals(feature) && 
        obj.isString() && 
        pars.size() > 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      parsx.add(par2); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("substring".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("substr".equals(feature) && 
        obj.isString() && 
        pars.size() > 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Expression par2x = 
        new BinaryExpression("+", par1, par2);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      parsx.add(par2x); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("substr".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));
      return res; 
    } 

    if ("splice".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Expression par1x = 
        new BinaryExpression("+", par1, unitExpression);  
      Expression par2x = 
        new BinaryExpression("+", par1, par2);  
      Vector parsx = new Vector(); 
      parsx.add(par1x); 
      parsx.add(par2x);
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, parsx);
      res.setType(obj.getType()); 
      res.setElementType(obj.getElementType());
      return res; 
    } 

    if ("indexOf".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      BinaryExpression indof = 
        new BinaryExpression("->indexOf", obj, par1); 
      Expression resx = 
        new BinaryExpression("-", indof, unitExpression);  
      resx.setType(new Type("int", null)); 
      return resx; 
    } 

    if ("indexOf".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1); 
      Expression par2x = 
        new BinaryExpression("+", par2, unitExpression);
      Expression par2y = 
        new BinaryExpression("-", par2, unitExpression);  
        
      Expression subrng = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, par2x);
      subrng.setType(obj.getType()); 
      subrng.setElementType(obj.getElementType());
      BinaryExpression indof = 
        new BinaryExpression("->indexOf", subrng, par1); 
      Expression resx = 
        new BinaryExpression("+", indof, par2y);  
      resx.setType(new Type("int", null)); 
      return resx; 
    } 

    if ("lastIndexOf".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      BinaryExpression indof = 
        new BinaryExpression("->lastIndexOf", obj, par1); 
      Expression resx = 
        new BinaryExpression("-", indof, unitExpression);  
      resx.setType(new Type("int", null)); 
      return resx; 
    } 

    if ("lastIndexOf".equals(feature) && 
        (obj.isSequence() || obj.isString()) && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1); 
      Expression par2x = 
        new BinaryExpression("+", par2, unitExpression);  
      Expression par2y = 
        new BinaryExpression("-", par2, unitExpression);  
      Expression subrng = 
        BasicExpression.newFunctionBasicExpression(
          "subrange", obj, par2x);
      subrng.setType(obj.getType()); 
      subrng.setElementType(obj.getElementType());
      BinaryExpression indof = 
        new BinaryExpression("->lastIndexOf", subrng, par1); 
      Expression resx = 
        new BinaryExpression("+", indof, par2y);  
      resx.setType(new Type("int", null)); 
      return resx; 
    } 

    if ("map".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Argument is an anonymous function or function name

      Expression par = (Expression) pars.get(0);
      // lambda e : T in f->apply(e)
      // Result is  obj->collect( e | f->apply(e))

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 
      if (pars.size() > 1) 
      { targ = (Expression) pars.get(1); } 


      if (par instanceof UnaryExpression && 
          ((UnaryExpression) par).isLambdaExpression()) 
      { UnaryExpression lam = (UnaryExpression) par; 
        Attribute e = lam.getAccumulator(); 
        Expression call = lam.getArgument(); 
        Expression v = new BasicExpression(e); 
        BinaryExpression carg = 
          new BinaryExpression(":", v, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("|C", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(call.getType()); 
        return colexpr; 
      } 
      else // function name
      { String vv = Identifier.nextIdentifier("_var"); 
        BasicExpression pf = 
          BasicExpression.newVariableBasicExpression(vv);
        pf.setType(obj.getElementType());  
        Expression call = 
          new BinaryExpression("->apply", par, pf);
        if (par instanceof BasicExpression)
        { ((BasicExpression) par).addParameter(pf); 
          ((BasicExpression) par).setObjectRef(targ); 
          call = par; 
        }  
        call.setType(par.getElementType()); 
        BinaryExpression carg = 
          new BinaryExpression(":", pf, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("|C", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(call.getType()); 
        return colexpr; 
      } 
    } 

    if ("reduce".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 1)
    { // obj.reduce(f,init) is 
      // obj->iterate(_z; _acc = init | f(_z,_acc)) 

      Expression fexpr = (Expression) pars.get(0);
      Expression init = (Expression) pars.get(1); 

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 

      String acc = Identifier.nextIdentifier("_acc"); 
      String var = Identifier.nextIdentifier("_var"); 

      BasicExpression varexpr = 
         BasicExpression.newVariableBasicExpression(var);  
    
      BasicExpression accexpr = 
         BasicExpression.newVariableBasicExpression(acc);
  
      Expression rrhs = 
         Expression.simplifyApply2( 
                          fexpr, varexpr, accexpr);
   
      BinaryExpression iter = 
         new BinaryExpression("->iterate",
                                   obj, rrhs);
      iter.iteratorVariable = var; 
      Attribute accum = new Attribute(acc, init.getType(), 
                            ModelElement.INTERNAL);
      accum.setInitialExpression(init); 
      iter.accumulator = accum; 
      iter.setType(init.getType()); 
      return iter; 
    } 

    if ("reduceRight".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 1)
    { // obj.reduceRight(f,init) is 
      // obj->reverse()->iterate(_z; _acc = init | f(_z,_acc)) 

      Expression fexpr = (Expression) pars.get(0);
      Expression init = (Expression) pars.get(1); 

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 

      String acc = Identifier.nextIdentifier("_acc"); 
      String var = Identifier.nextIdentifier("_var"); 

      BasicExpression varexpr = 
         BasicExpression.newVariableBasicExpression( 
                                   "(" + acc + "," + var + ")");
      Expression rrhs = 
         Expression.simplifyApply( 
                          fexpr, varexpr);
      Expression rev = new UnaryExpression("->reverse", obj);    
      BinaryExpression iter = 
         new BinaryExpression("->iterate",
                                   rev, rrhs);
      iter.iteratorVariable = var; 
      Attribute accum = new Attribute(acc, init.getType(), 
                            ModelElement.INTERNAL);
      accum.setInitialExpression(init); 
      iter.accumulator = accum; 
      iter.setType(init.getType()); 
      return iter; 
    } 

    if ("subarray".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { Expression st = (Expression) pars.get(0);
      Expression en = null; 
      if (pars.size() > 1) 
      { en = (Expression) pars.get(1); } 
      else 
      { en = new UnaryExpression("->size", obj); } 

      // obj.subrange(st+1,en)
      BinaryExpression incr = 
        new BinaryExpression("+", st, unitExpression);
      Vector parsx = new Vector(); 
      parsx.add(incr); 
      parsx.add(en);  
      Expression res = 
        BasicExpression.newFunctionBasicExpression(
            "subrange", obj, parsx); 
      res.setType(new Type("Sequence", null)); 
      res.setElementType(obj.getElementType()); 
      return res; 
    } 
      
    if ("filter".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Argument is an anonymous function
      Expression par = (Expression) pars.get(0);
      // lambda e : T in f->apply(e)
      // Result is  obj->select( e | f->apply(e))

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 
      if (pars.size() > 1) 
      { targ = (Expression) pars.get(1); } 

      if (par instanceof UnaryExpression &&
          ((UnaryExpression) par).isLambdaExpression())  
      { UnaryExpression lam = (UnaryExpression) par; 
        Attribute e = lam.getAccumulator(); 
        Expression call = lam.getArgument(); 
        Expression v = new BasicExpression(e); 
        BinaryExpression carg = 
          new BinaryExpression(":", v, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("|", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
      else // function name
      { String vv = Identifier.nextIdentifier("_var"); 
        BasicExpression pf = 
          BasicExpression.newVariableBasicExpression(vv);
        pf.setType(obj.getElementType());  
        Expression call = 
          new BinaryExpression("->apply", par, pf);
        if (par instanceof BasicExpression)
        { ((BasicExpression) par).addParameter(pf); 
          ((BasicExpression) par).setObjectRef(targ); 
          call = par; 
        }  
        call.setType(new Type("boolean", null)); 
        BinaryExpression carg = 
          new BinaryExpression(":", pf, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("|", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
    } 

    if ("every".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Argument is an anonymous function
      Expression par = (Expression) pars.get(0);
      // lambda e : T in f->apply(e)
      // Result is  obj->forAll( e | f->apply(e))

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 
      if (pars.size() > 1) 
      { targ = (Expression) pars.get(1); } 

      if (par instanceof UnaryExpression &&
          ((UnaryExpression) par).isLambdaExpression()) 
      { UnaryExpression lam = (UnaryExpression) par; 
        Attribute e = lam.getAccumulator(); 
        Expression call = lam.getArgument(); 
        Expression v = new BasicExpression(e); 
        BinaryExpression carg = 
          new BinaryExpression(":", v, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("!", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
      else // function name
      { String vv = Identifier.nextIdentifier("_var"); 
        BasicExpression pf = 
          BasicExpression.newVariableBasicExpression(vv);
        pf.setType(obj.getElementType());  
        Expression call = 
          new BinaryExpression("->apply", par, pf);
        if (par instanceof BasicExpression)
        { ((BasicExpression) par).addParameter(pf); 
          ((BasicExpression) par).setObjectRef(targ); 
          call = par; 
        }  
        call.setType(new Type("boolean", null)); 
        BinaryExpression carg = 
          new BinaryExpression(":", pf, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("!", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
    } 

    if ("some".equals(feature) && 
        obj.isSequence() && 
        pars.size() > 0)
    { // Argument is an anonymous function
      Expression par = (Expression) pars.get(0);
      // lambda e : T in f->apply(e)
      // Result is  obj->exists( e | f->apply(e))

      Expression targ = 
        BasicExpression.newVariableBasicExpression("self"); 
      if (pars.size() > 1) 
      { targ = (Expression) pars.get(1); } 

      if (par instanceof UnaryExpression &&
          ((UnaryExpression) par).isLambdaExpression()) 
      { UnaryExpression lam = (UnaryExpression) par; 
        Attribute e = lam.getAccumulator(); 
        Expression call = lam.getArgument(); 
        Expression v = new BasicExpression(e); 
        BinaryExpression carg = 
          new BinaryExpression(":", v, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("#", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
      else // function name
      { String vv = Identifier.nextIdentifier("_var"); 
        BasicExpression pf = 
          BasicExpression.newVariableBasicExpression(vv);
        pf.setType(obj.getElementType());  
        Expression call = 
          new BinaryExpression("->apply", par, pf);
        if (par instanceof BasicExpression)
        { ((BasicExpression) par).addParameter(pf); 
          ((BasicExpression) par).setObjectRef(targ); 
          call = par; 
        }  
        call.setType(new Type("boolean", null)); 
        BinaryExpression carg = 
          new BinaryExpression(":", pf, obj); 
        BinaryExpression colexpr = 
          new BinaryExpression("#", carg, call); 
        colexpr.setType(new Type("Sequence",null)); 
        colexpr.setElementType(obj.getElementType()); 
        return colexpr; 
      } 
    } 

    if (("at".equals(feature) || "charAt".equals(feature)) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression indx = 
        new BinaryExpression("+", par1, unitExpression);  
      BinaryExpression indof = 
        new BinaryExpression("->at", obj, indx); 
      indof.setType(new Type("String", null)); 
      indof.setElementType(new Type("String", null)); 
      return indof; 
    } // par1 could be negative. 

    if (("charCodeAt".equals(feature) || 
         "codePointAt".equals(feature)) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression indx = 
        new BinaryExpression("+", par1, unitExpression);  
      BinaryExpression indof = 
        new BinaryExpression("->at", obj, indx); 
      indof.setType(new Type("String", null)); 
      indof.setElementType(new Type("String", null));
      UnaryExpression codex =
        new UnaryExpression("->char2byte", indof);  
      codex.setType(new Type("int", null)); 
      return codex; 
    } 

    if ("startsWith".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new BinaryExpression("->hasPrefix",obj,par1); 
      expr.setType(new Type("boolean",null));  
      return expr; 
    } 

    if ("endsWith".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new BinaryExpression("->hasSuffix",obj,par1); 
      expr.setType(new Type("boolean",null));  
      return expr; 
    } 

    if ("includes".equals(feature) && 
        obj.isString() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new BinaryExpression("->indexOf",obj,par1); 
      expr.setType(new Type("int",null));
      Expression isin = 
        new BinaryExpression(">", expr, zeroExpression);
      isin.setBrackets(true);  
      isin.setType(new Type("boolean", null));   
      return isin; 
    } 

    if ("includes".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new BinaryExpression("->includes",obj,par1); 
      expr.setType(new Type("boolean",null));
      return expr; 
    } 

    if ("includes".equals(feature) && 
        obj.isSequence() && 
        pars.size() == 2)
    { Expression par1 = (Expression) pars.get(0); 
      Expression par2 = (Expression) pars.get(1);
      Vector parsx = new Vector(); 
      parsx.add(
        new BinaryExpression("+", par2, unitExpression));
      parsx.add(
        new UnaryExpression("->size", obj));    
      Expression subr = 
        BasicExpression.newFunctionBasicExpression("subrange", 
                            obj, parsx);  
      Expression expr = 
        new BinaryExpression("->includes",subr,par1); 
      expr.setType(new Type("boolean",null));
      return expr; 
    } 

    if ("split".equals(feature) && obj.isString() &&
        pars.size() == 1)
    { Expression par1 = (Expression) pars.get(0); 
      Expression expr = 
        new BinaryExpression("->split", obj, par1);
      expr.setType(new Type("Sequence", null)); 
      expr.setElementType(new Type("String", null)); 
      return expr; 
    } 

    if ("split".equals(feature) && obj.isString() &&
        pars.size() == 0)
    { Expression par1 =
        BasicExpression.newValueBasicExpression("\"[ \\t\\n\\r]+\""); 
      Expression expr = 
        new BinaryExpression("->split", obj, par1);
      expr.setType(new Type("Sequence", null)); 
      expr.setElementType(new Type("String", null)); 
      return expr; 
    } 

    if ("toUpperCase".equals(feature) && 
        obj.isString() && 
        pars.size() == 0)
    { UnaryExpression indof = 
        new UnaryExpression("->toUpperCase", obj); 
      indof.setType(new Type("String", null)); 
      indof.setElementType(new Type("String", null)); 
      return indof; 
    } 

    if ("toLowerCase".equals(feature) && 
        obj.isString() && 
        pars.size() == 0)
    { UnaryExpression indof = 
        new UnaryExpression("->toLowerCase", obj); 
      indof.setType(new Type("String", null)); 
      indof.setElementType(new Type("String", null)); 
      return indof; 
    } 

    if ("valueOf".equals(feature) && 
        obj.isString() && 
        pars.size() == 0)
    { return obj; } 

    BasicExpression classexpr = 
          BasicExpression.newCallBasicExpression(
                            feature + "",obj,pars); 
    return classexpr; 
  } 


  // globalThis is of type FromJavaScript -- a unique instance
  // operation getGlobalThis() : FromJavaScript
  // pre: true post: true 
  // activity: if _instance = null 
  //           then _instance = createFromJavaScript() 
  //           else skip ; return _instance; 

  public BehaviouralFeature jsglobalThis(Entity fjs, Attribute inst)
  { BehaviouralFeature bf = 
        new BehaviouralFeature("getGlobalThis", 
              new Vector(), false, new Type(fjs));
    BasicExpression _inst = 
      BasicExpression.newVariableBasicExpression(inst);
    _inst.setType(new Type(fjs)); 
    Expression isUndefined = 
       new UnaryExpression("->oclIsUndefined", _inst); 
    Expression cre = 
      BasicExpression.newCallBasicExpression(
                                 "createFromJavaScript"); 
    cre.setType(new Type(fjs)); 
    AssignStatement asgn = 
      new AssignStatement(_inst, cre); 
    ConditionalStatement cs = 
      new ConditionalStatement(isUndefined, 
                               asgn, skipStatement); 
    ReturnStatement ret = 
      new ReturnStatement(_inst); 
    SequenceStatement ss = new SequenceStatement(); 
    ss.addStatement(cs); 
    ss.addStatement(ret); 
    bf.setActivity(ss); 
    return bf;       
  } 

  public Expression jspropertyAssignmentAnonymousFunction(
                       java.util.Map vartypes, 
                       java.util.Map varelemtypes, 
                       Vector types, Vector entities)
  { System.out.println(">>> jspropertyAssignmentAnonymousFunction for " + this); 
    System.out.println(); 

    if ("singleExpression".equals(tag) && 
        terms.size() > 0 && 
        (terms.get(0) instanceof ASTCompositeTerm))
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(0); 
      return t1.jspropertyAssignmentAnonymousFunction(
                                vartypes,
                                varelemtypes,types,entities); 
    } 

    if ("anonymousFunction".equals(tag) && 
        terms.size() > 0 && 
        (terms.get(0) instanceof ASTCompositeTerm))
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(0); 
      return t1.jspropertyAssignmentAnonymousFunction(
                                vartypes,
                                varelemtypes,types,entities); 
    } 

    if ("functionDeclaration".equals(tag) &&
        "function".equals(terms.get(0) + "") && 
        "(".equals(terms.get(2) + "") && 
        ")".equals(terms.get(4) + "") && 
        terms.size() >= 6)
    { ASTTerm fid = (ASTTerm) terms.get(1); 
      ASTTerm args = (ASTTerm) terms.get(3); 
      ASTTerm body = (ASTTerm) terms.get(5); 

      String fname = fid.literalForm(); 
      Vector fpars = new Vector(); 
      Vector parterms = args.getTerms(); 
      for (int i = 0; i < parterms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) parterms.get(i);
        
        if (vbl instanceof ASTSymbolTerm) { } 
        else  
        { 
          Vector fpar = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          fpars.addAll(fpar);
        } 
      }
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);

      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      Type ftype = bf.getFunctionType(); 
      vartypes.put(fname,ftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      Entity fjs = 
        (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { fjs.addOperation(bf); 
        bf.setOwner(fjs); 
        selfexpr.setType(new Type(fjs)); 
      } 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    bf,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, bf);

      Expression fstring = 
        BasicExpression.newValueBasicExpression(
                              "\"" + fname + "\"");     
 
      return new BinaryExpression("|->", 
                                  fstring, res);  
    } 

    if ("functionDeclaration".equals(tag) &&
        "function".equals(terms.get(0) + "") && 
        "(".equals(terms.get(2) + "") && 
        ")".equals(terms.get(3) + "") && 
        terms.size() >= 5)
    { ASTTerm fid = (ASTTerm) terms.get(1); 
      ASTTerm body = (ASTTerm) terms.get(4); 

      Vector fpars = new Vector(); 
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);

      String fname = fid.literalForm(); 

      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      Type ftype = bf.getFunctionType(); 
      vartypes.put(fname,ftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      Entity fjs = 
        (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { fjs.addOperation(bf); 
        bf.setOwner(fjs); 
        selfexpr.setType(new Type(fjs)); 
      } 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    bf,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, bf); 
      Expression fstring = 
        BasicExpression.newValueBasicExpression(
                              "\"" + fname + "\"");     
 
      return new BinaryExpression("|->", 
                                  fstring, res);  
    } 

    // Type ltype = new Type("OclAny", null);
    //     Expression letexp = 
    //       UnaryExpression.newLambdaUnaryExpression(
    //         pars.modelElements, 
    //         body.statement, 
    //         ASTTerm.currentClass, 
    //         ASTTerm.enumtypes, ASTTerm.entities); 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      String t1tag = t1.getTag(); 

      if (t1 instanceof ASTCompositeTerm && 
          ("functionDeclaration".equals(t1tag) ||
           "anonymousFunction".equals(t1tag) ||
           "singleExpression".equals(t1tag)))
      { return ((ASTCompositeTerm) t1).jspropertyAssignmentAnonymousFunction(
                                vartypes,
                                varelemtypes,types,entities);
      } 

      Expression fname = t1.jsexpressionToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      Expression fstring = 
          new BinaryExpression("+", fname,
            BasicExpression.newValueBasicExpression(
                              "\"\""));     
      fstring.setBrackets(true); 
      fstring.setType(new Type("String", null)); 
      return new BinaryExpression("|->", 
                                  fstring, fstring);  
    } 
        
    return null; 
  } 

  public Expression jsexpressionToKM3(java.util.Map vartypes, 
    java.util.Map varelemtypes, Vector types, Vector entities)
  { System.out.println(">> jsexpressionToKM3 for " + tag + " with " + terms.size() + " terms " + terms); 
    System.out.println(); 

    if (terms.size() == 0)
    { return null; } 

    if ("expressionSequence".equals(tag) && 
        terms.size() >= 1) 
    { ASTTerm fterm = (ASTTerm) terms.get(terms.size()-1); 
      return fterm.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
    } 

    if ("arguments".equals(tag) && 
        terms.size() >= 3 && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + "")) 
    { ASTTerm fterm = (ASTTerm) terms.get(1); 
      return fterm.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
    } 

    if ("anonymousFunction".equals(tag) &&
        terms.size() == 1 && 
        "functionDeclaration".equals(
                   ((ASTTerm) terms.get(0)).getTag()))
    { ASTCompositeTerm func = (ASTCompositeTerm) terms.get(0); 
      Vector bfs = func.jsfunctionDeclarationToKM3(vartypes,
                             varelemtypes,types,
                             entities);
      if (bfs.size() == 0) 
      { return null; } 

      BehaviouralFeature bf = (BehaviouralFeature) bfs.get(0); 

      Entity fjs = 
        (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { fjs.addOperation(bf); 
        bf.setOwner(fjs); 
        selfexpr.setType(new Type(fjs)); 
      } 

      Vector fpars = bf.getParameters(); 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    bf,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, bf); 
      return res;  
    } 

    if ("getter".equals(tag) && terms.size() > 0)
    { ASTTerm t1 = (ASTTerm) terms.get(terms.size()-1); 
      return t1.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
    } 

    if ("setter".equals(tag) && terms.size() > 0)
    { ASTTerm t1 = (ASTTerm) terms.get(terms.size()-1); 
      return t1.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
    } 

    if ("templateStringAtom".equals(tag) && 
        terms.size() == 1) 
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return new BasicExpression(t1.literalForm()); 
    } 

    if ("templateStringAtom".equals(tag) && 
        terms.size() >= 3) 
    { ASTTerm t1 = (ASTTerm) terms.get(2); 
      Expression e1 = t1.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
      return e1; 
    } 

    if ("propertyAssignment".equals(tag) && 
        terms.size() == 1 && 
        terms.get(0) instanceof ASTCompositeTerm)
    { Expression res = 
        ((ASTCompositeTerm) 
            terms.get(0)).jspropertyAssignmentAnonymousFunction(
                                vartypes,
                                varelemtypes,types,entities);
      return res; 
    } 

    if (terms.size() == 1)
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      Expression rs = t1.jsexpressionToKM3(
         vartypes, varelemtypes, types, entities);
      return rs;  
    } 

    ASTTerm firstTerm = (ASTTerm) terms.get(0); 
    ASTTerm lastTerm = (ASTTerm) terms.get(terms.size()-1); 

    if ("templateStringLiteral".equals(tag) && 
        "`".equals(firstTerm + "") && "`".equals(lastTerm + ""))
    { String text = "";
      Expression res = null; 
 
      for (int i = 1; i < terms.size()-1; i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 

        // System.out.println(tt.getTag() + " " + tt.arity()); 
    
        if ("templateStringAtom".equals(tt.getTag()) &&
            tt.arity() == 0)
        { text = text + " "; } 
        else if ("templateStringAtom".equals(tt.getTag()) &&
            tt.arity() == 1)
        { text = text + tt.getTerm(0); } 
        else 
        { Expression expr = tt.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
          Expression textexpr = 
            BasicExpression.newValueBasicExpression(
                                    "\"" + text + "\""); 
          if (res == null)
          { res = new BinaryExpression("+", textexpr, expr); 
            text = ""; 
          } 
          else  
          { res = new BinaryExpression("+", res, textexpr);
            res = new BinaryExpression("+", res, expr);
            text = ""; 
          } 
          res.setType(new Type("String", null)); 
          res.setElementType(new Type("String", null)); 
        } 
      }
     
      if (text.length() > 0) 
      { Expression textexpr = 
            BasicExpression.newValueBasicExpression(
                                    "\"" + text + "\""); 
        if (res == null) 
        { return textexpr; } 
        else 
        { res = new BinaryExpression("+", res, textexpr); }
      } 

      res.setType(new Type("String", null)); 
      res.setElementType(new Type("String", null));
 
      return res; 
    } 

    if ("literal".equals(tag) && terms.size() > 1 &&  
        "/".equals(firstTerm + ""))
    { String text = "";
      for (int k = 1; k < terms.size(); k++) 
      { ASTTerm tk = (ASTTerm) terms.get(k);
        String tkstring = tk + ""; 
        if ("/".equals(tkstring)) 
        { break; }  
        if (tkstring.endsWith("/"))
        { text = 
            text + tkstring.substring(0,tkstring.length()-1); 
          break; 
        }  
        text = text + tk.literalForm(); 
      } 

      Expression textexpr = 
            BasicExpression.newValueBasicExpression(
                                    "\"" + text + "\""); 
      textexpr.setType(new Type("String", null)); 
      textexpr.setElementType(new Type("String", null));
      return textexpr; 
    } 

    if ("argument".equals(tag) && 
        terms.size() == 2 && 
        "...".equals(terms.get(0) + ""))
    { ASTTerm arg = (ASTTerm) terms.get(1); 
      Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
      return expr; 
    } 
  
    if ("singleExpression".equals(tag))
    { if (terms.size() == 3 && "(".equals(firstTerm + "") &&
                             ")".equals(lastTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        expr.setBrackets(true); 
        return expr; 
      }

      if (terms.size() == 4 && "import".equals(firstTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(2); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        BasicExpression importFunction = 
          BasicExpression.newCallBasicExpression("import", null,
                                                 expr); 
        return importFunction; 
      } 

      if (terms.size() == 2 && "!".equals(firstTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        UnaryExpression notexpr = 
          new UnaryExpression("not", expr);
        notexpr.setType(new Type("boolean", null));  
        return notexpr; 
      } 

      if (terms.size() == 2 && "~".equals(firstTerm + ""))
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        BinaryExpression addexpr = 
          new BinaryExpression("+", expr, unitExpression);
        addexpr.setBrackets(true); 
        UnaryExpression minusexpr = 
          new UnaryExpression("-", addexpr); 
        minusexpr.setType(expr.getType());  
        return minusexpr; 
      } 

      if (terms.size() == 2 && 
            ("-".equals(firstTerm + "") ||
             "+".equals(firstTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        String op = "" + terms.get(0); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        UnaryExpression minusexpr = 
          new UnaryExpression(op, expr); 
        minusexpr.setType(expr.getType());  
        return minusexpr; 
      } // Also converts to a number. 

      if (terms.size() == 2 && 
            ("--".equals(firstTerm + "") ||
             "++".equals(firstTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        String op = "" + terms.get(0); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        // String oper = "" + op.charAt(0); 

        // BinaryExpression minusexpr = 
        //   new BinaryExpression(oper, expr, unitExpression); 
        // minusexpr.setType(expr.getType());  
        return expr; 
      } 

      if (terms.size() == 2 && 
            ("--".equals(lastTerm + "") ||
             "++".equals(lastTerm + "")) )
      { ASTTerm arg = (ASTTerm) terms.get(0); 
        String op = "" + terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        return expr; 
      } // Query form

      if (terms.size() == 2 && 
          "typeof".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        expr.setBrackets(true); 
        UnaryExpression expr1 = 
          new UnaryExpression("->oclType", expr);
        Expression addexpr = 
          new BinaryExpression("+", expr1, emptyString);
        addexpr.setBrackets(true);   
        addexpr.setType(new Type("String", null));  
        return addexpr; 
      } 

      if (terms.size() == 2 && 
          "void".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        // Query form value is always null
        return expr; 
      } 

      if (terms.size() == 2 && 
          "delete".equals(firstTerm + "") )
      { ASTTerm arg = (ASTTerm) terms.get(1); 
        Expression expr = arg.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        expr.setBrackets(true); 
        UnaryExpression minusexpr = 
          new UnaryExpression("->isDeleted", expr); 
        minusexpr.setType(new Type("boolean", null));  
        return minusexpr; 
      } 


      /* if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()) && 
          lastTerm.arity() == 2)
      { ASTCompositeTerm oper = 
            (ASTCompositeTerm) terms.get(0); 
        Vector pars = new Vector(); 
        return oper.jsfeatureAccess(
                        pars,
                        vartypes,
                        varelemtypes,types,entities);
      } */ 

      if (terms.size() == 2 && 
          "arguments".equals(lastTerm.getTag()))
      { ASTTerm oper = (ASTTerm) terms.get(0); 
        Vector pars = 
          ((ASTCompositeTerm) lastTerm).jsexpressionListToKM3(
                 vartypes,varelemtypes,types,entities);
        Expression opexpr = 
          oper.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);

        String cnme = oper.literalForm(); 

        if ("eval".equals(cnme) && 
            lastTerm.arity() == 3 && 
            pars.size() > 0) 
        { // eval(str)
          String expr = pars.get(0) + ""; 
          if (expr.length() > 2 && 
              expr.startsWith("\"") && 
              expr.endsWith("\""))
          { int elen = expr.length(); 
            expr = expr.substring(1,elen-1); 
          } 

          String astexpr = 
            PreProcessModels.applyAntlr("JavaScript",
                                   "singleExpression",
                                   expr);
          if (astexpr == null || 
              "".equals(astexpr))
          { return new BasicExpression("null"); } 

          Compiler2 c = new Compiler2();    

          ASTTerm xx =
             c.parseGeneralAST(astexpr); 

          if (xx == null) 
          { return new BasicExpression("null"); } 

          return xx.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);  
        } 

        if ("parseFloat".equals(cnme) && 
            pars.size() == 1)
        { Expression par1 = (Expression) pars.get(0);
          par1.setBrackets(true);  
          Expression expr = 
            new UnaryExpression("->toReal", par1);  
          expr.setType(new Type("double", null));  
          return expr; 
        }

        if ("parseInt".equals(cnme) && 
            pars.size() == 1)
        { Expression par1 = (Expression) pars.get(0);
          par1.setBrackets(true);  
          Expression expr = 
            new UnaryExpression("->toInteger", par1);  
          expr.setType(new Type("int", null));  
          return expr; 
        }

        if ("String".equals(cnme))
        { Expression strexpr = 
               BasicExpression.newValueBasicExpression("");
          if (pars.size() > 0)
          { strexpr = (Expression) pars.get(0); } 
          strexpr.setType(new Type("String", null));
          return strexpr; 
        } 

        if ("RegExp".equals(cnme))
        { Expression strexpr = 
               BasicExpression.newValueBasicExpression("");
          if (pars.size() > 0)
          { strexpr = (Expression) pars.get(0); } 
          strexpr.setType(new Type("String", null));
          Expression regexpr = 
            BasicExpression.newStaticCallBasicExpression(
              "compile", "OclRegex", strexpr); 
          regexpr.setType(new Type("OclRegex", null));
          
          return regexpr; 
        } 

        if ("Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          arrexpr.setType(new Type("Sequence", null));
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       nullExpression);
                rexpr.setType(new Type("Sequence", null));
                return rexpr;
              } 
              else  
              { arrexpr.addElement(par1); }
            }
            else 
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("DataView".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          arrexpr.setType(new Type("Sequence", null));
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              return par1;
            }
            else if (pars.size() == 2) 
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;                     
            }
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;       
            } 
          }  
          return arrexpr; 
        } 

        if ("ArrayBuffer".equals(cnme) || 
            "SharedArrayBuffer".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("int", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("int", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(new Type("int", null)); 
                return rexpr;
              } 
              else  
              { arrexpr.addElement(par1); }
            }
            else 
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("BigInt64Array".equals(cnme) || 
            "BigUint64Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("long", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("long", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(new Type("Sequence", null));
                rexpr.setElementType(new Type("long", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("Int32Array".equals(cnme) ||
            "Int16Array".equals(cnme) || 
            "Int8Array".equals(cnme) ||
            "Uint32Array".equals(cnme) ||
            "Uint16Array".equals(cnme) || 
            "Uint8ClampedArray".equals(cnme) || 
            "Uint8Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("int", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("int", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(new Type("int", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("int", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("int", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("int", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("int", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("Float32Array".equals(cnme) || 
            "Float64Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("double", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("double", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroDoubleExpression);
                rexpr.setType(new Type("Sequence", null));
                rexpr.setElementType(new Type("double", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("double", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("double", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("double", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("double", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments
          
        if ("Error".equals(cnme) || 
            "InternalError".equals(cnme) || 
            "SyntaxError".equals(cnme) || 
            "TypeError".equals(cnme) || 
            "ReferenceError".equals(cnme) || 
            "EvalError".equals(cnme) || 
            "AggregateError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclException", "OclException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("OclException", null)); 
          return errbe; 
        } 

        if ("RangeError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newIndexingException", "IndexingException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("IndexingException", null)); 
          return errbe; 
        } 

        if ("URIError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newIncorrectElementException", "IncorrectElementException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("IncorrectElementException", null)); 
          return errbe; 
        } 

        if ("BigInt".equals(cnme))
        { Expression rx = 
            (Expression) pars.get(0);
          BinaryExpression sumexpr = 
            new BinaryExpression("+", emptyString, rx); 
          sumexpr.setBrackets(true); 
          Expression resx = 
            new UnaryExpression("->toLong", sumexpr); 
          resx.setType(new Type("long", null));  
          return resx; 
        } 

        if (isJSMathFunction(cnme))
        { // cos, sin etc used without "Math."
          return jsMathFunctionExpression(cnme,pars); 
        } 

        if (isGeneratorFunction(opexpr,vartypes,
                                varelemtypes,types,entities))
        { Expression gen =
            Expression.convertToGenerator(opexpr,pars); 
          gen.setType(new Type("OclIterator", null)); 
          return gen; 
        }
 
        if (isDefinedFunction(opexpr,vartypes,
                              varelemtypes,types,entities) ||
            opexpr.isFunctionType())
        { opexpr = Expression.convertToApply(opexpr, pars); }
        else if (opexpr instanceof BasicExpression)
        { BasicExpression be = (BasicExpression) opexpr; 
          if (be.objectRef == null) 
          { be.setParameters(pars);

            // Try to find the object ref among "with" 
            // variables. 

            be.setObjectRef(
                 BasicExpression.newVariableBasicExpression(
                                                    "self"));  
            return be; 
          }
          return jsfeatureAccess(be.objectRef,be.data,pars,
                                 vartypes,
                                 varelemtypes,types,entities); 
        } 
        else 
        { opexpr = Expression.convertToApply(opexpr, pars); }    

        // Expression opcall = 
        //   BasicExpression.newCallBasicExpression(opexpr, 
        //                                            pars);

        // opexpr.setParameters(pars); 
        return opexpr; 
      } 

      if (terms.size() >= 2 &&
          "new".equals(firstTerm + ""))
      { // new C is C.newC() for class C
        // If C is a function, this is an old-style object 
        // creation. 

        ASTTerm cname = (ASTTerm) terms.get(1); 
        Expression cls = cname.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        String cnme = cname.literalForm(); // cls + ""; 
        String constr = "new" + cnme; // "new" + cls;
  
        Vector pars = new Vector();
        if (terms.size() > 2) 
        { ASTTerm args = (ASTTerm) terms.get(2); 
          pars = args.jsexpressionListToKM3(vartypes,
                                varelemtypes,types,entities);
        } 
 
        Expression classexpr = 
          BasicExpression.newStaticCallBasicExpression(constr,
                                                    cnme,pars);

        if ("String".equals(cnme))
        { Expression strexpr = 
              BasicExpression.newValueBasicExpression("");       
          if (pars.size() > 0)
          { strexpr = new BinaryExpression("+", 
                             (Expression) pars.get(0), 
                             strexpr); 
          } 
          strexpr.setType(new Type("String", null));
          return strexpr; 
        } 

        if ("RegExp".equals(cnme))
        { Expression strexpr = 
               BasicExpression.newValueBasicExpression("");
          if (pars.size() > 0)
          { strexpr = (Expression) pars.get(0); } 
          strexpr.setType(new Type("String", null));
          Expression regexpr = 
            BasicExpression.newStaticCallBasicExpression(
              "compile", "OclRegex", strexpr); 
          regexpr.setType(new Type("OclRegex", null));
          
          return regexpr; 
        } 

        if ("WeakRef".equals(cnme))
        { Expression strexpr = (Expression) pars.get(0); 
          
          Expression regexpr = 
            new UnaryExpression("?", strexpr); 
          regexpr.setType(new Type("Ref", null));
          regexpr.setElementType(strexpr.getType());
          
          return regexpr; 
        } 

        if ("Array".equals(cnme))
        { SetExpression arrexpr = new SetExpression(true); 
          arrexpr.setType(new Type("Sequence", null));
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       nullExpression);
                rexpr.setType(new Type("Sequence", null));
                rexpr.setElementType(new Type("OclAny", null)); 
                return rexpr; 
              } 
              else  
              { arrexpr.addElement(par1); }
            }
            else 
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("ArrayBuffer".equals(cnme) || 
            "SharedArrayBuffer".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("int", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("int", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(new Type("int", null)); 
                return rexpr; 
              } 
              else  
              { arrexpr.addElement(par1); }
            }
            else 
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("BigInt64Array".equals(cnme) || 
            "BigUint64Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("long", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("long", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(new Type("long", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("long", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("long", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("Int32Array".equals(cnme) ||
            "Int16Array".equals(cnme) || 
            "Int8Array".equals(cnme) ||
            "Uint32Array".equals(cnme) ||
            "Uint16Array".equals(cnme) || 
            "Uint8ClampedArray".equals(cnme) || 
            "Uint8Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("int", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("int", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(new Type("int", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("int", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("int", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(new Type("int", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("int", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments

        if ("Float32Array".equals(cnme) || 
            "Float64Array".equals(cnme))
        { SetExpression arrexpr = 
                       new SetExpression(true); 
          Type arrtype = new Type("Sequence", null); 
          arrtype.setElementType(new Type("double", null));
          arrexpr.setType(arrtype);
          arrexpr.setElementType(new Type("double", null)); 
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { Vector pprs = new Vector(); 
                pprs.add(unitExpression); 
                pprs.add(par1); 
                Expression expr = 
                  BasicExpression.newFunctionBasicExpression(
                              "subrange", "Integer", pprs); 
                Expression rexpr =  
                  new BinaryExpression("->collect", expr,
                                       zeroDoubleExpression);
                rexpr.setType(arrtype);
                rexpr.setElementType(
                                new Type("double", null)); 
                return rexpr;
              } // (1..par1)->collect(0)
              else if (par1.isSequence())
              { return par1; } 
              else  
              { arrexpr.addElement(par1); }
            }
            else if (pars.size() == 2)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = new UnaryExpression("->size",
                                                    par1);
              // par1.subrange(par2+1,par1->size())

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(par3); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(
                          new Type("double", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("double", null)); 
              return farr;       
            } 
            else if (pars.size() == 3)
            { Expression par1 = (Expression) pars.get(0); 
              Expression par2 = (Expression) pars.get(1); 
              Expression par3 = (Expression) pars.get(2);
              // par1.subrange(par2+1,par2+par3)

              Vector rng = new Vector(); 
              rng.add(new BinaryExpression("+", par2, 
                                 unitExpression)); 
              rng.add(new BinaryExpression("+", par2, 
                                 par3)); 

              BasicExpression farr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", par1, rng); 
              Type farrtype = new Type("Sequence", null); 
              farrtype.setElementType(
                          new Type("double", null));
              farr.setType(farrtype);
              farr.setElementType(new Type("double", null)); 
              return farr;       
            } 
            else  
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments
          
        if ("Error".equals(cnme) || 
            "InternalError".equals(cnme) || 
            "SyntaxError".equals(cnme) || 
            "TypeError".equals(cnme) || 
            "EvalError".equals(cnme) || 
            "ReferenceError".equals(cnme) || 
            "AggregateError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclException", "OclException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("OclException", null)); 
          return errbe; 
        } 

        if ("RangeError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newIndexingException", "IndexingException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("IndexingException", null)); 
          return errbe; 
        } 

        if ("URIError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newIncorrectElementException", "IncorrectElementException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("IncorrectElementException", null)); 
          return errbe; 
        } 

        if ("BigInt".equals(cnme))
        { Expression rx = 
            (Expression) pars.get(0); 
          return rx; 
        } 
 
        if ("Object".equals(cnme) || "Map".equals(cnme) ||
            "WeakMap".equals(cnme))
        { SetExpression errbe = 
            SetExpression.newMapSetExpression();
          errbe.setElementType(new Type("OclAny", null));

          if (pars.size() == 1)
          { Expression par0 = (Expression) pars.get(0); 
            if (par0.isSequence())
            { // map is 
              // par0->iterate( _x; _acc = Map{} | 
              //   _acc->union(Map{ _x[1] |-> _x[2] }) )
                    
              Type maptype = new Type("Map", null); 
              maptype.setKeyType(new Type("String", null)); 
              maptype.setElementType(
                                 new Type("OclAny", null));
 
              BasicExpression indx = 
                BasicExpression.newVariableBasicExpression(
                                                 "_x"); 
              indx.setType(par0.getElementType()); 
            
              BasicExpression acc = 
                BasicExpression.newVariableBasicExpression(
                                                   "_acc"); 
              acc.setType(maptype); 
              acc.setElementType(
                                 new Type("OclAny", null));
              Attribute accatt = 
                new Attribute("_acc", maptype, 
                              ModelElement.INTERNAL); 
              accatt.setElementType(
                                 new Type("OclAny", null));
              Expression k = new BinaryExpression(
                                          "->at", indx, 
                                          unitExpression);  
              Expression v = new BinaryExpression(
                                          "->at", indx, 
                                          twoExpression);  
              Expression rng = 
                new BinaryExpression("|->", k, v); 
              SetExpression sexpr = 
                new SetExpression(); 
              sexpr.setType(maptype); 
              sexpr.addElement(rng); 
              BinaryExpression expr = 
                new BinaryExpression("->union", acc, sexpr); 
              expr.setType(maptype); 
              
              BinaryExpression objentries = 
                new BinaryExpression("->iterate", par0, expr); 
              objentries.setVariable("_x"); 
              objentries.setAccumulator(accatt); 
              objentries.setType(maptype); 
              objentries.setElementType(
                         new Type("OclAny", null)); 
              return objentries; 
            } 
            return par0; 
          }   
          return errbe; 
        } 

        if ("Set".equals(cnme) || "WeakSet".equals(cnme))
        { SetExpression errbe = 
            new SetExpression(false);
          errbe.setElementType(new Type("OclAny", null));
          if (pars.size() == 1)
          { Expression par0 = (Expression) pars.get(0); 
            Expression res = 
              new BinaryExpression("->union", errbe, par0); 
            res.setType(new Type("Set", null)); 
            res.setElementType(par0.getElementType());
            return res; 
          } 
          return errbe; 
        } 

        if ("Date".equals(cnme))
        { if (pars.size() == 0) 
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            return datebe; 
          } 

          if (pars.size() == 1) // string
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_String", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 

          if (pars.size() == 3) // year, month, day
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_YMD", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 

          if (pars.size() == 6) // year, month, day, hr, m, s
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_YMDHMS", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 
        }    
 
        Entity ent = (Entity) ModelElement.lookupByName(
                                             cnme,entities); 
        if (ent == null && Entity.validEntityName(cnme))
        { ent = new Entity(cnme); 
          entities.add(ent);
          Entity fromJS = 
            (Entity) ModelElement.lookupByName(
                                        "FromJavaScript",
                                        entities); 
          if (fromJS == null) 
          { fromJS = ASTTerm.currentClass; } 

          if (fromJS != null) 
          { BehaviouralFeature oldclass = 
                 fromJS.getOperation(cnme); 
            if (oldclass != null) 
            { oldclass.jsClassFromConstructor(
                                  ent,fromJS,pars,entities);
              fromJS.removeOperation(oldclass); 
              oldclass.setType(new Type(ent));
              oldclass.setName("new" + cnme);
              oldclass.setStatic(true);  
              oldclass.setOwner(ent); 
              ent.addOperation(oldclass); 
            }
            System.out.println(">> New class from constructor: " + ent.getKM3());  
          }  
          /* classexpr = 
              BasicExpression.newStaticCallBasicExpression(
                                                    constr,
                                                    cnme,pars); 
           */ 
        } 

        if (ent != null) 
        { classexpr.setType(new Type(ent)); } 
        // could be Object. 

        return classexpr; 
      } 

      if (terms.size() == 3 &&
          ".".equals(terms.get(1) + "") &&  
          "identifierName".equals(lastTerm.getTag()))
      { // obj.f is obj.f unless obj is a map: obj["f"]

        Expression feature = 
          lastTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Expression obj = firstTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        
        if (obj.isMap() && "size".equals(feature + ""))
        { UnaryExpression res = 
            new UnaryExpression("->size", obj);
          res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isMap() && "set".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"set");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if ((obj.isMap() || obj.isSet()) && 
            "delete".equals(lastTerm.literalForm()))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"delete");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isMap() && "has".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"has");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isMap() && "get".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"get");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isMap() && "clear".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"clear");
          // res.setType(new Type("int", null));  
          return res; 
        }


        if (obj.isMap())
        { Expression indx = 
            new BasicExpression("\"" + feature + "\""); 
          indx.setType(new Type("String", null)); 
          BinaryExpression res = 
            new BinaryExpression("->at", obj, indx);
          res.setType(obj.getElementType());  
          return res; 
        }  

        if (obj.isSet() && "add".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"add");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isSet() && "has".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"has");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isSet() && "get".equals(feature + ""))
        { Expression res = 
            BasicExpression.newBasicExpression(obj,"get");
          // res.setType(new Type("int", null));  
          return res; 
        }

        if (obj.isSet() && "size".equals(feature + ""))
        { UnaryExpression res = 
            new UnaryExpression("->size", obj);
          res.setType(new Type("int", null));  
          return res;
        }

        if (obj.isSequence() && "length".equals(feature + ""))
        { UnaryExpression res = 
            new UnaryExpression("->size", obj);
          res.setType(new Type("int", null));  
          return res; 
        } 

        if (obj.isString() && "length".equals(feature + ""))
        { UnaryExpression res = 
            new UnaryExpression("->size", obj);
          res.setType(new Type("int", null));  
          return res; 
        } 

        if ("length".equals(feature + "") && 
            obj instanceof BasicExpression)
        { BehaviouralFeature mm = 
            Entity.findOperation(
              ((BasicExpression) obj).getData(), entities); 
          if (mm != null) 
          { int n = mm.getArity(); 
            BasicExpression res = new BasicExpression(n);
            res.setType(new Type("int", null));  
            return res; 
          } 
        }

        if ("name".equals(feature + "") && 
            obj instanceof BasicExpression)
        { BasicExpression be = (BasicExpression) obj; 
          if (be.getParameters() == null) 
          { BehaviouralFeature mm = 
              Entity.findOperation(
                       be.getData(), entities); 
            if (mm != null) 
            { String ss = mm.getName(); 
              BasicExpression res = 
                BasicExpression.newValueBasicExpression(
                                       "\"" + ss + "\"");
              res.setType(new Type("String", null));  
              return res; 
            }
          }  
        }
  
        return jsfeatureAccess(obj,feature + "",
                               vartypes,
                               varelemtypes,types,entities); 
      } 

      if (terms.size() == 4 &&
          "[".equals(terms.get(1) + "") &&  
          "]".equals(lastTerm + ""))
      { // x[f] is x[f+1] unless x is a map: x[f] or x["f"]
        ASTTerm indterm = (ASTTerm) terms.get(2); 
        Expression indx = 
          indterm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Expression obj = firstTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);

        if (obj.isMap())
        { Expression indxs = 
            Expression.convertToString(indx); 
          BinaryExpression res = 
            new BinaryExpression("->at", obj, indxs); 
          res.setType(obj.getElementType()); 
          return res; 
        }
    
        if (obj.isSequence() || obj.isString())
        { if ("\"length\"".equals(indx + "") || 
              "\'length\'".equals(indx + ""))
          { Expression rx = 
              new UnaryExpression("->size", obj); 
            rx.setType(new Type("int", null)); 
            return rx; 
          } 

          Expression indmx = 
            new BinaryExpression("+", indx, unitExpression); 
          indmx.setType(new Type("int", null)); 
          Expression res = 
             BasicExpression.newIndexedBasicExpression( 
                                               obj, indmx);
          res.setType(obj.getElementType()); 
          return res;
        } 

        // Else - object: 
        // OclType.getAttributeValue(obj,indx)

        if (indx.isInteger()) // assume a sequence or string. 
        { Expression indmx = 
            new BinaryExpression("+", indx, unitExpression); 
          indmx.setType(new Type("int", null)); 
          Expression resx = 
            BasicExpression.newIndexedBasicExpression( 
                                               obj, indmx); 
          resx.setType(obj.getElementType()); 
          return resx;
        } 

        Vector parsx = new Vector(); 
        parsx.add(obj); 
        parsx.add(            
                Expression.convertToString(indx)); 
        Expression rx =  
          BasicExpression.newStaticCallBasicExpression(
            "getAttributeValue", "OclType", parsx); 
        return rx; 
      } 

      if (terms.size() == 3 &&
          "new".equals(firstTerm + "") &&  
          "arguments".equals(lastTerm.getTag()))
      { // new C(args) is C.newC(args)

        ASTTerm cname = (ASTTerm) terms.get(1); 
        Expression cls = cname.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        String cnme = cls + ""; 
        String constr = "new" + cls;
  
        Vector pars = 
          ((ASTCompositeTerm) lastTerm).jsexpressionListToKM3(
                 vartypes,varelemtypes,types,entities);
        Expression classexpr = 
          BasicExpression.newStaticCallBasicExpression(constr,
                                                    cls,pars); 

        if ("String".equals(cnme))
        { Expression strexpr = 
              BasicExpression.newValueBasicExpression("");       
          if (pars.size() > 0)
          { strexpr = 
              new BinaryExpression("+", 
                    (Expression) pars.get(0), strexpr); 
          } 
          strexpr.setType(new Type("String", null));
          return strexpr; 
        } 

        if ("Array".equals(cnme))
        { SetExpression arrexpr = new SetExpression(true); 
          arrexpr.setType(new Type("Sequence", null));
          if (pars.size() > 0) 
          { // If single int argument, is the size 
            if (pars.size() == 1) 
            { Expression par1 = (Expression) pars.get(0); 
              if (par1.isInteger())
              { } 
              else  
              { arrexpr.addElement(par1); }
            }
            else 
            { arrexpr.addElements(pars); }
          }  
          return arrexpr; 
        } // elements are the arguments
 
        if ("Error".equals(cnme) ||
            "SyntaxError".equals(cnme) || 
            "TypeError".equals(cnme) || 
            "InternalError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclException", "OclException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("OclException", null)); 
          return errbe; 
        } 
        // could be Object, String, Function, Array. 

        if ("URIError".equals(cnme))
        { BasicExpression errbe = 
            BasicExpression.newStaticCallBasicExpression(
              "newIncorrectElementException", "IncorrectElementException"); 
          errbe.setParameters(pars); 
          errbe.setType(new Type("IncorrectElementException", null)); 
          return errbe; 
        } 

        if ("Object".equals(cnme) || "Map".equals(cnme) ||
            "WeakMap".equals(cnme))
        { SetExpression errbe = 
            SetExpression.newMapSetExpression();
          errbe.setElementType(new Type("OclAny", null));  
          return errbe; 
        } 

        if ("Set".equals(cnme) || "WeakSet".equals(cnme))
        { SetExpression errbe = 
            new SetExpression(false);
          errbe.setElementType(new Type("OclAny", null));

          if (pars.size() == 1)
          { Expression par0 = (Expression) pars.get(0); 
            Expression res = 
              new BinaryExpression("->union", errbe, par0); 
            res.setType(new Type("Set", null)); 
            res.setElementType(par0.getElementType());
            return res; 
          }   
          return errbe; 
        } 

        if ("Date".equals(cnme))
        { if (pars.size() == 0) 
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            return datebe; 
          } 

          if (pars.size() == 1) // string
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_String", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 

          if (pars.size() == 3) // year, month, day
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_YMD", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 

          if (pars.size() == 6) // year, month, day, hr, m, s
          { BasicExpression datebe = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclDate_YMDHMS", "OclDate");
            datebe.setType(new Type("OclDate", null)); 
            datebe.setParameters(pars); 
            return datebe; 
          } 
        }    
 

        Entity ent = (Entity) ModelElement.lookupByName(
                                             cnme,entities); 
        if (ent == null && Entity.validEntityName(cnme))
        { ent = new Entity(cnme); 
          entities.add(ent); 
        } 

        if (ent != null) 
        { classexpr.setType(new Type(ent)); }

        return classexpr; 
      } 

      if (terms.size() == 3 && "=".equals(terms.get(1) + ""))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        return rhsexpr; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "+=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsplus = 
          new BinaryExpression("+", lhsexpr, rhsexpr); 
        lhsplus.setType(lhsexpr.getType());  
        return lhsplus; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "-=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsminus = 
          new BinaryExpression("-", lhsexpr, rhsexpr);  
        lhsminus.setType(lhsexpr.getType());  
        return lhsminus; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "*=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsplus = 
          new BinaryExpression("*", lhsexpr, rhsexpr);  
        Type restype = Expression.deduceType("*", lhsexpr, 
                                             rhsexpr);
        lhsplus.setType(restype); 
        return lhsplus; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "/=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsdiv = 
          new BinaryExpression("/", lhsexpr, rhsexpr);  
        Type restype = Expression.deduceType("/", lhsexpr, 
                                             rhsexpr);
        lhsdiv.setType(restype); 
        return lhsdiv; 
      } // really a statement. 
 
      if (terms.size() == 3 && 
          "%=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        BinaryExpression lhsdiv = 
          new BinaryExpression("mod", lhsexpr, rhsexpr);  
        Type restype = Expression.deduceType("mod", lhsexpr, 
                                             rhsexpr);
        lhsdiv.setType(restype); 
        return lhsdiv; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "|=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseOr", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        return lhsdiv; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "&=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseAnd", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        return lhsdiv; 
      } // really a statement. 

      if (terms.size() == 3 && 
          "^=".equals(((ASTTerm) terms.get(1)).literalForm()))
      { // Assignment
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        Vector prs = new Vector(); 
        prs.add(lhsexpr); 
        prs.add(rhsexpr); 
        Expression lhsdiv = 
          BasicExpression.newStaticCallBasicExpression(
                            "bitwiseXor", "MathLib", 
                            prs);  
        Type restype = new Type("int", null);
        lhsdiv.setType(restype); 
        return lhsdiv; 
      } // really a statement. 

      if (terms.size() == 3 && 
          ("||".equals(terms.get(1) + "") || 
           "||=".equals(((ASTTerm) terms.get(1)).literalForm()) )
         )
      { // Or
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression lhsor = new BinaryExpression("or", 
                                          lhsexpr, rhsexpr); 
        Type restype = Expression.deduceType("or", lhsexpr, 
                                             rhsexpr);
        lhsor.setType(restype); 
        return lhsor; 
      } 

      if (terms.size() == 3 && 
          ("&&".equals(terms.get(1) + "") ||
           "&&=".equals(((ASTTerm) terms.get(1)).literalForm()))
         )
      { // And
        ASTTerm lhs = (ASTTerm) terms.get(0); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm rhs = (ASTTerm) terms.get(2); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression lhsand = 
          new BinaryExpression("&", lhsexpr, rhsexpr);
        Type restype = Expression.deduceType("&", lhsexpr, 
                                             rhsexpr);
        lhsand.setType(restype); 
        return lhsand; 
      } 

      if (terms.size() == 3 && "&".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Vector parms = new Vector(); 
        parms.add(lhsexpr); 
        parms.add(rhsexpr); 
        Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                          "bitwiseAnd", "MathLib", parms); 
        Type restype = Expression.deduceType("bitwiseAnd", 
                                             lhsexpr, 
                                             rhsexpr);
        expr.setType(restype); 
        return expr; 
      } 

      if (terms.size() == 3 && "|".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Vector parms = new Vector(); 
        parms.add(lhsexpr); 
        parms.add(rhsexpr); 
        Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                          "bitwiseOr", "MathLib", parms); 
        Type restype = Expression.deduceType("bitwiseOr", 
                                             lhsexpr, 
                                             rhsexpr);
        expr.setType(restype); 
        return expr; 
      } 

      if (terms.size() == 3 && "^".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Vector parms = new Vector(); 
        parms.add(lhsexpr); 
        parms.add(rhsexpr); 
        Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                          "bitwiseXor", "MathLib", parms);
        Type restype = Expression.deduceType("bitwiseXor", 
                                             lhsexpr, 
                                             rhsexpr);
        expr.setType(restype); 
         
        return expr; 
      } 

      if (terms.size() == 3 && "==".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression("=",lhsexpr,rhsexpr); 
        expr.setType(new Type("boolean", null)); 
        return expr; 
      } 

      if (terms.size() == 3 && "!=".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression("/=",lhsexpr,rhsexpr); 
        expr.setType(new Type("boolean", null)); 
        return expr; 
      } 

      if (terms.size() == 3 && 
          "===".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression("<>=",lhsexpr,rhsexpr); 
        expr.setType(new Type("boolean", null)); 
        return expr; 
      } 

      if (terms.size() == 3 && 
          "!==".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression("<>=",lhsexpr,rhsexpr);
        // expr.setBrackets(true); 
        expr.setType(new Type("boolean", null)); 
        UnaryExpression notexpr = 
          new UnaryExpression("not", expr);  
        notexpr.setType(new Type("boolean", null)); 
        return notexpr; 
      } 

      if (terms.size() == 3 && "in".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        if (rhsexpr.isMap())
        { Expression expr = 
            new UnaryExpression("->keys",rhsexpr);
          BinaryExpression inmapexpr = 
            new BinaryExpression("->includes", expr, lhsexpr);
          inmapexpr.setType(new Type("boolean", null)); 
          return inmapexpr; 
        }   
        else if (rhsexpr.isSequence())
        { Expression sze =
            new UnaryExpression("->size", rhsexpr); 
          Expression rel1 = 
            new BinaryExpression("<", lhsexpr, sze); 
          Expression rel2 = 
            new BinaryExpression("<=", zeroExpression, lhsexpr); 
          rel1.setBrackets(true); 
          rel2.setBrackets(true); 
          Expression res = 
            new BinaryExpression("&", rel1, rel2); 
          res.setBrackets(true);
          res.setType(new Type("boolean", null)); 
         
          return res;   
        }    
        else // object
        { // lrng->oclType().getFields()
          UnaryExpression rngtype = 
            new UnaryExpression("->oclType", rhsexpr); 
          Expression lrng = 
            BasicExpression.newCallBasicExpression(
                                       "getFields",rngtype);  
          BinaryExpression inobjexpr = 
            new BinaryExpression("->includes", lrng, lhsexpr);
          inobjexpr.setType(new Type("boolean", null)); 
          return inobjexpr; 
        } 
      } 

      if (terms.size() == 3 && 
          "instanceof".equals(terms.get(1) + "")) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression("->oclIsKindOf",lhsexpr,rhsexpr); 
        expr.setType(new Type("boolean", null)); 
        return expr; 
      } 

      if (terms.size() == 3 && 
           ("<".equals(terms.get(1) + "") ||
            "<=".equals(terms.get(1) + "") ||
            ">".equals(terms.get(1) + "") ||
            ">=".equals(terms.get(1) + "") ) ) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        String op = "" + terms.get(1); 
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression expr = 
          new BinaryExpression(op,lhsexpr,rhsexpr); 
        expr.setType(new Type("boolean", null)); 
        return expr; 
      }

      if (terms.size() == 3 && 
          "<<".equals(terms.get(1) + ""))
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, rhsexpr); 
        twopow.setBrackets(true); 
        Expression expr = 
              new BinaryExpression("*", 
                           lhsexpr, twopow);
        expr.setType(new Type("long", null)); 
        return expr; 
      }

      if (terms.size() == 3 && 
          (">>".equals(terms.get(1) + "") || 
           ">>>".equals(terms.get(1) + "") ) )
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, rhsexpr); 
        twopow.setBrackets(true); 
        Expression expr = 
              new BinaryExpression("/", 
                           lhsexpr, twopow);
        expr.setType(new Type("long", null)); 
        return expr; 
      }

      if (terms.size() == 3 && 
          "??".equals(terms.get(1) + ""))
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        UnaryExpression isundefined = 
           new UnaryExpression("->oclIsUndefined", lhsexpr);
        isundefined.setType(new Type("boolean",null));  
        ConditionalExpression expr = 
              new ConditionalExpression(isundefined, 
                    rhsexpr, lhsexpr); 
        Type tt = 
          Expression.deduceType("?",lhsexpr,rhsexpr); 
        expr.setType(tt); 
        return expr; 
      }

      if (terms.size() == 3 && 
           ("+".equals(terms.get(1) + "") ||
            "*".equals(terms.get(1) + "") ||
            "/".equals(terms.get(1) + "") ||
            "-".equals(terms.get(1) + "") ||
            "%".equals(terms.get(1) + "") || 
            "**".equals(terms.get(1) + "") ) ) 
      { ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        String op = "" + terms.get(1); 
        Expression lhsexpr = e1.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        Expression rhsexpr = e2.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        String oper = op; 
        if ("%".equals(op))
        { oper = "mod"; } 
        else if ("**".equals(op))
        { oper = "->pow"; } 

        Expression expr = 
          new BinaryExpression(oper,lhsexpr,rhsexpr); 
        Type tt = 
          Expression.deduceType(oper,lhsexpr,rhsexpr); 
        expr.setType(tt); 
        System.out.println(">> Type of " + expr + " inferred as " + tt); 
        return expr; 
      }

      if (terms.size() == 5 && "?".equals(terms.get(1) + "") &&
          ":".equals(terms.get(3) + ""))
      { // Conditional
        ASTTerm test = (ASTTerm) terms.get(0); 
        Expression testexpr = test.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities); 
        ASTTerm lhs = (ASTTerm) terms.get(2); 
        Expression lhsexpr = lhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        ASTTerm rhs = (ASTTerm) terms.get(4); 
        Expression rhsexpr = rhs.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
        ConditionalExpression cond = 
          new ConditionalExpression(testexpr,lhsexpr,rhsexpr); 
        Type tt = 
          Expression.deduceType("?",lhsexpr,rhsexpr); 
        cond.setType(tt); 
        return cond; 
      } 
    } 

    
    if ("variableDeclarationList".equals(tag) && 
        terms.size() > 1)
    { 
      ASTTerm mod = (ASTTerm) terms.get(0);
      String mods = mod.literalForm(); 
      // var, let or const
      ASTTerm vbl = (ASTTerm) terms.get(1);
      return vbl.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities);
    }

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 3 && 
        "=".equals(terms.get(1) + ""))
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      Expression expr = lhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities); 
      return expr; 
    } // get type from rhs

    if ("variableDeclaration".equals(tag) && 
        terms.size() == 1)
    { ASTTerm lhs = (ASTTerm) terms.get(0); 
      return lhs.jsexpressionToKM3(vartypes,
                              varelemtypes,types,entities);
    } 

    if ("objectLiteral".equals(tag))
    { // JSON object literal -- 
      // create a map

      if (terms.size() == 2 && "{".equals(firstTerm + "") &&
                             "}".equals(lastTerm + ""))
      { // empty map 
        Expression expr = SetExpression.newMapSetExpression(); 
        return expr; 
      } 

      if (terms.size() > 2 && "{".equals(firstTerm + "") &&
                             "}".equals(lastTerm + ""))
      { // non-empty map 
        SetExpression expr = SetExpression.newMapSetExpression();
        for (int i = 1; i < terms.size()-1; i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i);
          if (tt instanceof ASTSymbolTerm) 
          { continue; } 
 
          Expression ttmaplet = 
             tt.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
          expr.addElement(ttmaplet); // must be a maplet  x |-> y
        }
        // Deduce types
 
        return expr; 
      } 
    } 
 
    if ("arrayLiteral".equals(tag))
    { // JSON array literal -- 
      // create a sequence

      if (terms.size() == 2 && "[".equals(firstTerm + "") &&
                             "]".equals(lastTerm + ""))
      { // empty sequence 
        Expression expr = new SetExpression(true); 
        return expr; 
      } 

      if (terms.size() == 3 && "[".equals(firstTerm + "") &&
          "elementList".equals(terms.get(1) + "") && 
                             "]".equals(lastTerm + ""))
      { // empty sequence with grammar error
        Expression expr = new SetExpression(true); 
        return expr; 
      }

      if (terms.size() == 3 && "[".equals(firstTerm + "") &&
                             "]".equals(lastTerm + ""))
      { // non-empty sequence

        ASTCompositeTerm elems = (ASTCompositeTerm) terms.get(1); 
        Vector eterms = elems.getTerms(); 
        Expression expr = new SetExpression(true); 

        Vector listelems = new Vector(); 
        String prev = ""; 

        for (int i = 0; i < eterms.size(); i++) 
        { ASTTerm tt = (ASTTerm) eterms.get(i); 
          if (tt instanceof ASTSymbolTerm) 
          { String tsym = tt.literalForm(); 
            if (",".equals(prev) && 
                ",".equals(tsym))
            { // add a blank element
              listelems.add(new BasicExpression("null")); 
            } 
            prev = tsym; 
            continue; 
          } 
          else if (tt.arity() == 2 && 
                   "...".equals(tt.getTerm(0) + ""))
          { // interpolated sequence
            SetExpression before = 
              new SetExpression(listelems,true); 
            Expression sqelem = 
              tt.getTerm(1).jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
            expr = 
              new BinaryExpression("^",before,sqelem); 
            prev = ""; 
            listelems = new Vector(); 
            continue; 
          } 

          Expression ttelem = 
             tt.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
          listelems.add(ttelem);
          prev = "";  
        } 
        SetExpression expr1 = 
          new SetExpression(listelems,true);

        if (expr instanceof SetExpression && 
            ((SetExpression) expr).isEmpty())
        { expr = expr1; } 
        else 
        { Type oldtype = expr.getType(); 
          Type oldelemtype = expr.getElementType(); 
          expr = new BinaryExpression("^", expr, expr1); 
          expr.setType(oldtype); 
        }

        System.out.println(">>> Sequence " + expr + " with type " + expr.getType()); 

        return expr; 
      } 
    }

    if ("propertyAssignment".equals(tag) && 
        terms.size() == 3 && 
        ":".equals(terms.get(1) + ""))
    { Expression ttlhs = 
             firstTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      Expression lhsx = 
        Expression.convertToString(ttlhs);     
      Expression ttrhs = 
             lastTerm.jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      BinaryExpression res = 
             new BinaryExpression("|->", lhsx, ttrhs); 
      return res; 
    } 

    if ("propertyName".equals(tag) && 
        terms.size() == 3 && 
        "[".equals(terms.get(0) + "") &&
        "]".equals(terms.get(2) + ""))
    { Expression ttlhs = 
        ((ASTTerm) terms.get(1)).jsexpressionToKM3(vartypes,
                                varelemtypes,types,entities);
      ttlhs.setBrackets(true);      
      Expression lhsx = 
        new BinaryExpression("+", ttlhs, emptyString);
      lhsx.setBrackets(true);
      lhsx.setType(new Type("String", null));       
      return lhsx; 
    } 

    if ("anonymousFunction".equals(tag) &&
        "function".equals(firstTerm + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "") && 
        terms.size() >= 5)
    { ASTTerm args = (ASTTerm) terms.get(2); 
      ASTTerm body = (ASTTerm) terms.get(4); 

      Vector fpars = new Vector(); 
      Vector parterms = args.getTerms(); 
      for (int i = 0; i < parterms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) parterms.get(i);
        
        if (vbl instanceof ASTSymbolTerm) { } 
        else  
        { 
          Vector fpar = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          fpars.addAll(fpar);
        } 
      }
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);

      String fname = Identifier.nextIdentifier("func_"); 

      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      Type ftype = bf.getFunctionType(); 
      vartypes.put(fname,ftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      Entity fjs = ASTTerm.currentClass; 
      if (fjs == null) 
      { fjs = (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);
      } 

      BehaviouralFeature oper = null; 

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { oper = fjs.getIdenticalOperation(bf.getActivity());
        if (oper == null) 
        { fjs.addOperation(bf); 
          bf.setOwner(fjs);
          oper = bf; 
        }  
        selfexpr.setType(new Type(fjs)); 
      } 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    oper,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, oper); 
      return res;  
    } 

    if ("anonymousFunction".equals(tag) &&
        "function".equals(firstTerm + "") && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(2) + "") && 
        terms.size() >= 4)
    { ASTTerm body = (ASTTerm) terms.get(3); 

      Vector fpars = new Vector(); 
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);

      String fname = Identifier.nextIdentifier("func_"); 

      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      Type ftype = bf.getFunctionType(); 
      vartypes.put(fname,ftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      Entity fjs = ASTTerm.currentClass; 
      if (fjs == null) 
      { fjs = (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);
      } 

      BehaviouralFeature oper = null; 

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { oper = fjs.getIdenticalOperation(bf.getActivity());
        if (oper == null) 
        { fjs.addOperation(bf); 
          bf.setOwner(fjs);
          oper = bf; 
        } 
        selfexpr.setType(new Type(fjs)); 
      } 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    oper,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(
                                    bfcall, oper); 
      return res;  
    } 


    if ("anonymousFunction".equals(tag) &&
        "=>".equals(terms.get(1) + "") &&  
        terms.size() == 3)
    { ASTTerm args = (ASTTerm) terms.get(0); 
      ASTTerm body = (ASTTerm) terms.get(2); 

      Vector fpars = new Vector(); 
      Vector parterms = args.getTerms(); 
      for (int i = 0; i < parterms.size(); i++) 
      { ASTTerm vbl = (ASTTerm) parterms.get(i);
        
        if (vbl instanceof ASTSymbolTerm) { } 
        else  
        { 
          Vector fpar = vbl.jsvariableDeclarationToKM3(
                             vartypes,
                             varelemtypes,types,
                             entities);
          fpars.addAll(fpar);
        } 
      }
  
      Vector stats = body.jsstatementToKM3(vartypes,
                             varelemtypes,types,
                             entities);

      String fname = Identifier.nextIdentifier("func_"); 

      BehaviouralFeature bf = 
        new BehaviouralFeature(fname,fpars,stats); 

      Vector retvals = 
         Statement.getReturnValues(bf.getActivity()); 

      System.out.println(">> Return values: " + retvals); 

      if (retvals != null && retvals.size() > 0)
      { Type retType = Type.determineType(retvals); 
        bf.setType(retType);
        Type retElemType = Type.determineElementType(retvals); 
        bf.setElementType(retElemType); 
      } 
      else 
      { bf.setReturnType(new Type("void", null)); }
 
      // deduce return type from stat 
      bf.setPost(trueExpression); 
      Type ftype = bf.getFunctionType(); 
      vartypes.put(fname,ftype); 
      varelemtypes.put(fname,bf.getReturnType()); 

      Entity fjs = 
        (Entity) ModelElement.lookupByName(
                           "FromJavaScript", entities);

      BasicExpression selfexpr = new BasicExpression("self"); 
      if (fjs != null) 
      { fjs.addOperation(bf); 
        bf.setOwner(fjs); 
        selfexpr.setType(new Type(fjs)); 
      } 

      Expression bfcall = 
        BasicExpression.newQueryCallBasicExpression(
                                    bf,selfexpr,fpars); 
      Expression res = 
        UnaryExpression.newLambdaUnaryExpression(bfcall, bf); 
      return res;  
    } 

    return null; 
  } 


  /* Java abstraction: */ 

  public boolean isAssignment()
  { if ("expression".equals(tag) && terms.size() == 3)
    { ASTTerm op = (ASTTerm) terms.get(1);
      if ("=".equals(op))
      { return true; }  
    }
    return false;
  } 

  public boolean isCreation()
  { if ("expression".equals(tag) && terms.size() >= 2 && 
        "new".equals(terms.get(0) + ""))
    { return true; }  
    
    return false;
  } 

  public String toKM3Assignment()
  { if (terms.size() == 3) // BinaryExpression
    { ASTTerm op = (ASTTerm) terms.get(1); 
      ASTTerm e1 = (ASTTerm) terms.get(0);
      ASTTerm e2 = (ASTTerm) terms.get(2);
      String lhs = e1.queryForm(); 
      String rhs = e2.toKM3(); 
      if (e1.expression != null && e2.expression != null) 
      { statement = new AssignStatement(e1.expression, e2.expression); } 
      return lhs + " := " + rhs; 
    } 
    return toKM3(); 
  } 

  public String toKM3creation()
  { if ("expression".equals(tag) && terms.size() >= 2 && 
        "new".equals(terms.get(0) + ""))
    { ASTTerm cre = (ASTTerm) terms.get(1); 
      String res = cre.toKM3();
      expression = cre.expression; 
      statement = cre.statement;
      modelElements = cre.modelElements;  
      return res;  
    }  
    
    return toKM3();
  } 

  public String toKM3Test()
  { expression = new BasicExpression(true); 
    if (tag.equals("forControl") && terms.size() > 2)
    { String res = "true"; 

      if (";".equals(terms.get(0) + ""))
      { // no initialisation
        if (";".equals(terms.get(1) + ""))
        { // no test either
          return res; 
        } 
        else // test but no init
        { ASTTerm test = (ASTTerm) terms.get(1);
          res = test.toKM3();
          expression = test.expression; 
          return res;  
        }
      } 

      if (";".equals(terms.get(2) + ""))
      { // for (init;;inc?)
        return res; 
      } 

      ASTTerm testf = (ASTTerm) terms.get(2); // normal for
          
      res = testf.toKM3();
      expression = testf.expression; 
      return res;  
    } 
    else if (tag.equals("forControl") && terms.size() == 2) 
    { String res = "true"; 
      return res; 
    } 

    ASTTerm test = (ASTTerm) terms.get(0);
    String res = test.toKM3();
    expression = test.expression; 
    statement = test.statement; 
    return res;  
  } 

  public ASTTerm forTest()
  { if (tag.equals("forControl") && terms.size() > 2)
    { 
      if (";".equals(terms.get(0) + ""))
      { // no initialisation
        if (";".equals(terms.get(1) + ""))
        { // no test either
          return new ASTBasicTerm("literal","true"); 
        } 
        else // test but no init
        { ASTTerm test = (ASTTerm) terms.get(1);
          return test;  
        }
      } 

      if (";".equals(terms.get(2) + ""))
      { // for (init;;inc?)
        return new ASTBasicTerm("literal","true");
      } 

      ASTTerm testf = (ASTTerm) terms.get(2); // normal for
          
      return testf;  
    } 
    else if (tag.equals("forControl") && terms.size() == 2) 
    { return new ASTBasicTerm("literal","true"); }
 
    ASTTerm test = (ASTTerm) terms.get(0);
    return test;  
  } 

  public String toKM3Init()
  { if (tag.equals("forControl"))
    { if (";".equals(terms.get(0) + ""))
      { return null; } // no init
      ASTCompositeTerm init = (ASTCompositeTerm) terms.get(0);
      return init.toKM3Init(); 
    } 
    else if (tag.equals("forInit"))
    { ASTTerm init = (ASTTerm) terms.get(0);
      return init.toKM3(); 
    }  
    return null; 
  } 

  public ASTTerm forInit()
  { if (tag.equals("forControl"))
    { if (";".equals(terms.get(0) + ""))
      { return null; } // no init
      ASTCompositeTerm init = (ASTCompositeTerm) terms.get(0);
      return init.forInit(); 
    } 
    else if (tag.equals("forInit"))
    { ASTTerm init = (ASTTerm) terms.get(0);
      return init; 
    }  
    return null; 
  } 

  public String toKM3Incr()
  { if (tag.equals("forControl") && terms.size() > 4)
    { // (forControl ini ; test ; incr )

      ASTTerm incr = (ASTTerm) terms.get(4);
      return incr.toKM3();
    } 

    if (";".equals(terms.get(0) + ""))
    { // no initialisation
      if (";".equals(terms.get(1) + ""))
      { // no test either
        if (terms.size() <= 2)
        { return ""; } 
        else 
        { ASTTerm incr = (ASTTerm) terms.get(2);
          return incr.toKM3(); 
        } 
      } 
      else // test but no init
      { // (forControl ; test ; ?)
        if (terms.size() > 3) 
        { ASTTerm incr = (ASTTerm) terms.get(3);
          return incr.toKM3(); 
        } 
        else 
        { return ""; }  
      }
    } 
  
    if (terms.size() > 2 && ";".equals(terms.get(2) + ""))
    { // (forControl init;;inc?)
      if (terms.size() > 3)
      { ASTTerm incr = (ASTTerm) terms.get(3);
        return incr.toKM3(); 
      } 
      return "";
    }
 
    return null;  
  } 

  public ASTTerm forIncr()
  { if (tag.equals("forControl") && terms.size() > 4)
    { ASTTerm incr = (ASTTerm) terms.get(4);
      return incr;
    } 

    if (tag.equals("forControl") && terms.size() > 3 && 
        ";".equals(terms.get(1) + "") && 
        ";".equals(terms.get(2) + ""))
    { ASTTerm incr = (ASTTerm) terms.get(3);
      return incr;
    }

    if (tag.equals("forControl") && terms.size() > 3 && 
        ";".equals(terms.get(0) + "") && 
        ";".equals(terms.get(2) + ""))
    { ASTTerm incr = (ASTTerm) terms.get(3);
      return incr;
    }

    if (tag.equals("forControl") && terms.size() > 2 && 
        ";".equals(terms.get(0) + "") && 
        ";".equals(terms.get(1) + ""))
    { ASTTerm incr = (ASTTerm) terms.get(2);
      return incr;
    }

    return null;  
  } 

  public boolean isEnhancedForControl()
  { if (tag.equals("forControl") && terms.size() > 0)
    { ASTTerm fc = (ASTTerm) terms.get(0);
      if (fc instanceof ASTCompositeTerm && 
          ((ASTCompositeTerm) fc).tag.equals("enhancedForControl"))
      { return true; }
    } 
    return false;  
  } 

  public String toKM3annotationConstantDeclarators()
  { modelElements = new Vector(); 
    String resx = ""; 

    if ("variableDeclarators".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTCompositeTerm vd = (ASTCompositeTerm) terms.get(i);
        resx = resx + vd.toKM3annotationConstantDeclarators(); 
        modelElement = vd.modelElement; 
        if (modelElement != null) 
        { modelElements.add(modelElement); } 
      } 
      return resx; 
    } 

    if ("variableDeclarator".equals(tag))
    { ASTTerm vd1 = (ASTTerm) terms.get(0);
      String vname = vd1.literalForm(); 
      Attribute att = new Attribute(vname, 
                                    new Type("OclAny", null), 
                                    ModelElement.INTERNAL);
      if (terms.size() > 2) 
      { ASTTerm expr = (ASTTerm) terms.get(2); 
        String res = expr.toKM3();
        expression = expr.expression;
        if (expression != null) 
        { att.setType(expression.getType()); 
          att.setInitialExpression(expression); 
        } 
      } 
      modelElement = att; 
      return "  attribute " + vname + " : " + att.getType() + ";\n"; 
    } 

    if ("constantDeclarator".equals(tag) && terms.size() > 1) 
    { // ID ([])* = value
      ASTTerm vd1 = (ASTTerm) terms.get(0);
      String vname = vd1.literalForm(); 
      Attribute att = new Attribute(vname, 
                                    new Type("OclAny", null), 
                                    ModelElement.INTERNAL);
      
      ASTTerm expr = (ASTTerm) terms.get(terms.size()-1); 
      String res = expr.toKM3();
      expression = expr.expression;
      if (expression != null) 
      { att.setType(expression.getType()); } 
       
      modelElement = att; 
      return "  attribute " + vname + " : " + att.getType() + ";\n";  
    } 

    return resx; 
  } 
    
  public String toKM3Var()
  { if ("variableDeclarators".equals(tag))
    { ASTCompositeTerm vd1 = (ASTCompositeTerm) terms.get(0);
      return vd1.toKM3Var();
    } // Process each one 

    if ("variableDeclarator".equals(tag) || 
        "constantDeclarator".equals(tag))
    { ASTTerm var = (ASTTerm) terms.get(0); 
      return var.toKM3(); 
    } 
    return null;  
  } 

  public String toKM3VarInit()
  { if ("variableDeclarators".equals(tag))
    { ASTCompositeTerm vd1 = (ASTCompositeTerm) terms.get(0);
      String res = vd1.toKM3VarInit();
      expression = vd1.expression; 
      statement = vd1.statement; 
      return res; 
    } 

    if ("variableDeclarator".equals(tag) && terms.size() > 2)
    { // (variableDeclaratorId x) = (variableInitializer expr)
      
      ASTTerm expr = (ASTTerm) terms.get(2); 
      String res = "";
      // String spre = expr.preSideEffect(); 
      // if (expr.statement == null) 
      { res = expr.toKM3(); 
        statement = expr.statement;
        expression = expr.expression;
      } 
      /* else 
      { SequenceStatement ss = new SequenceStatement(); 
        ss.addStatement(expr.statement); 
        res = expr.toKM3(); 
        ss.addStatement(expr.statement); 
        statement = ss; 
      }  */  
      return res;  
    } 

    if ("constantDeclarator".equals(tag) && terms.size() > 1) 
    { // ID ([])* = value
      ASTTerm expr = (ASTTerm) terms.get(terms.size()-1); 
      String res = expr.toKM3();
      expression = expr.expression;
      statement = expr.statement;  
      return res;  
    } 

    return null;  
  } // and recurse down the list of declarators

  public ASTTerm varInit()
  { if ("variableDeclarators".equals(tag))
    { ASTCompositeTerm vd1 = (ASTCompositeTerm) terms.get(0);
      return vd1.varInit();
    } 

    if ("variableDeclarator".equals(tag) && terms.size() > 2)
    { ASTTerm var = (ASTTerm) terms.get(2); 
      return var; 
    } 

    return null;  
  } // and recurse down the list of declarators

  public String getParNameList(ASTTerm t)
  { Vector pars = getParameterNames(t); 
    String res = ""; 
    for (int i = 0; i < pars.size(); i++) 
    { res = res + pars.get(i); 
      if (i < pars.size() - 1)
      { res = res + ", "; }
    } 
    return res; 
  } 

  public Vector getParameterNames(ASTTerm t) 
  { Vector res = new Vector(); 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if ("formalParameters".equals(tt.tag))
      { if (tt.terms.size() > 2)
        { ASTTerm fplist = (ASTTerm) tt.terms.get(1); 
          return getParameterNames(fplist); 
        } 
        return res; // empty parameter list 
      } 

      if ("formalParameterList".equals(tt.tag))
      { for (int i = 0; i < tt.terms.size(); i++) 
        { ASTTerm telem = (ASTTerm) tt.terms.get(i); 
          if (telem instanceof ASTSymbolTerm) { } 
          else 
          { res.add(getParameterName(telem)); } 
        } 
      } 
    } 
    return res; 
  } 

  public String getParameterName(ASTTerm t)
  { String res = ""; 
    if (t instanceof ASTCompositeTerm)
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if ("formalParameter".equals(tt.tag) || 
          "lastFormalParameter".equals(tt.tag))
      { int nTerms = tt.terms.size(); 
        ASTTerm varDec = (ASTTerm) tt.terms.get(nTerms - 1); 
        return varDec.toKM3(); 
      } 
    } 
    return res; 
  } 

  public static Vector getExpressions(Vector termList)
  { Vector res = new Vector(); 
    for (int i = 0; i < termList.size(); i++) 
    { ASTTerm trm = (ASTTerm) termList.get(i); 
      if (trm.expression != null) 
      { res.add(trm.expression); } 
    } 
    return res; 
  } 

  public Vector getCallArguments(ASTTerm t) 
  { Vector res = new Vector(); 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if ("arguments".equals(tt.tag) && tt.terms.size() > 2)
      { ASTTerm arg = (ASTTerm) tt.terms.get(1); 
        return getCallArguments(arg); 
      }
      else if ("expressionList".equals(tt.tag) )
      { for (int i = 0; i < tt.terms.size(); i++) 
        { ASTTerm telem = (ASTTerm) tt.terms.get(i); 
          if (telem instanceof ASTSymbolTerm) { } 
          else 
          { res.add(telem); } 
        } 
      } 
    } 
    return res; 
  } 

  public String getCallArgumentsTail(ASTTerm t) 
  { String res = ""; 
    if (t instanceof ASTCompositeTerm) 
    { ASTCompositeTerm tt = (ASTCompositeTerm) t; 
      if ("arguments".equals(tt.tag) && tt.terms.size() > 2)
	  { ASTTerm arg = (ASTTerm) tt.terms.get(1); 
	    return getCallArgumentsTail(arg); 
      }
	  else if ("expressionList".equals(tt.tag))
      { for (int i = 2; i < tt.terms.size(); i++) 
        { ASTTerm telem = (ASTTerm) tt.terms.get(i); 
          res = res + telem.toKM3();  
        } 
      } 
    } 
    return res; 
  } 

  public String queryForm()
  { // The return value of an updating operation 
    // such as pop, take, remove
    // Or value returned by a side-effecting expression; 
    // Side-effects are defined by preSideEffect, 
    // postSideEffect

    if ("methodCall".equals(tag) && terms.size() == 4)
    { // (methodCall met ( args ))
      ASTTerm met = (ASTTerm) terms.get(0); 
      ASTTerm arg1 = (ASTTerm) terms.get(2); 
      String methodt = met.literalForm(); 

      if ("parseInt".equals(methodt))
      { String res = arg1.queryForm(); 

        // JOptionPane.showInputDialog(">>> parseInt " + arg1.expression); 

        if (arg1.expression != null) 
        { arg1.expression.setBrackets(true); 
          expression = 
            new UnaryExpression("->toInteger", 
                                arg1.expression); 
          statement = null;   
          return "(" + res + ")->toInteger()"; 
        } 
      } 
    }

    if ("creator".equals(tag) || "innerCreator".equals(tag))
    { // 2 arguments, the type, and any constructor pars
      return creatorQueryForm(); 
    } 

    if ("createdName".equals(tag))
    { return creatorQueryForm(); } 
    // Ignores type parameters in creation. 

    if ("classCreatorRest".equals(tag))
    { return creatorQueryForm(); } 

    if ("enhancedForControl".equals(tag) && 
        terms.size() >= 4)
    { // mods type id : rng

      int sze = terms.size(); 

      ASTTerm typeTerm = (ASTTerm) terms.get(sze-4); 
      ASTTerm varTerm = (ASTTerm) terms.get(sze-3); 
      ASTTerm rangeTerm = (ASTTerm) terms.get(sze-1);
 
      // String km3type = typeTerm.toKM3(); 
      String km3var = varTerm.queryForm(); 
      String km3range = rangeTerm.queryForm(); 
      String res = km3var + " : " + km3range; 
      if (varTerm.expression != null && 
          rangeTerm.expression != null) 
      { expression = 
          new BinaryExpression(":", varTerm.expression, 
                               rangeTerm.expression);

        String retype = ASTTerm.getElementType(rangeTerm);  
        if (retype != null) 
        { ASTTerm.setType(varTerm, retype); }  
      } 

      // if (km3var != null) 
      // { res = res + " := " + km3init; }  
      return res; 
    }   

    if (terms.size() == 3 && ".".equals(terms.get(1) + "") &&
        "this".equals(terms.get(2) + ""))
    { // C.this |--> self->oclAsType(C)
      ASTTerm cterm = (ASTTerm) terms.get(0); 
      String cc = cterm.queryForm();
      ASTTerm.setType(this,cc); 
 
      if (cterm.expression != null) 
      { BasicExpression selfbe = 
          BasicExpression.newVariableBasicExpression(
                                           "_container"); 
        expression = new BinaryExpression(
                           "->oclAsType", selfbe, 
                           cterm.expression); 
        return "_container->oclAsType(" + cc + ")"; 
      }
      expression = 
         BasicExpression.newVariableBasicExpression("self"); 
      return "self"; 
    }   

    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { if (terms.size() == 3 && 
          "class".equals(((ASTTerm) terms.get(2)).literalForm()))
      { String args = ((ASTTerm) terms.get(0)).literalForm(); 
        String classcallres = "OclType[\"" + args + "\"]"; 
        Expression texpr = 
          BasicExpression.newTypeBasicExpression("OclType"); 
        expression = 
           BasicExpression.newIndexedBasicExpression(
                     texpr,
                     new BasicExpression("\"" + args + "\"")); 
        ASTTerm.setType(this, "OclType"); 
        return classcallres; 
      }  

      if (terms.size() == 3 && "(".equals(terms.get(0) + "") && 
          ")".equals(terms.get(2) + ""))  // ( t ) 
      { ASTTerm tt = (ASTTerm) terms.get(1); 
        String qf = tt.queryForm();
        ASTTerm.setType(this, ASTTerm.getType(tt)); 

        expression = tt.expression; 
        if (expression != null) 
        { expression.setBrackets(true); }   
        return qf; 
      } 

      if (terms.size() == 1) 
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        String qf = tt.queryForm();
        ASTTerm.setType(this, ASTTerm.getType(tt));
        expression = tt.expression; 
        return qf;  
      } 

      String res = ""; 

      for (int i = 0; i < terms.size(); i++) 
      { res = res + ((ASTTerm) terms.get(i)).queryForm(); }
 
      return res; 
    } 


    if ("expressionList".equals(tag))
    { Vector strs = new Vector(); 
      Vector exprs = new Vector(); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm telem = (ASTTerm) terms.get(i); 
        if (telem instanceof ASTSymbolTerm) { } 
        else 
        { strs.add(telem.toKM3()); 
          if (telem.expression != null) 
          { exprs.add(telem.expression); }
          statement = telem.statement; // Hack
        }  
      } 
     
      String res = "( "; 
      for (int i = 0; i < strs.size(); i++) 
      { res = res + strs.get(i); 
        if (i < strs.size()-1) 
        { res = res + ","; } 
      }
 
      if (exprs.size() == 1) 
      { expression = (Expression) exprs.get(0); 
        expression.setBrackets(true); 
      }

      return res + " )"; 
    } 
    
    if ("lambdaParameters".equals(tag))
    { if (terms.size() > 1)
      { ASTTerm par = (ASTTerm) terms.get(1); 
        String res = par.queryForm(); 
        expression = par.expression; 
        return res; 
      } // but could be several
    } 

    if ("lambdaExpression".equals(tag) && terms.size() > 2)
    { // (lambdaExpression (lambdaParameters ( pars )) -> 
      //    (lambdaBody (block { stats }))
      //  

      ASTTerm pars = (ASTTerm) terms.get(0); 
      String parString = pars.lambdaParametersToKM3(); 
      ASTTerm body = (ASTTerm) terms.get(2); 
      String bodyString = body.toKM3();

      System.out.println("*****************************");  

      System.out.println("*** Lambda expression with body " + 
                         body.expression + "/" + 
                         body.statement + " variables " + 
                         pars.modelElements); 
 
      System.out.println("*****************************");  
      
      if (body.expression != null) 
      { Type ltype = new Type("OclAny", null);  
        Expression letexp = 
          UnaryExpression.newLambdaUnaryExpression(
                  pars.modelElements, body.expression); 
        expression = letexp; 
        return letexp + ""; 
      } 

      if (body.statement != null) 
      { Type ltype = new Type("OclAny", null);
        Expression letexp = 
          UnaryExpression.newLambdaUnaryExpression(
            pars.modelElements, 
            body.statement, 
            ASTTerm.currentClass, 
            ASTTerm.enumtypes, ASTTerm.entities); 
        expression = letexp; 
        return letexp + ""; 
      } 

      return "lambda " + parString + " in " + bodyString; 
    }     

    if ("lambdaBody".equals(tag))
    { if (terms.size() > 1)
      { ASTTerm par = (ASTTerm) terms.get(1); 
        String res = par.queryForm(); 
        expression = par.expression; 
        return res; 
      } 
    } 

    if ("expression".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm expr = (ASTTerm) terms.get(0); 
        String qf = expr.queryForm();
        ASTTerm.setType(this, ASTTerm.getType(expr));
        expression = expr.expression; 
        return qf; 
      } 

      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        String op1 = op.toKM3(); 
        String arg1 = op.toKM3(); 
        String op1trim = op1.trim(); 

        String opx = op.queryForm(); 
        String argx = arg.queryForm(); 

        if ("new".equals(op + ""))
        { String res = argx; // arg.queryForm(); 
          ASTTerm.setType(this,ASTTerm.getType(arg));
          expression = arg.expression; 
          modelElements = arg.modelElements;

          // JOptionPane.showInputDialog(">>> " + expression + " for " + arg); 
 
          return res;  
        } 

        if ("-".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("-", arg.expression); 
          } 
          return "-" + arg1; 
        } 

        if ("+".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg));
          expression = arg.expression;  
          return arg1; 
        } 

        if ("!".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          if (arg.expression != null) 
          { arg.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("not", arg.expression); 
          } 
          return "not(" + arg1 + ")"; 
        } 

        if ("~".equals(op.literalForm()))
        { BinaryExpression addexpr = 
            new BinaryExpression("+", arg.expression, 
                                 unitExpression);
          addexpr.setBrackets(true); 
          expression = 
            new UnaryExpression("-", addexpr); 
          return "-(" + arg1 + " + 1)"; 
        } 

        if ("++".equals(op1trim))
        { expression = arg.expression; 
          ASTTerm.setType(this, ASTTerm.getType(arg));

          if (arg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression incr = new BinaryExpression("+", arg.expression, unit); 
            statement = new AssignStatement(arg.expression, incr); 
          } 

          System.out.println(">> Query form of " + this + " is: " + expression); 
          System.out.println(">> Update form of " + this + " is: " + statement); 

          return argx; 
        }
 
        if ("--".equals(op1trim))
        { expression = arg.expression; 
          ASTTerm.setType(this, ASTTerm.getType(arg));

          if (arg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            BinaryExpression incr = new BinaryExpression("-", arg.expression, unit); 
            statement = new AssignStatement(arg.expression, incr); 
          } 

          return argx; 
        }

        if ("++".equals(arg.literalForm()))
        { expression = op.expression; 
          ASTTerm.setType(this, ASTTerm.getType(op));

          if (op.expression != null) 
          { Expression unit = new BasicExpression(1); 
            BinaryExpression incr = new BinaryExpression("+", op.expression, unit); 
            statement = new AssignStatement(op.expression, incr); 
          } 

          System.out.println(">> Query form of " + this + " is: " + expression); 
          System.out.println(">> Update form of " + this + " is: " + statement); 

          return opx; 
        } 

        if ("--".equals(arg.literalForm()))
        { expression = op.expression; 
          ASTTerm.setType(this, ASTTerm.getType(op));

          if (op.expression != null) 
          { Expression unit = new BasicExpression(1); 
            BinaryExpression incr = new BinaryExpression("-", op.expression, unit); 
            statement = new AssignStatement(op.expression, incr); 
          } 

          return opx; 
        } 

        String km3 = opx + argx;

        if (arg.expression != null) 
        { expression = new UnaryExpression(opx.trim(), arg.expression); } 

        if (arg.statement != null) 
        { statement = arg.statement; } 


        System.out.println(">> Query form of " + this + " is: " + expression); 
        System.out.println(">> Update form of " + this + " is: " + statement); 
        System.out.println(); 

        return km3; 
      }  

      if (terms.size() > 2 && ".".equals(terms.get(1) + ""))
      { ASTTerm obj = (ASTTerm) terms.get(0); 
        ASTTerm call = (ASTTerm) terms.get(2); 
        return queryForm(obj,call); 
      } // method call query form

      if (terms.size() == 3) // binary expression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        String opx = op.toKM3(); 
        String e1x = e1.queryForm(); 
        String e2x = e2.queryForm();

        if ("=".equals(op + "") || "+=".equals(op + "") ||
            "-=".equals(op + "") || "*=".equals(op + "") ||
            "/=".equals(op + "") || "|=".equals(op + "") ||
            "&=".equals(op + "") || "^=".equals(op + "") ||
            "%=".equals(op + "") || "<<=".equals(op + "") ||
            ">>=".equals(op + "") || ">>>=".equals(op + ""))
        { expression = e1.expression;
          ASTTerm.setType(this, ASTTerm.getType(e1));
           
          return e1x; 
        } // similarly for other assignements. 

        if ("&".equals(op + "") && e1.isInteger() && 
            e2.isInteger())
        { ASTTerm.setType(this, "int");
          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseAnd", "MathLib", parms); 
          } 

          return "MathLib.bitwiseAnd(" + e1x + ", " + e2x + ")"; 
        } 

        if ("|".equals(op + "") && 
            (e1.isInteger() || 
             e2.isInteger()))
        { ASTTerm.setType(this, "int");

          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseOr", "MathLib", parms); 
          } 

          return "MathLib.bitwiseOr(" + e1x + ", " + e2x + ")"; 
        } 

        if ("^".equals(op + "") && 
            (e1.isInteger() || 
             e2.isInteger()))
        { ASTTerm.setType(this, "int");

          // JOptionPane.showInputDialog("bitwiseOr for " + e1 + " " + e2); 

          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseXor", "MathLib", parms); 
          } 

          return "MathLib.bitwiseXor(" + e1x + ", " + e2x + ")"; 
        } 

        if (e1.expression != null && e2.expression != null) 
        { expression = new BinaryExpression(opx.trim(), 
                             e1.expression, e2.expression);
        }

        if ("!=".equals(op + "") || "==".equals(op + "") || 
            "<=".equals(op + "") || ">=".equals(op + "") ||
            "&&".equals(op + "") || "||".equals(op + "") ||
            "<".equals(op + "") || ">".equals(op + ""))
        { ASTTerm.setType(this, "boolean"); 
          if (expression != null) 
          { expression.setType(new Type("boolean", null)); } 
        } 

        return e1x + opx + e2x; 
      } 
        
      if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm cast = (ASTTerm) terms.get(1); 
        ASTTerm call = (ASTTerm) terms.get(3);

        String ct = cast.toKM3();  
        String qf = call.queryForm(); 

        ASTTerm.setType(this, ct); 

        if ("String".equals(ASTTerm.getType(call)) && 
            ("int".equals(ct) || "long".equals(ct) ||
             "short".equals(ct) || "byte".equals(ct))
           )
        { if (call.expression != null)
          { call.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->char2byte", 
                                  call.expression); 
          }
          return "(" + qf + ")->char2byte()"; 
        }  

        if (call.expression != null && cast.expression != null)
        { call.expression.setBrackets(true); 
          expression = 
            new BinaryExpression("->oclAsType", call.expression, cast.expression); 
        } 

        return "(" + qf + ")->oclAsType(" + ct + ")"; 
      } 

      if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        String elemType = ASTTerm.getElementType(arr); 
        ASTTerm.setType(this, elemType); 

        // JOptionPane.showInputDialog(">>>--->>> element type of " + this + " is " + elemType); 
        System.out.println(); 

        String arrx = arr.queryForm(); 
        String indx = ind.queryForm(); 

        if (arr.expression != null && 
            ind.expression != null)
        { BasicExpression unit = new BasicExpression(1); 
          Expression inde = 
            new BinaryExpression("+", ind.expression, unit);  

          expression = 
             BasicExpression.newIndexedBasicExpression(
                                     arr.expression, inde); 
        } 

        return arrx + "[" + indx + " + 1]";
      } 

      if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        String condx = cond.queryForm(); 
        String ifx = ifoption.queryForm(); 
        String elsex = elseoption.queryForm();
        ASTTerm.setType(this, ASTTerm.getType(ifoption)); 
          
        if (cond.expression != null && 
            ifoption.expression != null && 
            elseoption.expression != null) 
        { expression = 
            new ConditionalExpression(cond.expression,
                  ifoption.expression, 
                  elseoption.expression); 
        } 
 
        return "if " + condx + " then " + ifx + " else " + elsex + " endif"; 
      } 

    } 

    return toKM3(); 
  } 

  public String queryForm(ASTTerm arg, ASTTerm call)
  { // arg . call

    System.out.println(">> Method call query form " + arg + "." + call); 

    String args = arg.queryForm(); 
    String calls = call.toKM3();

    if ("class".equals(calls))
    { String res = "OclType[\"" + args + "\"]"; 
      Expression texpr = 
        BasicExpression.newTypeBasicExpression("OclType"); 
      expression = BasicExpression.newIndexedBasicExpression(
                     texpr,
                     new BasicExpression("\"" + args + "\"")); 
      ASTTerm.setType(this, "OclType"); 
      return res; 
    }  
        
    if (call instanceof ASTCompositeTerm)
    { ASTCompositeTerm callterm = (ASTCompositeTerm) call; 
      if (callterm.tag.equals("methodCall") ||
          callterm.tag.equals(
              "explicitGenericInvocationSuffix"))
      { Vector callterms = callterm.terms; 
        String called = callterms.get(0) + "";
        ASTTerm callargs; 
		
        if (callterm.tag.equals(
             "explicitGenericInvocationSuffix"))
        { callargs = (ASTTerm) callterms.get(1); } 
        else 
        { callargs = (ASTTerm) callterms.get(2); }
		
        Vector cargs = getCallArguments(callargs); 
        String thisliteral = this.literalForm(); 
        
        if ("Files".equals(args))
        { return filesQueryFormKM3(called,cargs,arg,call, args,calls); } 
  
        if ("Paths".equals(args))
        { return pathsQueryFormKM3(called,cargs,arg,call, args,calls); }

        if ("System".equals(args) && "out".equals(calls))
        { ASTTerm.setType(thisliteral,"OclFile");  
          Entity ocltypeent = new Entity("OclFile"); 
          Type ocltype = new Type(ocltypeent); 
          expression = new BasicExpression(ocltype); 
          expression.setUmlKind(Expression.CLASSID);
          BasicExpression sysfile = new BasicExpression("\"System.out\""); 
          sysfile.setType(new Type("String", null)); 
 
          ((BasicExpression) expression).setArrayIndex(sysfile); 
          
          return "OclFile[\"System.out\"]"; 
        } 
        else if ("System".equals(args) && "in".equals(calls))
        { ASTTerm.setType(thisliteral,"OclFile");  
          Entity ocltypeent = new Entity("OclFile"); 
          Type ocltype = new Type(ocltypeent); 
          expression = new BasicExpression(ocltype); 
          expression.setUmlKind(Expression.CLASSID);
          BasicExpression sysfile = new BasicExpression("\"System.in\""); 
          sysfile.setType(new Type("String", null)); 
 
          ((BasicExpression) expression).setArrayIndex(sysfile); 
          return "OclFile[\"System.in\"]"; 
        } 
        else if ("System".equals(args) && "err".equals(calls))
        { ASTTerm.setType(thisliteral,"OclFile");  
          Entity ocltypeent = new Entity("OclFile"); 
          Type ocltype = new Type(ocltypeent); 
          expression = new BasicExpression(ocltype); 
          expression.setUmlKind(Expression.CLASSID);
          BasicExpression sysfile = new BasicExpression("\"System.err\""); 
          sysfile.setType(new Type("String", null)); 
 
          ((BasicExpression) expression).setArrayIndex(sysfile); 
          return "OclFile[\"System.err\"]"; 
        } 

        if ("pop".equals(called) || "take".equals(called) || 
            "pollLast".equals(called) ||
            "removeLast".equals(called))
        { // _1 = _2.pop(); is 
          // _1 := _2->last() ; _2 := _2->front()

          String elemT = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemT); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->last", arg.expression); } 

          return args + "->last()";   
        }
        else if ("poll".equals(called) && 
                 arg.isSortedSequence())
        { // _1 = _2.poll(); is 
          // _1 := _2->min() PriorityQueue: SortedSequence

          String elemT = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemT); 

          if (arg.expression != null) 
          { expression = 
               new UnaryExpression("->min", arg.expression);
          } 

          return args + "->min()";   
        }
        else if ("poll".equals(called) ||    
            "pollFirst".equals(called) ||
            "removeFirst".equals(called))
        { // _1 = _2.poll(); is 
          // _1 := _2->first() ; _2 := _2->tail()

          String elemT = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemT); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->first", arg.expression); } 

          return args + "->first()";   
        }
        else if ("put".equals(called) && arg.isMap() &&
                 cargs.size() >= 1)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = new BinaryExpression("->at", arg.expression, callarg1.expression); } 
           
          return args + "->at(" + callp1 + ")";
        }
        else if (("add".equals(called) || 
                  "offerFirst".equals(called) ||
                  "offerLast".equals(called)) && 
                 arg.isCollection() && 
                 cargs.size() >= 1)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, "boolean"); 

          if (arg.isSet())
          { if (arg.expression != null && 
              callarg1.expression != null) 
            { expression = 
                new BinaryExpression("->excludes",
                      arg.expression, callarg1.expression); 
            } 
            return args + "->excludes(" + callp1 + ")"; 
          } 
          else 
          { expression = new BasicExpression(true); 
            return "true"; 
          } // sequences always change - 
            // unless a capacity limit
        }
        else if ("append".equals(called) && arg.isString())
        { String callp = callargs.toKM3(); 

          ASTTerm.setType(this, "String"); 

          if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (callarg1.isStringSequence())
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { Expression ue = 
                  new UnaryExpression("->sum", callarg1.expression);  
                expression = new BinaryExpression("+", arg.expression, ue); 
                expression.setBrackets(true); 
              } 
              return "(" + args + " + " + callp1 + "->sum())"; 
            }   

            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                 new BinaryExpression("+", 
                       arg.expression, callarg1.expression); 
              expression.setBrackets(true); 
            } 

            return "(" + args + " + (\"\" + " + callp1 + "))"; 
          } 
          else if (cargs.size() == 3) 
          { // subrange of first argument
            ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null &&  
                callarg2.expression != null &&  
                callarg3.expression != null)
            { BasicExpression unit = new BasicExpression(1);
              Expression sum1 = new BinaryExpression("+", callarg2.expression, unit);  
              Expression sum23 = new BinaryExpression("+", callarg2.expression, callarg3.expression);
              Vector parms = new Vector(); 
              parms.add(sum1); parms.add(sum23); 
              Expression subr = BasicExpression.newFunctionBasicExpression("subrange", callarg1.expression, parms); 
              Expression ue = new UnaryExpression("->sum", subr); 
              expression = new BinaryExpression("+", arg.expression, ue); 
              expression.setBrackets(true); 
            } 
                
            return "(" + args + " + " + callp1 + ".subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ")->sum())"; 
          }   
        }
        else if ("insert".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          String callp = getCallArgumentsTail(callargs); 

          ASTTerm.setType(this, "String"); 

          if (cargs.size() == 2)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            
            if (arg.expression != null && 
                callarg1.expression != null &&  
                callarg2.expression != null)
            { BasicExpression unit = new BasicExpression(1);
              Expression sum1 = new BinaryExpression("+", callarg1.expression, unit);
              Vector parms = new Vector(); 
              parms.add(sum1); 
              parms.add(callarg2.expression); 
              expression = BasicExpression.newFunctionBasicExpression("insertAt", arg.expression, parms); 
            }    
            return args + ".insertAt(" + callp1 + " +1, \"\" + " + callp2 + ")"; 
          } 
          else if (cargs.size() == 4)
          { // subrange of 2nd argument
            ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 
            ASTTerm callarg4 = (ASTTerm) cargs.get(3);
            String callp4 = callarg4.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null &&  
                callarg2.expression != null && 
                callarg3.expression != null && 
                callarg4.expression != null)
            { BasicExpression unit = new BasicExpression(1);
              Expression sum1 = new BinaryExpression("+", callarg1.expression, unit);

              Vector subpars = new Vector(); 
              subpars.add(
                new BinaryExpression("+", callarg3.expression,
                                     unitExpression)); 
              subpars.add(
                new BinaryExpression("+", callarg3.expression,
                                     callarg4.expression)); 

              Expression arg2subrange = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", callarg2.expression, subpars); 
              Vector parms = new Vector(); 
              parms.add(sum1); 
              UnaryExpression arg2subrangesum = 
                new UnaryExpression("->sum", arg2subrange); 
              parms.add(arg2subrangesum); 

              expression = BasicExpression.newFunctionBasicExpression("insertAt", arg.expression, parms); 
            }    

            return args + ".insertAt(" + callp1 + "+1, " + callp2 + ".subrange(" + callp3 + "+1, " + callp3 + "+" + callp4 + ")->sum())"; 
          }     
        }
        else if ("replace".equals(called) && arg.isString() && 
                 cargs.size() == 3)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          ASTTerm callarg3 = (ASTTerm) cargs.get(2);
          String callp3 = callarg3.toKM3(); 

          ASTTerm.setType(this, "String"); 
          
          return "(" + args + ".subrange(1," + callp1 + ") + " + args + ".subrange(" + callp2 + "+ 1)).insertAt(" + callp1 + " +1, " + callp3 + ")";  
        }
        else if ("addAll".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();

          ASTTerm.setType(this, "boolean");  

          if (arg.isSet())
          { if (arg.expression != null && 
                callarg1.expression != null) 
            { Expression incl = 
                new BinaryExpression("->includesAll", 
                                     arg.expression, 
                                     callarg1.expression); 
              expression = 
                new UnaryExpression("not", incl); 
            } 
            return "not(" + args + "->includesAll(" + callp1 + "))"; 
          } 
          else 
          { expression = new BasicExpression(true); 
            return "true"; 
          } // sequences always change
        }
        else if (arg.isSortedSequence() && 
                 "remove".equals(called) && 
                 cargs.size() > 1
                )
        { // arg.remove(x,n) is 
          // n > 0 & arg->includes(x)

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(this, "boolean");

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression isinExpr = 
              new BinaryExpression("->includes", arg.expression,
                                   callarg1.expression);
            Expression nonzero = 
              new BinaryExpression(">", callarg2.expression,
                                   zeroExpression);   
            nonzero.setBrackets(true); 
            expression = 
              new BinaryExpression("&", 
                                   isinExpr, nonzero); 
          }

          return args + "->includes(" + callp1 + ") & (" + callp2 + " > 0)"; 
        }   
        else if (( arg.isCollection() || arg.isMap() ) && 
                 ( "remove".equals(called) || 
                   "removeElement".equals(called) ) && 
                 cargs.size() >= 1
                )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType);  

          if (callarg1.isInteger())
          { if (arg.expression != null && 
                callarg1.expression != null) 
            { Expression incr = 
                new BinaryExpression("+", callarg1.expression,
                                     unitExpression);  
              expression = 
                new BinaryExpression("->at", 
                                     arg.expression, incr); 
            }
  
            return args + "->at(" + callp1 + "+1)"; 
          } 

          if (arg.isMap())
          { if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                new BinaryExpression("->at", 
                      arg.expression, callarg1.expression); 
            }  

            return args + "->at(" + callp1 + ")"; 
          }
 
          if (arg.expression != null && callarg1.expression != null) 
          { expression = new BinaryExpression("->includes", arg.expression, callarg1.expression); }  

          return args + "->includes(" + callp1 + ")"; 
        }
        else if (arg.isCollection() && 
                 ("removeFirstOccurrence".equals(called) ||
                  "removeLastOccurrence".equals(called)) && 
                 cargs.size() >= 1
                )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType);  
 
          if (arg.expression != null && callarg1.expression != null) 
          { expression = new BinaryExpression("->includes", arg.expression, callarg1.expression); }  

          return args + "->includes(" + callp1 + ")"; 
        }
        else if ("removeAll".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, "boolean"); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { BinaryExpression be = 
              new BinaryExpression("->intersection", 
                    arg.expression, callarg1.expression); 
            expression = new UnaryExpression("->notEmpty", be); 
          }  

          return args + "->intersection(" + callp1 + ")->notEmpty()"; 
        }
        else if ("retainAll".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, "boolean"); 

          if (arg.expression != null && callarg1.expression != null) 
          { BinaryExpression be = 
              new BinaryExpression("-", arg.expression, callarg1.expression); 
            be.setBrackets(true); 
            expression = new UnaryExpression("->notEmpty", be); 
          }  

          return "(" + args + " - " + callp1 + ")->notEmpty()"; 
        }
        else if ("removeFirst".equals(called) || 
                 "pollFirst".equals(called))
        { if (arg.expression != null) 
          { expression = new UnaryExpression("->first", arg.expression); }

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType); 

          return args + "->first()"; 
        }
        else if (("remove".equals(called) ||
                  "poll".equals(called)) && 
                 cargs.size() == 0 &&
                 arg.isSequence())
        { if (arg.expression != null) 
          { expression = new UnaryExpression("->first", arg.expression); }

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType); 

          return args + "->first()"; 
        }
        else if ("set".equals(called) && callterms.size() >= 3)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = new BinaryExpression("->at", 
                arg.expression, callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")"; 
        }
        else if ("delete".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, "String"); 
                      
          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression unit = new BasicExpression(1); 
              Vector pars = new Vector(); 
              pars.add(unit); 
              pars.add(callarg1.expression); 
              Expression sum1 = 
                 BasicExpression.newFunctionBasicExpression("subrange", arg.expression, pars);
              Expression incr = 
                new BinaryExpression("+", callarg2.expression, 
                                     unit);  
              Expression sum2 = 
                 BasicExpression.newFunctionBasicExpression("subrange", arg.expression, incr); 
              expression = 
                new BinaryExpression("+", sum1, sum2); 
            } 

            return args + ".subrange(1," + callp1 + ") + " + 
                   args + ".subrange(" + callp2 + "+1)";
          } 
        } 
        else if ("deleteCharAt".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          ASTTerm.setType(this, "String"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            BinaryExpression sum1 = 
              new BinaryExpression("+", callarg.expression, unit); 
            expression = 
              new BinaryExpression("->excludingAt", arg.expression, sum1); 
          } 

          return args + "->excludingAt(" + callp + " + 1)"; 
        } 
        else if ("reverse".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { expression = new UnaryExpression("->reverse", arg.expression); }

          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          return args + "->reverse()"; 
        }   
        else if ("clear".equals(called) && (arg.isCollection() ||
                                            arg.isMap()))
        { if (arg.expression != null) 
          { expression = 
              new BinaryExpression("->intersection", arg.expression, new SetExpression()); 
          }

          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          return args + "->intersection(Set{})"; 
        }   
        else if ("replaceAll".equals(called) && "Collections".equals(args) && cargs.size() == 3)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          ASTTerm callarg3 = (ASTTerm) cargs.get(2);
          String callp3 = callarg3.toKM3(); 

          ASTTerm.setType(this, "boolean"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = 
              new BinaryExpression("->includes", 
                                   callarg1.expression, 
                                   callarg2.expression); 
          } 
          
          return callp1 + "->includes(" + callp2 + ")";  
        }
        else 
        { return featureAccess(arg,call,args,calls); } 
      } // also: removeRange, removeElement
    }

    if (arg.expression != null && call.expression != null &&
        call.expression instanceof BasicExpression) 
    { expression = (BasicExpression) call.expression; 
      ((BasicExpression) expression).setObjectRef(arg.expression); 
    } // and parameters? 

    return args + "." + calls;  
  }  
  
  public String oclIteratorKM3(ASTTerm arg, ASTTerm call, 
                               String args, 
                               String called, Vector cargs, 
                               String calls)
  { // pre: arg.isOclIterator()

    String thisliteral = this.literalForm(); 

    if ("getMetaData".equals(called) && 
         arg.isOclIterator())
    { // metadata is the iterator itself

      expression = arg.expression;
      return args; 
    } 
    else if ("getBoolean".equals(called) && 
                 arg.isOclIterator() && 
                 cargs.size() > 0)
    { ASTTerm.setType(thisliteral,"boolean"); 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.isInteger())
      { Expression expr = 
          BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
        expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   booleanTypeExpression); 
        return args + ".getCurrentFieldByIndex(" + 
                                  callp1 + ")"; 
     } 

     if (arg.expression != null && 
              callarg1.expression != null) 
     { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
       Expression atexpression = 
              new BinaryExpression("->at",   
                    curr,  
                    callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   booleanTypeExpression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(boolean)"; 
        } // for OclIterator
        else if ("getObject".equals(called) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"OclAny"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { expression = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            return args + ".getCurrentFieldByIndex(" + 
                                  callp1 + ")"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            expression = 
              new BinaryExpression("->at",   
                    curr,  
                    callarg1.expression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")"; 
        } // for OclIterator
        else if (("getTimestamp".equals(called) ||
                  "getDate".equals(called)) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"OclDate"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 

          if (callarg1.isInteger())
          { expression = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(OclDate)"; 
          } 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            expression = 
              new BinaryExpression("->at",   
                    curr,  
                    callarg1.expression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(OclDate)"; 
        } // for OclIterator
        else if (("getInt".equals(called) || 
                  "getByte".equals(called) || 
                  "getShort".equals(called)) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"int"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
       
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   intTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(int)"; 
          } 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            Expression atexpression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   intTypeExpression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(int)"; 
        } // for OclIterator
        else if ("getLong".equals(called) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"long"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   longTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(long)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            expression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(long)"; 
        } // for OclIterator
        else if (("getBigDecimal".equals(called) || 
                  "getDouble".equals(called) || 
                  "getFloat".equals(called)) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"double"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   doubleTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(double)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            Expression atexpression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   doubleTypeExpression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(double)"; 
        } // for OclIterator
        else if ("getArray".equals(called) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"Sequence"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   sequenceTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(Sequence)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            Expression atexpression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   sequenceTypeExpression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(Sequence)"; 
        } // for OclIterator
        else if ("getBytes".equals(called) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"Sequence(int)"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   sequenceTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(Sequence)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            Expression atexpression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   sequenceTypeExpression); 
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(Sequence)"; 
        } // for OclIterator
        else if (("getString".equals(called) || 
                  "getNString".equals(called) || 
                  "getURL".equals(called)) && 
                 arg.isOclIterator())
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (callarg1.isInteger())
          { Expression expr = 
              BasicExpression.newCallBasicExpression(
                "getCurrentFieldByIndex", arg.expression,
                callarg1.expression); 
            expression = 
              new BinaryExpression("->oclAsType", 
                                   expr,
                                   stringTypeExpression); 
            return args + ".getCurrentFieldByIndex(" + 
                       callp1 + ")->oclAsType(String)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression); 
            Expression atexpression = 
              new BinaryExpression("->at", curr, 
                                   callarg1.expression);
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression,
                                   stringTypeExpression);  
          } 

          return args + ".getCurrent()->at(" + callp1 + ")->oclAsType(String)"; 
        } // for OclIterator
        else if ("absolute".equals(called) && 
                 arg.isOclIterator())
        { // same as setPosition(callarg1)

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "setPosition", arg.expression, 
                callarg1.expression);
            statement = 
              InvocationStatement.newInvocationStatement(curr,
                                          callarg1.expression);  
          } 
          return args + ".setPosition(" + callp1 + ")"; 
        } 
        else if ("relative".equals(called) && 
                 arg.isOclIterator())
        { // same as movePosition(callarg1)

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "movePosition", arg.expression, 
                callarg1.expression);
            statement = 
              InvocationStatement.newInvocationStatement(curr,
                                          callarg1.expression);  
          } 
          return args + ".movePosition(" + callp1 + ")"; 
        } 
        else if (("updateString".equals(called) || 
                  "updateInt".equals(called) ||
                  "updateBigDecimal".equals(called) ||
                  "updateDouble".equals(called) ||
                  "updateLong".equals(called) || 
                  "updateArray".equals(called) || 
                  "updateBoolean".equals(called) || 
                  "updateByte".equals(called) || 
                  "updateBytes".equals(called) || 
                  "updateDate".equals(called) || 
                  "updateFloat".equals(called) || 
                  "updateNString".equals(called) || 
                  "updateObject".equals(called) || 
                  "updateTime".equals(called) ||
                  "updateTimestamp".equals(called) ||  
                  "updateShort".equals(called) ||
                  "setString".equals(called) || 
                  "setInt".equals(called) ||
                  "setBigDecimal".equals(called) ||
                  "setDouble".equals(called) ||
                  "setLong".equals(called) || 
                  "setArray".equals(called) || 
                  "setBoolean".equals(called) || 
                  "setByte".equals(called) || 
                  "setBytes".equals(called) || 
                  "setDate".equals(called) || 
                  "setFloat".equals(called) || 
                  "setNString".equals(called) || 
                  "setObject".equals(called) || 
                  "setTime".equals(called) ||
                  "setTimestamp".equals(called) ||  
                  "setShort".equals(called)) && 
                 arg.isOclIterator() && 
                 cargs.size() >= 2)
        { // same as .getCurrent()[arg1] := arg2

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 

          if (callarg1.isInteger())
          { Vector setpars = new Vector(); 
            setpars.add(callarg1.expression); 
            setpars.add(callarg2.expression); 
    
            expression = 
              BasicExpression.newCallBasicExpression(
                "setCurrentFieldByIndex", arg.expression,
                setpars); 
            statement = 
              InvocationStatement.newInvocationStatement(
                      expression,setpars);  
            return args + ".setCurrentFieldByIndex(" + 
                                  callp1 + "," + callp2 + ")"; 
          } 
          
          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression);
            Expression upd = 
              BasicExpression.newIndexedBasicExpression(
                curr, callarg1.expression); 
            statement = 
              new AssignStatement(upd,callarg2.expression);  
          } 
          return args + ".getCurrent()[" + callp1 + "] := " + callp2 + ";\n"; 
        } 
        else if (("updateNull".equals(called) ||
                  "setNull".equals(called)) && 
                 arg.isOclIterator())
        { // same as .getCurrent()[arg1] := null

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3();
 
          if (callarg1.isInteger())
          { Vector setpars = new Vector(); 
            setpars.add(callarg1.expression); 
            setpars.add(nullExpression); 
    
            expression = 
              BasicExpression.newCallBasicExpression(
                "setCurrentFieldByIndex", arg.expression,
                setpars); 
            statement = 
              InvocationStatement.newInvocationStatement(
                      expression,setpars);  
            return args + ".setCurrentFieldByIndex(" + 
                                  callp1 + ",null)"; 
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression curr = 
              BasicExpression.newCallBasicExpression(
                "getCurrent", arg.expression);
            Expression upd = 
              BasicExpression.newIndexedBasicExpression(
                curr, callarg1.expression); 
            statement = 
              new AssignStatement(upd,nullExpression);  
          } 
          return args + ".getCurrent()[" + callp1 + "] := null;\n"; 
        } 
        else if ("deleteRow".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.delete()
          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "delete", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".delete()"; 
        }  
        else if ("afterLast".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToEnd()

          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "moveToEnd", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".moveToEnd()"; 
        }  
        else if ("moveToInsertRow".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToEnd()

          // But moveToInsertRow also memorises the 
          // current position & creates an empty map 
          // at the end position. 

          SequenceStatement statss = new SequenceStatement(); 

          if (arg.expression != null)
          { Expression expr1 = 
              BasicExpression.newCallBasicExpression(
                          "markPosition", arg.expression); 
            Statement stat1 = 
              InvocationStatement.newInvocationStatement(
                                                   expr1);
            Expression expr2 = 
              BasicExpression.newCallBasicExpression(
                          "moveToEnd", arg.expression); 
            Statement stat2 = 
              InvocationStatement.newInvocationStatement(
                                                   expr2); 

            Expression emptyMap = new SetExpression(false); 
            emptyMap.setType(new Type("Map", null)); 

            Expression expr3 = 
              BasicExpression.newCallBasicExpression(
                          "insert", arg.expression, emptyMap); 
            Statement stat3 = 
              InvocationStatement.newInvocationStatement(
                                              expr3,emptyMap); 
            statss.addStatement(stat1); 
            statss.addStatement(stat2); 
            statss.addStatement(stat3); 
          } 
          statement = statss; 

          return args + ".markPosition() ; " + args + ".moveToEnd() ; " + args + ".insert(Map{}) "; 
        }  
        else if ("moveToCurrentRow".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToMarkedPosition()

          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "moveToMarkedPosition", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".moveToMarkedPosition()"; 
        }  
        else if ("beforeFirst".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToStart()
          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "moveToStart", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".moveToStart()"; 
        }  
        else if ("last".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToLast()
          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "moveToLast", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".moveToLast()"; 
        }  
        else if ("first".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.moveToFirst()
          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "moveToFirst", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression); 
          } 
          return args + ".moveToFirst()"; 
        }  
        else if ("getRow".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.getPosition()
          ASTTerm.setType(this,"int"); 

          if (arg.expression != null)
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "getPosition", arg.expression); 
          } 
          return args + ".getPosition()"; 
        }  
        else if ("isFirst".equals(called) && 
                 arg.isOclIterator())
        { // same as 1 = arg.getPosition()
          ASTTerm.setType(this,"boolean"); 

          if (arg.expression != null)
          { Expression posexpr = 
              BasicExpression.newCallBasicExpression(
                 "getPosition", arg.expression);
            expression = 
              new BinaryExpression("=", unitExpression,
                                   posexpr); 
            expression.setBrackets(true);  
          } 
          return "(1 = " + args + ".getPosition())"; 
        }  
        else if ("isLast".equals(called) && 
                 arg.isOclIterator())
        { // same as arg.length() = arg.getPosition()
          ASTTerm.setType(this,"boolean"); 

          if (arg.expression != null)
          { Expression posexpr = 
              BasicExpression.newCallBasicExpression(
                 "getPosition", arg.expression);
            Expression lenexpr = 
              BasicExpression.newCallBasicExpression(
                 "length", arg.expression);
            expression = 
              new BinaryExpression("=", lenexpr,
                                   posexpr); 
            expression.setBrackets(true);  
          } 

          return "(" + args + ".length() = " + args + ".getPosition())"; 
        }  

    if (arg.expression != null && call.expression != null &&
        call.expression instanceof BasicExpression) 
    { expression = (BasicExpression) call.expression; 
      ((BasicExpression) expression).setObjectRef(arg.expression); 

      // Vector pars = new Vector(); 
      // for (int i = 0; i < cargs.size(); i++) 
      
    } 

        System.out.println(">>> internal method call: " + arg + "." + called + cargs); 

        Vector xpars = new Vector(); 
        for (int i = 0; i < cargs.size(); i++) 
        { ASTTerm cargi = (ASTTerm) cargs.get(i); 
          if (cargi.expression != null) 
          { xpars.add(cargi.expression); } 
        } 
          
        String cname = ASTTerm.getType(args); 
        if (cname != null) 
        { Entity cent = 
            (Entity) ModelElement.lookupByName(cname,ASTTerm.entities); 
          if (cent != null) 
          { cent.refineOperation(called,xpars); } 
        } 

        if (arg.expression != null) 
        { expression = BasicExpression.newCallBasicExpression(
                called, arg.expression, xpars); 
          ((BasicExpression) expression).setIsEvent();  
          statement = 
            InvocationStatement.newInvocationStatement(
                expression, xpars);  
              
          System.out.println(">>> internal method call: " + arg.expression + "." + called + xpars); 
          return args + "." + calls; 
        } 

    return args + "." + calls;  
  }  

  public String pathsQueryFormKM3(String called, Vector cargs, ASTTerm arg, ASTTerm call, String args, String calls)
  { // The return values

    if ("get".equals(called) && 
        cargs.size() >= 2)
    { // OclFile.newOclFile(cargs1 + cargs->collect(x | "/" + x)->sum())
      ASTTerm.setType(this, "OclFile"); 
    
      String callargsum = ""; 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3();
      callargsum = callp1;  
          
      if (callarg1.expression != null)    
      { expression = 
          callarg1.expression;
      } 

      for (int i = 1; i < cargs.size(); i++) 
      { ASTTerm ct = (ASTTerm) cargs.get(i); 
        String callpi = ct.toKM3();
        callargsum = callargsum + "/" + callpi;
        if (expression != null && ct.expression != null)    
        { Expression pathtail = 
            new BinaryExpression("+", expression, 
                       new BasicExpression("\"/\"")); 
          expression = 
            new BinaryExpression("+", pathtail, 
                                 ct.expression);
        } 
      }
      
      expression = 
         BasicExpression.newStaticCallBasicExpression(
                            "newOclFile", "OclFile", 
                            expression);
        
      return "OclFile.newOclFile(" + callargsum + ")"; 
    } 

    if ("get".equals(called) && 
        cargs.size() == 1)
    { // OclFile.newOclFile(cargs1)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      expression = 
         BasicExpression.newStaticCallBasicExpression(
                            "newOclFile", "OclFile", 
                            callarg1.expression);
      return "OclFile.newOclFile(" + callp1 + ")"; 
    } 

    System.out.println(">>> internal method call: " + arg + "." + called + cargs); 

    Vector xpars = new Vector(); 
    for (int i = 0; i < cargs.size(); i++) 
    { ASTTerm cargi = (ASTTerm) cargs.get(i); 
      if (cargi.expression != null) 
          { xpars.add(cargi.expression); } 
        } 
          
        String cname = ASTTerm.getType(args); 
        if (cname != null) 
        { Entity cent = 
            (Entity) ModelElement.lookupByName(cname,ASTTerm.entities); 
          if (cent != null) 
          { cent.refineOperation(called,xpars); } 
        } 

        if (arg.expression != null) 
        { expression = BasicExpression.newCallBasicExpression(
                called, arg.expression, xpars); 
          ((BasicExpression) expression).setIsEvent();  
          statement = 
            InvocationStatement.newInvocationStatement(
                expression, xpars);  
              
          System.out.println(">>> internal method call: " + arg.expression + "." + called + xpars); 
          return args + "." + calls; 
        } 

    return ""; 
  } 

  public String filesQueryFormKM3(String called, Vector cargs, ASTTerm arg, ASTTerm call, String args, String calls)
  { // The return values

    if ("copy".equals(called) && 
        cargs.size() >= 2)
    { // OclFile.copyFromTo(cargs1,cargs2)
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { expression = 
          BasicExpression.newCallBasicExpression(
                                "length", 
                                callarg1.expression);
      } 

      return callp1 + ".length()"; 
    } // actually returns callp1.length() as a query

    if ("createDirectory".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).mkdir()
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      expression = 
          callarg1.expression; 

      return callp1; 
    } // actually returns callp1 as a query

    if ("createFile".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(carg1)
      ASTTerm.setType(this, "String"); 
    
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      expression = callarg1.expression; 

      return callp1; 
    } 

    if ("createTempDirectory".equals(called) && 
        cargs.size() == 2)
    { // OclFile.createTemporaryFile(carg1,"")
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      expression = callarg1.expression; 

      return callp1; 
    } 

    if ("createTempDirectory".equals(called) && 
        cargs.size() == 3)
    { // OclFile.createTemporaryFile(carg1/carg2,"")
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { Expression expr1 = 
          new BinaryExpression("+", callarg1.expression,
                               forwardSlash);
        expression =
          new BinaryExpression("+", expr1,
                               callarg2.expression);  
      } 

      return callp1 + "/" + callp2; 
    } 

    if ("createTempFile".equals(called) && 
        cargs.size() == 3)
    { // OclFile.createTemporaryFile(carg1,carg3)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg3 = (ASTTerm) cargs.get(1);
      String callp3 = callarg3.toKM3(); 
          
      if (callarg1.expression != null &&
          callarg3.expression != null)    
      { Expression expr1 = 
          new BinaryExpression("+", callarg1.expression,
            BasicExpression.newValueBasicExpression("\".\""));
        expression =
          new BinaryExpression("+", expr1,
                               callarg3.expression);  
      } 

      return callp1 + "." + callp3; 
    } 

    if ("createTempFile".equals(called) && 
        cargs.size() == 4)
    { // OclFile.createTemporaryFile(carg1/carg2,carg3)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
      ASTTerm callarg3 = (ASTTerm) cargs.get(2);
      String callp3 = callarg3.toKM3(); 
          
      if (callarg1.expression != null &&
          callarg2.expression != null &&
          callarg3.expression != null)    
      { Expression expr1 = 
          new BinaryExpression("+", callarg1.expression,
                               forwardSlash);
        Expression expr2 = 
          new BinaryExpression("+", expr1,
                               callarg2.expression); 
        Expression expr3 = 
          new BinaryExpression("+", expr2,
            BasicExpression.newValueBasicExpression("\".\""));
        expression = 
          new BinaryExpression("+", 
                         expr3, callarg3.expression);  
      } 

      return  callp1 + "/" + callp2 + "." + callp3; 
    } 

    if ("deleteIfExists".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.deleteFile(carg1)
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression test = 
          BasicExpression.newCallBasicExpression("exists",
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression));
        expression = 
          new ConditionalExpression(test,
                                 trueExpression, 
                                 falseExpression);  
      } 

      return "if OclFile.newOclFile(" + callp1 + ").exists() then true else false endif"; 
    } // no query form

    if ("exists".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).exists()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "exists", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").exists()"; 
    }

    if ("getFileStore".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).getParentFile()
      ASTTerm.setType(this, "OclFile"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "getParentFile", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").getParentFile()"; 
    }

    if ("getLastModifiedTime".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).lastModified()
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "lastModified", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").lastModified()"; 
    }

    if ("isDirectory".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isDirectory()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isDirectory", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isDirectory()"; 
    }

    if ("isHidden".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isHidden()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isHidden", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isHidden()"; 
    }

    if ("isOpen".equals(called))
    { // OclFile[cargs1] /= null & OclFile[cargs1].isOpen()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isOpen", 
                                fexpr); 
      } 

      return "(OclFile[" + callp1 + "] /= null & OclFile[" + callp1 + "].isOpen())"; 
    }

    if ("isReadable".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).canRead()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "canRead", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").canRead()"; 
    }

    if ("isRegularFile".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isFile()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isFile", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isFile()"; 
    }

    if ("isSameFile".equals(called) && 
        cargs.size() >= 2)
    { // (cargs1 = cargs2)
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { expression = 
          new BinaryExpression("=", 
                               callarg1.expression,
                               callarg2.expression);
        expression.setBrackets(true);  
      } 

      return "(" + callp1 + " = " + callp2 + ")"; 
    }

    if ("isWritable".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).canWrite()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "canWrite", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").canWrite()"; 
    }

    if (("lines".equals(called) || 
         "readAllLines".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readAll()->split("\n\r")
      ASTTerm.setType(this, "Sequence(String)"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "readAllLines", 
                                fexpr); 
        // expression = 
        //   new BinaryExpression("->split", expr1, 
        //     BasicExpression.newValueBasicExpression(
        //       "\"\n\r\"")); 

        Type stringSeq = new Type("Sequence", null); 
        stringSeq.setElementType(new Type("String", null)); 
        expression.setType(stringSeq); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").readAllLines()"; 
    }

    if ("readString".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readAll()
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Read", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "readAll", 
                                fexpr); 

        Type stringS = new Type("String", null); 
        stringS.setElementType(new Type("String", null)); 
        expression.setType(stringS); 
      } 

      return "OclFile.newOclFile_Read(" + callp1 + ").readAll()"; 
    }

    if (("list".equals(called) || 
         "newDirectoryStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).list()
    
      ASTTerm.setType(this, "Sequence(String)"); 

      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "list", 
                                fexpr); 
        Type stringSeq = new Type("Sequence", null); 
        stringSeq.setElementType(new Type("String", null)); 
        expression.setType(stringSeq); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").list()"; 
    }

    if ("move".equals(called) && 
        cargs.size() >= 2)
    { // carg2 
      
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      expression = callarg2.expression; 

      return callp2; 
    } 

    if (("newBufferedReader".equals(called) ||
         "newInputStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile_Read(OclFile.newOclFile(carg1) 
      ASTTerm.setType(this, "OclFile"); 
     
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Read", "OclFile", 
                                expr);
      } 

      return "OclFile.newOclFile_Read(OclFile.newOclFile(" + callp1 + "))"; 
    } 

    if (("newBufferedWriter".equals(called) || 
         "newByteChannel".equals(called) ||
         "newPrintWriter".equals(called) ||  
         "newOutputStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile_Write(OclFile.newOclFile(carg1) 
      ASTTerm.setType(this, "OclFile"); 
     
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Write", "OclFile", 
                                expr);
      } 

      return "OclFile.newOclFile_Write(OclFile.newOclFile(" + callp1 + "))"; 
    } 

    if ("notExists".equals(called) && 
        cargs.size() >= 1)
    { // not(OclFile.newOclFile(cargs1).exists())
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          new UnaryExpression("not", 
            BasicExpression.newCallBasicExpression(
                                "exists", 
                                fexpr)); 
      } 

      return "not(OclFile.newOclFile(" + callp1 + ").exists())"; 
    }

    if ("probeContentType".equals(called) && 
        cargs.size() >= 1)
    { // "text/plain"
      ASTTerm.setType(this, "String"); 
    
      expression = 
          BasicExpression.newValueBasicExpression(
                                "\"text/plain\""); 

      return "\"text/plain\""; 
    }

    if ("readAllBytes".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readNbytes(f.length())
      ASTTerm.setType(this, "Sequence(int)"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        Expression lexpr = 
          BasicExpression.newCallBasicExpression(
                                "length", fexpr);

        expression = 
          BasicExpression.newCallBasicExpression(
            "readNbytes", fexpr, lexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").readNbytes(OclFile.newOclFile(" + callp1 + ").length())"; 
    }

    if ("write".equals(called) && 
        cargs.size() >= 2)
    { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      expression = callarg1.expression; 

      return callp1; 
    }

    if ("size".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).length()
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "length", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").length()"; 
    }

    System.out.println(">>> internal method call: " + arg + "." + called + cargs); 

    Vector xpars = new Vector(); 
    for (int i = 0; i < cargs.size(); i++) 
    { ASTTerm cargi = (ASTTerm) cargs.get(i); 
      if (cargi.expression != null) 
          { xpars.add(cargi.expression); } 
        } 
          
        String cname = ASTTerm.getType(args); 
        if (cname != null) 
        { Entity cent = 
            (Entity) ModelElement.lookupByName(cname,ASTTerm.entities); 
          if (cent != null) 
          { cent.refineOperation(called,xpars); } 
        } 

        if (arg.expression != null) 
        { expression = BasicExpression.newCallBasicExpression(
                called, arg.expression, xpars); 
          ((BasicExpression) expression).setIsEvent();  
          statement = 
            InvocationStatement.newInvocationStatement(
                expression, xpars);  
              
          System.out.println(">>> internal method call: " + arg.expression + "." + called + xpars); 
          return args + "." + calls; 
        } 

    return ""; 
  }  

  public String pathsMethodCallFormKM3(String called, Vector cargs)
  { // The return values

    if ("get".equals(called) && 
        cargs.size() >= 2)
    { // OclFile.newOclFile(cargs1 + cargs->collect(x | "/" + x)->sum())
      ASTTerm.setType(this, "OclFile"); 
    
      String callargsum = ""; 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3();
      callargsum = callp1;  
          
      if (callarg1.expression != null)    
      { expression = 
          callarg1.expression;
      } 

      for (int i = 1; i < cargs.size(); i++) 
      { ASTTerm ct = (ASTTerm) cargs.get(i); 
        String callpi = ct.toKM3();
        callargsum = callargsum + "/" + callpi;
        if (expression != null && ct.expression != null)    
        { Expression pathtail = 
            new BinaryExpression("+", expression, 
                       new BasicExpression("\"/\"")); 
          expression = 
            new BinaryExpression("+", pathtail, 
                                 ct.expression);
        } 
      }
      
      expression = 
         BasicExpression.newStaticCallBasicExpression(
                            "newOclFile", "OclFile", 
                            expression);
        
      return "OclFile.newOclFile(" + callargsum + ")"; 
    } 

    if ("get".equals(called) && 
        cargs.size() == 1)
    { // OclFile.newOclFile(cargs1)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      expression = 
         BasicExpression.newStaticCallBasicExpression(
                            "newOclFile", "OclFile", 
                            callarg1.expression);
      return "OclFile.newOclFile(" + callp1 + ")"; 
    } 

    System.out.println(">>> internal method call: " + called + cargs); 

    return ""; 
  } 

  public String filesMethodCallFormKM3(String called, Vector cargs)
  { // update forms

    if ("copy".equals(called) && 
        cargs.size() >= 2)
    { // OclFile.copyFromTo(cargs1,cargs2)
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { Vector parsx = new Vector(); 
        parsx.add(callarg1.expression); 
        parsx.add(callarg2.expression); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "copyFromTo", "OclFile", 
                                parsx);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression,parsx);  
      } 

      return "OclFile.copyFromTo(" + callp1 + "," + callp2 + ")"; 
    } // actually returns callp1.length() as a query

    if (("createDirectory".equals(called) || 
         "createDirectories".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).mkdir()
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        if ("createDirectory".equals(called))
        { expression = 
            BasicExpression.newCallBasicExpression(
                                "mkdir", 
                                fexpr);
        } 
        else 
        { expression = 
            BasicExpression.newCallBasicExpression(
                                "mkdirs", 
                                fexpr);
        } 

        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression);  
      } 

      return "OclFile.newOclFile(" + callp1 + ").mkdir()"; 
    } // actually returns callp1 as a query

    if ("createFile".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(carg1)
      ASTTerm.setType(this, "String"); 
    
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 callarg1.expression);  
      } 

      return "OclFile.newOclFile(" + callp1 + ")"; 
    } // returns callp1

    if ("createTempDirectory".equals(called) && 
        cargs.size() == 2)
    { // OclFile.createTemporaryFile(carg1,"")
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Vector fpars = new Vector(); 
        fpars.add(callarg1.expression); 
        fpars.add(emptyString); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                   "createTemporaryFile", "OclFile", fpars);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 fpars);  
      } 

      return "OclFile.newTemporaryFile(" + callp1 + ", \"\")"; 
    } // returns callp1

    if ("createTempDirectory".equals(called) && 
        cargs.size() == 3)
    { // OclFile.createTemporaryFile(carg1/carg2,"")
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { Vector fpars = new Vector(); 
        Expression fname = 
          new BinaryExpression("+", 
                callarg1.expression, 
                forwardSlash);
        fname = 
          new BinaryExpression("+", 
                fname, callarg2.expression);
        fpars.add(fname); 
        fpars.add(emptyString); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                     "createTemporaryFile", "OclFile", fpars);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 fpars);  
      } 

      return "OclFile.newTemporaryFile(" + callp1 + "/" + callp2 + ", \"\")"; 
    } // returns callp1 + "/" + callp2

    if ("createTempFile".equals(called) && 
        cargs.size() == 3)
    { // OclFile.createTemporaryFile(carg1,carg3)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg3 = (ASTTerm) cargs.get(1);
      String callp3 = callarg3.toKM3(); 
          
      if (callarg1.expression != null &&
          callarg3.expression != null)    
      { Vector fpars = new Vector(); 
        fpars.add(callarg1.expression); 
        fpars.add(callarg3.expression); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                    "createTemporaryFile", "OclFile", fpars);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 fpars);  
      } 

      return "OclFile.newTemporaryFile(" + callp1 + "," + callp3 + ")"; 
    } // returns callp1 + "." + callp3

    if ("createTempFile".equals(called) && 
        cargs.size() == 4)
    { // OclFile.createTemporaryFile(carg1/carg2,carg3)
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
      ASTTerm callarg3 = (ASTTerm) cargs.get(2);
      String callp3 = callarg3.toKM3(); 
          
      if (callarg1.expression != null &&
          callarg2.expression != null &&
          callarg3.expression != null)    
      { Vector fpars = new Vector();
        Expression fname = 
          new BinaryExpression("+", 
                callarg1.expression, 
                forwardSlash);
        fname = 
          new BinaryExpression("+", 
                fname, callarg2.expression);
        fname.setType(new Type("String", null));   
        fpars.add(fname); 
        fpars.add(callarg3.expression); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                    "createTemporaryFile", "OclFile", fpars);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 fpars);  
      } 

      return "OclFile.newTemporaryFile(" + callp1 + "/" + callp2 + ", " + callp3 + ")"; 
    } // callp1 + "/" + callp2 + "." + callp3

    if (("delete".equals(called) || 
         "deleteIfExists".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.deleteFile(carg1)
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "deleteFile", "OclFile", 
                                callarg1.expression);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 callarg1.expression);  
      } 

      return "OclFile.deleteFile(" + callp1 + ")"; 
    } // no query form

    if ("exists".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).exists()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "exists", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").exists()"; 
    }

    if ("getFileStore".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).getParentFile()
      ASTTerm.setType(this, "OclFile"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "getParentFile", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").getParentFile()"; 
    }

    if ("getLastModifiedTime".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).lastModified()
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "lastModified", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").lastModified()"; 
    }

    if ("isDirectory".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isDirectory()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isDirectory", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isDirectory()"; 
    }

    if ("isHidden".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isHidden()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isHidden", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isHidden()"; 
    }

    if ("isReadable".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).canRead()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "canRead", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").canRead()"; 
    }

    if ("isRegularFile".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).isFile()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "isFile", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").isFile()"; 
    }

    if ("isSameFile".equals(called) && 
        cargs.size() >= 2)
    { // (cargs1 = cargs2)
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { expression = 
          new BinaryExpression("=", 
                               callarg1.expression,
                               callarg2.expression);
        expression.setBrackets(true);  
      } 

      return "(" + callp1 + " = " + callp2 + ")"; 
    }

    if ("isWritable".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).canWrite()
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "canWrite", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").canWrite()"; 
    }

    if ("readString".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readAll()
      ASTTerm.setType(this, "String"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Read", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "readAll", 
                                fexpr); 

        Type stringS = new Type("String", null); 
        stringS.setElementType(new Type("String", null)); 
        expression.setType(stringS); 
      } 

      return "OclFile.newOclFile_Read(" + callp1 + ").readAll()"; 
    }

    if (("lines".equals(called) || 
         "readAllLines".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readAll()->split("\n\r")
      ASTTerm.setType(this, "Sequence(String)"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "readAllLines", 
                                fexpr); 
        // expression = 
        //   new BinaryExpression("->split", expr1, 
        //     BasicExpression.newValueBasicExpression(
        //       "\"\n\r\"")); 
      } 

      return "OclFile.newOclFile_Read(" + callp1 + ").readAllLines()"; 
    }

    if (("list".equals(called) || 
         "newDirectoryStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).list()
    
      ASTTerm.setType(this, "Sequence(String)"); 

      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "list", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").list()"; 
    }

    if ("move".equals(called) && 
        cargs.size() >= 2)
    { // if OclFile.renameFile(carg1,carg2) then carg2 
      // else null endif
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { Vector fls = new Vector(); 
        fls.add(callarg1.expression); 
        fls.add(callarg2.expression); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "renameFile", "OclFile", 
                                fls);
        statement = 
          InvocationStatement.newInvocationStatement(
                                 expression, 
                                 fls);  
      } 

      return "OclFile.renameFile(" + callp1 + ", " + callp2 + ")"; 
    } 

    if (("newBufferedReader".equals(called) ||
         "newInputStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile_Read(OclFile.newOclFile(carg1) 
      ASTTerm.setType(this, "OclFile"); 
     
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Read", "OclFile", 
                                expr);
      } 

      return "OclFile.newOclFile_Read(OclFile.newOclFile(" + callp1 + "))"; 
    } 

    if (("newBufferedWriter".equals(called) || 
         "newByteChannel".equals(called) || 
         "newPrintWriter".equals(called) || 
         "newOutputStream".equals(called)) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile_Write(OclFile.newOclFile(carg1) 
      ASTTerm.setType(this, "OclFile"); 
     
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression expr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Write", "OclFile", 
                                expr);
      } 

      return "OclFile.newOclFile_Write(OclFile.newOclFile(" + callp1 + "))"; 
    } 

    if ("notExists".equals(called) && 
        cargs.size() >= 1)
    { // not(OclFile.newOclFile(cargs1).exists())
      ASTTerm.setType(this, "boolean"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          new UnaryExpression("not", 
            BasicExpression.newCallBasicExpression(
                                "exists", 
                                fexpr)); 
      } 

      return "not(OclFile.newOclFile(" + callp1 + ").exists())"; 
    }

    if ("probeContentType".equals(called) && 
        cargs.size() >= 1)
    { // "text/plain"
      ASTTerm.setType(this, "String"); 
    
      expression = 
          BasicExpression.newValueBasicExpression(
                                "\"text/plain\""); 

      return "\"text/plain\""; 
    }

    if ("readAllBytes".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).readNbytes(f.length())
      ASTTerm.setType(this, "Sequence(int)"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        Expression lexpr = 
          BasicExpression.newCallBasicExpression(
                                "length", fexpr);

        expression = 
          BasicExpression.newCallBasicExpression(
            "readNbytes", fexpr, lexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").readNbytes(OclFile.newOclFile(" + callp1 + ").length())"; 
    }

    if ("write".equals(called) && 
        cargs.size() >= 2)
    { // OclFile.newOclFile_Write(
      //    OclFile.newOclFile(cargs1)).writeNbytes(f,f->size())
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
          
      if (callarg1.expression != null && 
          callarg2.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        Expression wfexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile_Write", "OclFile", 
                                fexpr);
        Expression lexpr = 
          new UnaryExpression("->size", callarg2.expression);  
        Vector parsx = new Vector(); 
        parsx.add(callarg2.expression); 
        parsx.add(lexpr);
 
        expression = 
          BasicExpression.newCallBasicExpression(
            "writeNbytes", wfexpr, parsx); 
        statement = 
          InvocationStatement.newInvocationStatement(
            expression, parsx); 
      } 

      return "OclFile.newOclFile_Write(OclFile.newOclFile(" + callp1 + ")).writeNbytes(" + callp2 + ", " + callp2 + "->size())"; 
    }


    if ("size".equals(called) && 
        cargs.size() >= 1)
    { // OclFile.newOclFile(cargs1).length()
      ASTTerm.setType(this, "long"); 
    
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
          
      if (callarg1.expression != null)    
      { Expression fexpr = 
          BasicExpression.newStaticCallBasicExpression(
                                "newOclFile", "OclFile", 
                                callarg1.expression);
        expression = 
          BasicExpression.newCallBasicExpression(
                                "length", 
                                fexpr); 
      } 

      return "OclFile.newOclFile(" + callp1 + ").length()"; 
    }


    return ""; 
  }  

  public String streamFeatureAccess(ASTTerm arg, ASTTerm call, 
           String args, String calls, 
           String called, Vector cargs)
  { String argliteral = arg.literalForm(); 
    String thisliteral = this.literalForm(); 
    Expression argexpr = arg.expression; 

    if ("empty".equals(called) &&
        cargs.size() == 1)
    { ASTTerm.setType(thisliteral,"Sequence"); 
      expression = new SetExpression(true); 
      return "Sequence{}"; 
    } 
    else if ("concat".equals(called) &&
        cargs.size() > 1)
    { ASTTerm.setType(thisliteral,"Sequence"); 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3();

      // callp1->union(callp2)
      if (callarg1.expression != null && 
          callarg2.expression != null)
      { expression = 
          new BinaryExpression("->union", callarg1.expression,
                               callarg2.expression); 
        return expression + ""; 
      } 
    } 
    else if ("of".equals(called) &&
        cargs.size() >= 1)
    { ASTTerm.setType(thisliteral,"Sequence");

      expression = new SetExpression(true); 
  
      for (int i = 0; i < cargs.size(); i++) 
      {  
        ASTTerm callarg = (ASTTerm) cargs.get(i);
        String callp = callarg.toKM3(); 
        if (callarg.expression != null)
        { ((SetExpression) expression).addElement(
                                 callarg.expression);
        }  
        return expression + ""; 
      } 
    } 
    else if ("range".equals(called) &&
        cargs.size() > 1)
    { ASTTerm.setType(thisliteral,"Sequence"); 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
 
      // Integer.subrange(callp1,callp2-1)
      if (callarg1.expression != null && 
          callarg2.expression != null)
      { Vector pars = new Vector(); 
        pars.add(callarg1.expression); 
        pars.add(new BinaryExpression("-", callarg2.expression,
                                      oneExpression)); 
        expression = 
          BasicExpression.newFunctionBasicExpression(
            "subrange", "Integer", pars); 
        return expression + ""; 
      } 
    }
    else if ("rangeClosed".equals(called) &&
        cargs.size() > 1)
    { ASTTerm.setType(thisliteral,"Sequence"); 
      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      ASTTerm callarg2 = (ASTTerm) cargs.get(1);
      String callp2 = callarg2.toKM3(); 
 
      // Integer.subrange(callp1,callp2-1)
      if (callarg1.expression != null && 
          callarg2.expression != null)
      { Vector pars = new Vector(); 
        pars.add(callarg1.expression); 
        pars.add(callarg2.expression); 
        expression = 
          BasicExpression.newFunctionBasicExpression(
            "subrange", "Integer", pars); 
        return expression + ""; 
      } 
    }

    args = arg.queryForm(); 
    calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls; 
  } 

  public String spliteratorsFeatureAccess(ASTTerm arg, ASTTerm call, 
           String args, String calls, 
           String called, Vector cargs)
  { String argliteral = arg.literalForm(); 
    String thisliteral = this.literalForm(); 
    Expression argexpr = arg.expression;

    if ("emptyDoubleSpliterator".equals(called) || 
        "emptyIntSpliterator".equals(called) || 
        "emptyLongSpliterator".equals(called) || 
        "emptySpliterator".equals(called))
    { ASTTerm.setType(thisliteral,"OclIterator"); 

      Expression insts = 
        new SetExpression(true); 
      Vector pars = new Vector(); 
      pars.add(insts); 
      expression = 
        BasicExpression.newFunctionBasicExpression(
                               "newOclIterator_Sequence",  
                               "OclIterator", pars); 

      return "OclIterator.newOclIterator_Sequence(Sequence{})"; 
    } 
    else if ("spliterator".equals(called) && cargs.size() > 0)
    { ASTTerm.setType(thisliteral,"OclIterator"); 

      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      
      Vector pars = new Vector(); 
      pars.add(callarg1.expression); 
      expression = 
        BasicExpression.newFunctionBasicExpression(
                               "newOclIterator_Sequence",  
                               "OclIterator", pars); 

      return "OclIterator.newOclIterator_Sequence(" + callp1 + ")"; 
    } 
    else if ("iterator".equals(called) && cargs.size() > 0)
    { ASTTerm.setType(thisliteral, "OclIterator"); 

      ASTTerm callarg1 = (ASTTerm) cargs.get(0);
      String callp1 = callarg1.toKM3(); 
      
      expression = callarg1.expression; 

      return callp1; 
    } 


    args = arg.queryForm(); 
    calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls; 
  } 

  public String enumSetFeatureAccess(ASTTerm arg, ASTTerm call, 
           String args, String calls, 
           String called, Vector cargs)
  { String argliteral = arg.literalForm(); 
    String thisliteral = this.literalForm(); 
    Expression argexpr = arg.expression; 
    
    if ("allOf".equals(called) && 
        "EnumSet".equals(argliteral))
    { ASTTerm.setType(thisliteral,"Set"); 
      ASTTerm callarg = (ASTTerm) cargs.get(0);
      String callp1 = callarg.toKM3(); 

      if (callarg.expression != null) 
      { Expression insts = 
          BasicExpression.newFunctionBasicExpression(
                               "allInstances",  
                               callarg.expression); 
            expression = 
              new UnaryExpression("->asSet", insts); 
       } 

       return callp1 + ".allInstances()->asSet()"; 
     } 
     else if ("copyOf".equals(called) && 
                 "EnumSet".equals(argliteral))
        { ASTTerm.setType(thisliteral,"Set"); 
          ASTTerm callarg = (ASTTerm) cargs.get(0);
          String callp1 = callarg.toKM3(); 

          if (callarg.expression != null) 
          { Expression insts = 
              new UnaryExpression("->copy", callarg.expression); 
            expression = 
              new UnaryExpression("->asSet", insts); 
          } 

          return callp1 + "->copy()->asSet()"; 
        } 
        else if ("of".equals(called) && 
                 "EnumSet".equals(argliteral))
        { ASTTerm.setType(thisliteral,"Set"); 
          SetExpression resx = new SetExpression(); 

          for (int i = 0; i < cargs.size(); i++) 
          { ASTTerm callarg = (ASTTerm) cargs.get(i);
            String callpar = callarg.toKM3(); 
            if (callarg.expression != null) 
            { resx.addElement(callarg.expression); }  
            String elemtype = 
               ASTTerm.getType(callarg); 
            if (elemtype != null) 
            {               
              ASTTerm.setElementType(this,elemtype);   
            } 
          } 

          expression = resx; 
          return expression + ""; 
        } 
        else if ("complementOf".equals(called) && 
                 "EnumSet".equals(argliteral))
        { // callarg->any()->oclType().allInstances() - callarg
 
          ASTTerm.setType(thisliteral,"Set");
 
          ASTTerm callarg = (ASTTerm) cargs.get(0);
          String callp1 = callarg.toKM3(); 

          String callargtype = 
             ASTTerm.getElementType(callarg); 

          // System.out.println(">+>+> Element type of " + callarg + " is " + callargtype); 

          if (callarg.expression != null) 
          { Expression argtype = 
              new UnaryExpression("->oclType", 
                new UnaryExpression("->any",
                                    callarg.expression));
 
            if (callargtype != null && 
                ModelElement.lookupByName(
                     callargtype,ASTTerm.enumtypes) != null)
            { Type et = (Type) ModelElement.lookupByName(
                           callargtype,ASTTerm.enumtypes); 
              argtype = new BasicExpression(et);  
                                           
              ASTTerm.setElementType(this,callargtype);   
            } 
                 
            Expression insts = 
              BasicExpression.newFunctionBasicExpression(
                       "allInstances", argtype); 
            expression = 
              new BinaryExpression("-", insts, 
                                   callarg.expression); 
            expression.setBrackets(true); 
          } 

          return "(" + callp1 + "->any()->oclType().allInstances() - callp1)"; 
        } 
        else if ("range".equals(called) && 
                 "EnumSet".equals(argliteral))
        { // callarg1->oclType().allInstances()->select(
          //   _x | _x >= callarg1 && _x <= callarg2 )
 
          ASTTerm.setType(thisliteral,"Set");
 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 

          String callargtype = ASTTerm.getType(callarg1); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression argtype = 
              new UnaryExpression("->oclType", 
                                  callarg1.expression);
 
            if (callargtype != null && 
                ModelElement.lookupByName(
                     callargtype,ASTTerm.enumtypes) != null)
            { Type et = (Type) ModelElement.lookupByName(
                     callargtype,ASTTerm.enumtypes); 
              argtype = new BasicExpression(et);
              ASTTerm.setElementType(this,callargtype);   
            } 
                 
            Expression insts = 
              BasicExpression.newFunctionBasicExpression(
                       "allInstances", argtype);
        Expression _xx = 
              BasicExpression.newVariableBasicExpression("_xx"); 
        BinaryExpression seldom = 
              new BinaryExpression(":", _xx, insts);
        Expression geq = 
              new BinaryExpression(">=", _xx, callarg1.expression); 
        Expression leq = 
              new BinaryExpression("<=", _xx, callarg2.expression); 
  
        Expression selrng = 
              new BinaryExpression("&", geq, leq); 
        expression = 
              new BinaryExpression("|", seldom, 
                                   selrng); 
      } 

      return "(" + callp1 + "->oclType()).allInstances()->select( _xx | _xx >= " + callp1 + " & _xx <= " + callp2 + ")"; 
    } 

    args = arg.queryForm(); 
    calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls; 
  }

  public String featureAccess(ASTTerm arg, ASTTerm call, String args, String calls)
  { // arg . call
    // args . calls

    // The arg itself may have a side-effect, eg: (x = e).f()

    String argliteral = arg.literalForm(); 
    String thisliteral = this.literalForm(); 
    Expression argexpr = arg.expression; 
      // assumes already defined

    // JOptionPane.showInputDialog(">>> Featureaccess: " + args + 
    //             " . " + calls + "\n" + 
    //             ">>> literal forms: " + argliteral); 


    if (call instanceof ASTCompositeTerm)
    { ASTCompositeTerm callterm = (ASTCompositeTerm) call;
      if (callterm.tag.equals("explicitGenericInvocation"))
      { ASTTerm actualCall = (ASTTerm) callterm.terms.get(1);
        return 
          featureAccess(arg,actualCall,args,
                        actualCall.literalForm()); 
      }  
 
      if (callterm.tag.equals("methodCall") ||
          callterm.tag.equals(
               "explicitGenericInvocationSuffix"))
      { Vector callterms = callterm.terms; 
        String called = callterms.get(0) + "";
        // JOptionPane.showInputDialog(">> Method call " + args + 
        //                    " . " + called + " " + callterms); 
        
        ASTTerm callargs; 
        if (callterm.tag.equals(
                "explicitGenericInvocationSuffix"))
        { callargs = (ASTTerm) callterms.get(1); } 
        else 
        { callargs = (ASTTerm) callterms.get(2); } 
		
        Vector cargs = getCallArguments(callargs); 
          
        // System.out.println(">> Call arguments " + cargs); 
        // System.out.println(); 
 
        if ("getRuntime".equals(called) && 
            "Runtime".equals(args))
        { ASTTerm.setType(this, "OclProcess"); 
          expression = 
            BasicExpression.newStaticCallBasicExpression(
                                  "getRuntime", "OclProcess"); 
          return "OclProcess.getRuntime()"; 
        } 
        else if (("println".equals(called) || 
                  "print".equals(called)) && 
                 "System.out".equals(argliteral.trim()))
        { if (cargs.size() == 0)
          { Vector pars = new Vector(); 
            Expression par = 
                BasicExpression.newValueBasicExpression("\"\""); 
            expression = 
                new UnaryExpression("->display", par); 
            statement = 
                new ImplicitInvocationStatement(expression); 

            return "execute (\"\")->display()"; 
          }

          ASTTerm arg1 = (ASTTerm) cargs.get(0); 
          String callp = arg1.toKM3();

          Statement sideEffect = null;


          String res = arg1.queryForm(); 

          if (arg1.expression != null) 
          { arg1.expression.setBrackets(true); 
            expression = 
                new UnaryExpression("->display", 
                                    arg1.expression); 
            Statement stat = 
                new ImplicitInvocationStatement(expression); 


            if (arg1.hasSideEffect())
            { arg1.postSideEffect(); 
              sideEffect = arg1.statement; 
            }   

            System.out.println(">>> Side effect of println is: " + sideEffect); 

            if (sideEffect == null) 
            { statement = stat; } 
            else 
            { statement = 
                  new SequenceStatement(stat,sideEffect); 
            }
          } 
            
          return "execute (" + res + ")->display()"; 
        } 
        else if (("println".equals(called) || 
                  "print".equals(called)) && 
                 "System.err".equals(argliteral.trim()))
        { if (cargs.size() == 0)
          { Vector pars = new Vector(); 
            Expression par = 
                BasicExpression.newValueBasicExpression("\"\""); 
            expression = 
                new UnaryExpression("->display", par); 
            statement = 
                new ImplicitInvocationStatement(expression); 

            return "execute (\"\")->display()"; 
          }

          ASTTerm arg1 = (ASTTerm) cargs.get(0); 
          // String callp = arg1.toKM3();

          Statement sideEffect = null; 

          String res = arg1.queryForm(); 

          if (arg1.expression != null) 
          { arg1.expression.setBrackets(true);
            Entity ocltypeent = new Entity("OclFile"); 
            Type ocltype = new Type(ocltypeent); 
            BasicExpression errfile = 
               new BasicExpression(ocltype); 
            errfile.setUmlKind(Expression.CLASSID);
            BasicExpression sysfile = new BasicExpression("\"System.err\""); 
            sysfile.setType(new Type("String", null)); 
 
            errfile.setArrayIndex(sysfile); 
            expression = 
              BasicExpression.newCallBasicExpression(
                "println", errfile, arg1.expression); 
            Statement stat = 
                new ImplicitInvocationStatement(expression); 
          
            if (arg1.hasSideEffect())
            { arg1.postSideEffect(); 
              sideEffect = arg1.statement; 
            }   

            System.out.println(">>> Side effect of println is: " + sideEffect); 
     
            if (sideEffect == null) 
            { statement = stat; } 
            else 
            { statement = 
                  new SequenceStatement(stat,sideEffect); 
            }
          } 
            
          return "execute (OclFile[\"System.err\"].println(" + res + "))"; 
        } 
        else if ("println".equals(called) || 
                 "print".equals(called))
        { if (cargs.size() == 0)
          { Vector pars = new Vector(); 
            Expression par = 
              BasicExpression.newValueBasicExpression("\"\""); 
            expression = 
              new UnaryExpression("->display", par); 
            statement = 
              new ImplicitInvocationStatement(expression); 

            return "execute (\"\")->display()"; 
          }

          ASTTerm arg1 = (ASTTerm) cargs.get(0); 
          // String callp = arg1.toKM3();

          Statement sideEffect = null; 
          if (arg1.hasSideEffect()) 
          { arg1.postSideEffect(); 
            sideEffect = arg1.statement; 
          } 
 
          // JOptionPane.showInputDialog(">>> Side effect of println is: " + sideEffect); 

          String res = arg1.queryForm(); 

          if (argexpr != null && arg1.expression != null) 
          { arg1.expression.setBrackets(true);
            expression = 
              BasicExpression.newCallBasicExpression(
                called, argexpr, arg1.expression); 
            Statement stat = 
                new ImplicitInvocationStatement(expression); 
          
            if (sideEffect == null) 
            { statement = stat; } 
            else 
            { statement = 
                  new SequenceStatement(stat,sideEffect); 
            }
          } 
            
          return "" + statement; 
        } 
        else if ("exec".equals(called) && 
                 "OclProcess".equals(ASTTerm.getType(arg)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"OclProcess");
          if (callarg1.expression != null) 
          { Vector procargs = new Vector(); 
            procargs.add(new BasicExpression("null")); 
            procargs.add(callarg1.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclProcess", "OclProcess", procargs); 
          } 
          return "OclProcess.newOclProcess(null, " + callp1 + ")";  
        }
        else if ("toDegrees".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { BasicExpression conver = new BasicExpression(57.29577951308232); 
            expression = 
              new BinaryExpression("*", conver, callarg1.expression); 
            expression.setBrackets(true); 
          } 
          return "(57.29577951308232*(" + callp1 + "))"; 
        }  
        else if ("toRadians".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { BasicExpression conver = 
               new BasicExpression(0.017453292519943295); 
            expression = 
              new BinaryExpression("*", conver, callarg1.expression);
            expression.setBrackets(true); 
             
          } 
          return "(0.017453292519943295*(" + callp1 + "))"; 
        }  
        else if ("max".equals(called) && 
                 ("Math".equals(args) || 
                  "Long".equals(args)) 
                )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral, 
                          ASTTerm.getType(callarg1)); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { SetExpression setexp = new SetExpression();
            setexp.addElement(callarg1.expression); 
            setexp.addElement(callarg2.expression);  
            expression = 
              new UnaryExpression("->max", setexp); 
          } 

          return "Set{" + callp1 + ", " + callp2 + "}->max()"; 
        }  
        else if ("min".equals(called) &&
                 ("Math".equals(args) || 
                  "Long".equals(args))
                )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 
          ASTTerm.setType(thisliteral, 
                          ASTTerm.getType(callarg1)); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { SetExpression setexp = new SetExpression();
            setexp.addElement(callarg1.expression); 
            setexp.addElement(callarg2.expression);  
            expression = 
              new UnaryExpression("->min", setexp); 
          } 

          return "Set{" + callp1 + ", " + callp2 + "}->min()"; 
        }  
        else if ("abs".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral, 
                          ASTTerm.getType(callarg1)); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->abs",  callarg1.expression); 
          } 
          
          return "(" + callp1 + ")->abs()"; 
        }  
        else if ("abs".equals(called)) // for BigInteger
        { ASTTerm.setType(thisliteral,"long"); 

          if (arg.expression != null) 
          { arg.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->abs", arg.expression); 
          } 

          return "(" + args + ")->abs()"; 
        }  
        else if ("floor".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->floor",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->floor()"; 
        }  
        else if ("round".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->round",  callarg1.expression); 
          } 
          
          return "(" + callp1 + ")->round()"; 
        }  
        else if ("ceil".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->ceil",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->ceil()"; 
        }  
        else if ("sin".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->sin",  callarg1.expression); 
          } 
          
          return "(" + callp1 + ")->sin()"; 
        }  
        else if ("cos".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->cos",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->cos()"; 
        }  
        else if ("tan".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->tan",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->tan()"; 
        }  
        else if ("log".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->log",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->log()"; 
        }  
        else if ("asin".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->asin",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->asin()"; 
        }  
        else if ("acos".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->acos",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->acos()"; 
        }  
        else if ("atan".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->atan",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->atan()"; 
        }  
        else if ("exp".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->exp",  callarg1.expression); 
          } 

          ASTTerm.setType(thisliteral,"double"); 
          
          return "(" + callp1 + ")->exp()"; 
        }  
        else if ("sinh".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->sinh",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->sinh()"; 
        }  
        else if ("cosh".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->cosh",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->cosh()"; 
        }  
        else if ("tanh".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->tanh",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->tanh()"; 
        }  
        else if ("log10".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->log10",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->log10()"; 
        }  
        else if ("sqrt".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->sqrt",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->sqrt()"; 
        }  
        else if ("cbrt".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 
          
          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->cbrt",  callarg1.expression); 
          } 

          return "(" + callp1 + ")->cbrt()"; 
        }  
        else if ("pow".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("->pow",  callarg1.expression, callarg2.expression); 
          } 

          return "(" + callp1 + ")->pow(" + callp2 + ")"; 
        }  
        else if ("pow".equals(called) && arg.isNumber())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
         
          ASTTerm.setType(thisliteral,"double"); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { arg.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("->pow", arg.expression, callarg1.expression); 
          } 

          return "(" + args + ")->pow(" + callp1 + ")"; 
        }  
        else if ("gcd".equals(called) && arg.isNumber())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { arg.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("->gcd", arg.expression, callarg1.expression); 
          } 
         
          ASTTerm.setType(thisliteral,"long"); 

          return "(" + args + ")->gcd(" + callp1 + ")"; 
        }  
        else if ("rint".equals(called) && "Math".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null) 
          { expression = 
              new BinaryExpression("*", new BasicExpression(1.0), 
                new UnaryExpression("->round", callarg1.expression));
            expression.setBrackets(true);  
          } 

          return "(1.0*((" + callp1 + ")->round()))"; 
        }  
        else if ("random".equals(called) && "Math".equals(args))
        { ASTTerm.setType(thisliteral,"double"); 

          expression = BasicExpression.newStaticCallBasicExpression("random", "MathLib", new Vector()); 

          return "MathLib.random()"; 
        }  
        else if ("nextBoolean".equals(called) && "ThreadLocalRandom.current()".equals(args))
        { ASTTerm.setType(thisliteral,"boolean"); 

          expression = BasicExpression.newStaticCallBasicExpression("nextBoolean", "MathLib", new Vector()); 

          return "MathLib.nextBoolean()"; 
        }  
        else if ("matches".equals(called) && 
                 "Pattern".equals(argliteral) && 
                 cargs.size() >= 2)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = 
                new BinaryExpression("->isMatch", callarg2.expression, callarg1.expression); 
          } 
          
          return callp2 + "->isMatch(" + callp1 + ")"; 
        } 
        else if ("matches".equals(called))
        { ASTTerm.setType(thisliteral,"boolean"); 
          
          if (cargs.size() == 0) // on a Matcher
          { if (arg.expression != null) 
            { expression = 
                 BasicExpression.newCallBasicExpression("isMatch", arg.expression);
            }  
            
            return args + ".isMatch()"; 
          } 
          else if (cargs.size() == 1 && arg.isString())
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            
            if (callarg1.expression != null && 
                arg.expression != null) 
            { expression = 
                new BinaryExpression("->isMatch", arg.expression, callarg1.expression); 
            } 

            return args + "->isMatch(" + callp1 + ")"; 
          } 
        } 
        else if ("find".equals(called)) // on Matcher
        { if (cargs.size() == 0)
          { ASTTerm.setType(thisliteral,"boolean"); 
          
            if (arg.expression != null) 
            { expression = 
                 BasicExpression.newCallBasicExpression(
                            "hasNext", arg.expression);
            }

            return args + ".hasNext()"; 
          } // treat as an OclIterator
        } 
        else if ("list".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"Sequence"); 

          if (callarg1.expression != null) 
          { Expression sexpr = new SetExpression(true);
            Expression elems = 
              BasicExpression.newBasicExpression(callarg1.expression, "elements");  
            expression = 
              new BinaryExpression("->union", sexpr, elems); 
          } 

          return "Sequence{}->union(" + callp1 + ".elements)"; 
        } 
        else if ("enumeration".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          System.out.println(">>> enumeration of collection: " + this); 

          ASTTerm.setType(thisliteral,"OclIterator"); 

          if (callarg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclIterator_Set", "OclIterator", callarg1.expression); 
          } // why not _Sequence if callarg1 is a sequence?

          return "OclIterator.newOclIterator_Set(" + callp1 + ")"; 
        }  
        else if ("elements".equals(called) && arg.isMap())
        { 
          System.out.println(">>> enumeration of map values: " + this); 
          
          ASTTerm.setType(thisliteral,"OclIterator"); 
          // With same element type as arg. 

          if (arg.expression != null) 
          { Expression vals = new UnaryExpression("->values", arg.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclIterator_Sequence", "OclIterator", vals); 
          } 

          return "OclIterator.newOclIterator_Sequence(" + args + "->values())"; 
        }  
        else if ("min".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          String elemT = ASTTerm.getElementType(callarg1); 
          ASTTerm.setType(thisliteral,elemT); 

          if (cargs.size() == 2) 
          { ASTTerm cmptrm = (ASTTerm) cargs.get(1); 
            String cmp = cmptrm.toKM3(); 
            Vector spars = new Vector(); 
            spars.add(callarg1.expression); 
            spars.add(cmptrm.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "minimumWith", "OclComparator", spars); 
            return "OclComparator.minimumWith(" + 
                      callp1 + ", " + cmp + ")"; 
          } 
          
          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->min", callarg1.expression); } 

          return "(" + callp1 + ")->min()"; 
        }  
        else if ("max".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemT = ASTTerm.getElementType(callarg1); 
          ASTTerm.setType(thisliteral,elemT); 

          if (cargs.size() == 2) 
          { ASTTerm cmptrm = (ASTTerm) cargs.get(1); 
            String cmp = cmptrm.toKM3(); 
            Vector spars = new Vector(); 
            spars.add(callarg1.expression); 
            spars.add(cmptrm.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "maximumWith", "OclComparator", spars); 
            return "OclComparator.maximumWith(" + 
                      callp1 + ", " + cmp + ")"; 
          } 

          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->max", callarg1.expression); } 
          
          return "(" + callp1 + ")->max()"; 
        } 
        else if (("sort".equals(called) || 
                  "parallelSort".equals(called)) && 
                 ("Collections".equals(args) || 
                  "Arrays".equals(args)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"Sequence"); 
          // or a map if arg is a map
          
          if (cargs.size() > 2) 
          { ASTTerm lowind = (ASTTerm) cargs.get(1); 
            ASTTerm highind = (ASTTerm) cargs.get(2);
            String lowval = lowind.toKM3(); 
            String highval = highind.toKM3();

            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(lowind.expression); 

            Expression subrange1 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars1); 

            Vector pars2 = new Vector(); 
            pars2.add(new BinaryExpression("+",
                            lowind.expression,unitExpression)); 
            pars2.add(highind.expression); 

            Expression subrange2 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars2); 
 
            String midres = 
              callp1 + ".subrange(" + lowval + "+1," + highval + ")->sort()"; 

            if (cargs.size() == 4) 
            { ASTTerm cmptrm = (ASTTerm) cargs.get(4);
              String cmp = cmptrm.toKM3();
              Vector spars = new Vector(); 
              spars.add(subrange2); 
              spars.add(cmptrm.expression);  
              subrange2 = 
                BasicExpression.newStaticCallBasicExpression(
                  "sortWith", "OclComparator", spars); 
              midres = 
                "OclComparable.sortWith(" + 
                   callp1 + ".subrange(" + lowval + "+1, " +
                                        highval + "), " + 
                                        cmp + ")";        
            } 
            else   
            { subrange2 = new UnaryExpression("->sort", subrange2); 
              subrange2.setBrackets(true); 
            } 

            Vector pars3 = new Vector(); 
            pars3.add(new BinaryExpression("+",
                            highind.expression,unitExpression)); 
            pars3.add(
               new UnaryExpression("->size",
                                   callarg1.expression)); 

            Expression subrange3 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars3); 

            Expression cat1 = 
              new BinaryExpression("^", subrange2, subrange3); 
            expression = 
              new BinaryExpression("^", subrange1, cat1); 

            return callp1 + " := " + callp1 + ".subrange(1," + lowval + ")^(" + midres + ")^" + callp1 + ".subrange(" + highval + "+1," + callp1 + ".size)"; 
          }  

          if (cargs.size() == 2) // sort with comparator
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 
            Vector spars = new Vector(); 
            spars.add(callarg1.expression); 
            spars.add(callarg2.expression); 
            expression =
              BasicExpression.newStaticCallBasicExpression(
                "sortWith", "OclComparator", spars);  
             // new BinaryExpression(
             //      "->sortedWith", callarg1.expression,
             //                      callarg2.expression); 
            statement = 
              new AssignStatement(callarg1.expression,
                                  expression); 
            modelElements = callarg2.modelElements; 

            return callp1 + " := " + 
                  "OclComparable.sortWith(" + callp1 + ", " +
                                          callp2 + ")"; 
          } 

          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->sort", callarg1.expression); 
            statement = 
              new AssignStatement(callarg1.expression,
                                  expression); 
          } 

          return callp1 + " := (" + callp1 + ")->sort()"; 
        } 
        else if ("replaceAll".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,
                          ASTTerm.getType(callarg1)); 
          
          if (cargs.size() > 2) 
          { ASTTerm obj = (ASTTerm) cargs.get(1); 
            ASTTerm rep = (ASTTerm) cargs.get(2);
            String objx = obj.toKM3(); 
            String repx = rep.toKM3();

            if (callarg1.expression != null && 
                obj.expression != null &&  
                rep.expression != null) 
            { Expression xexp = 
                BasicExpression.newVariableBasicExpression("x_1"); 
              Expression eq = 
                new BinaryExpression("=", xexp, obj.expression); 
              Expression conde = 
                new ConditionalExpression(eq,rep.expression,xexp);
              Expression domexpr = 
                new BinaryExpression(":", xexp, callarg1.expression);  
              expression = 
                new BinaryExpression("|C", domexpr, conde); 
              statement = 
                new AssignStatement(callarg1.expression, expression); 
            } 
 
            return callp1 + " := " + callp1 + "->collect(x_1 | if x_1 = " + objx + " then " + repx + " else x_1 endif )"; 
          }  
          return callp1; 
        } 
        else if ("swap".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"Sequence"); 
          
          if (cargs.size() > 2) 
          { ASTTerm obj = (ASTTerm) cargs.get(1); 
            ASTTerm rep = (ASTTerm) cargs.get(2);
            String objx = obj.toKM3(); 
            String repx = rep.toKM3();
 
            if (callarg1.expression != null && 
                obj.expression != null && 
                rep.expression != null) 
            { String x_1 = Identifier.nextIdentifier("x_"); 
              Expression xbe = 
                BasicExpression.newVariableBasicExpression(
                                                         x_1);
              Expression objind = 
                new BinaryExpression("+", obj.expression, 
                                     unitExpression); 
              Expression repind = 
                new BinaryExpression("+", rep.expression, 
                                     unitExpression); 
              Expression test1 = 
                new BinaryExpression("=", xbe, repind);
              Expression test2 = 
                new BinaryExpression("=", xbe, objind);
              
              Expression argobj = 
                BasicExpression.newIndexedBasicExpression(
                  callarg1.expression,objind); 
              Expression argrep = 
                BasicExpression.newIndexedBasicExpression(
                  callarg1.expression,repind); 
              Expression argx = 
                BasicExpression.newIndexedBasicExpression(
                  callarg1.expression,xbe); 
 
              Expression ifstat1 = 
                new ConditionalExpression(test1,argobj,argx);
              Expression ifstat2 = 
                new ConditionalExpression(test2,
                                          argrep,ifstat1);
              Vector pars = new Vector(); 
              pars.add(unitExpression); 
              pars.add(new UnaryExpression("->size", 
                                       callarg1.expression)); 

              Expression subrang = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars); 
              Expression colldom =
                new BinaryExpression(":", xbe, subrang);  
              expression = 
                new BinaryExpression("|C", colldom, ifstat2); 
              statement = 
                new AssignStatement(callarg1.expression,
                                    expression); 
            } 

            return callp1 + " := Integer.subrange(1," + callp1 + ".size)->collect(x_1 | if x_1 = " + objx + "+1 then " + callp1 + "[" + repx + "+1] else if x_1 = " + repx + "+1 then " + callp1 + "[" + objx + "+1] else " + callp1 + "[x_1] endif endif )"; 
          }  
          return callp1; 
        } 
        else if ("rotate".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"Sequence"); 
          
          if (cargs.size() > 1) 
          { ASTTerm nn = (ASTTerm) cargs.get(1); 
            String nx = nn.toKM3(); 

            if (callarg1.expression != null && 
                nn.expression != null) 
            { Expression argsize = 
                new UnaryExpression("->size", 
                                    callarg1.expression);
              String x_1 = Identifier.nextIdentifier("x_"); 
              Expression xbe = 
                BasicExpression.newVariableBasicExpression(
                                                         x_1);
              Expression ind1 = 
                new BinaryExpression("-", xbe, 
                                     unitExpression); 
              Expression ind2 = 
                new BinaryExpression("-", ind1, 
                                     nn.expression);
              ind2.setBrackets(true);  
              Expression ind3 = 
                new BinaryExpression("mod", ind2, argsize);
              ind3.setBrackets(true); 
              Expression ind4 = 
                new BinaryExpression("+", ind3, 
                                     unitExpression);
              
              Expression appl = 
                new BinaryExpression("->at", 
                       callarg1.expression,ind4); 
 
              Vector pars = new Vector(); 
              pars.add(unitExpression); 
              pars.add(argsize); 

              Expression subrang = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars); 
              Expression colldom =
                new BinaryExpression(":", xbe, subrang);  
              expression = 
                new BinaryExpression("|C", colldom, appl); 
              statement = 
                new AssignStatement(callarg1.expression,
                                    expression); 
            } 

            return callp1 + " := Integer.subrange(1," + callp1 + ".size)->collect( x_1 | " + callp1 + "->at(((x_1-1-" + nx + ") mod " + callp1 + ".size) + 1) )"; 
          }  
          return callp1; 
        } 
        else if ("shuffle".equals(called) && 
                 "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"Sequence"); 

          if (callarg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "randomiseSequence", "OclRandom", 
                callarg1.expression); 
            statement = 
              new AssignStatement(callarg1.expression,
                                  expression); 
          } 
          
          return callp1 + " := OclRandom.randomiseSequence(" + callp1 + ")"; 
        } 
        else if ("forName".equals(called) && "Class".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"OclType"); 

          if (callarg1.expression != null) 
          { Entity ocltypeent = new Entity("OclType"); 
            Type ocltype = new Type(ocltypeent); 
            expression = new BasicExpression(ocltype); 
            expression.setUmlKind(Expression.CLASSID); 
            ((BasicExpression) expression).setArrayIndex(callarg1.expression); 
          } 

          return "OclType[" + callp1 + "]"; 
        } 
        else if ("copyValueOf".equals(called) && "String".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 
          if (cargs.size() == 1)
          { if (callarg1.expression != null) 
            { callarg1.expression.setBrackets(true); 
              expression = new UnaryExpression("->sum", callarg1.expression); 
            } 
            return "(" + callp1 + ")->sum()"; 
          } 
          else if (cargs.size() == 3)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2); 
            String callp3 = callarg3.toKM3();

            if (callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(
                new BinaryExpression("+", callarg2.expression,
                                     unitExpression)); 
              pars.add(
                new BinaryExpression("+", callarg2.expression,
                                     callarg3.expression));
              Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", callarg1.expression, pars); 
              expression = 
                new UnaryExpression("->sum", subr); 
            } 
 
            return "(" + callp1 + ").subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ")->sum()";  
          }
        } 
        else if ("asList".equals(called) && 
                 "Arrays".equals(args))
        { ASTTerm.setType(thisliteral,"Sequence"); 
          String callp1 = toKM3arraylist(cargs); 
          
          return callp1; 
        }
        else if ("binarySearch".equals(called) && 
                 "Arrays".equals(args))
        { ASTTerm.setType(thisliteral,"int"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 

          if (cargs.size() == 3) 
          { ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 

            Vector spars = new Vector(); 
            spars.add(callarg1.expression); 
            spars.add(callarg2.expression); 
            spars.add(callarg3.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "binarySearch", "OclComparator", spars); 
            // OclComparator.binarySearch(callp1,callp2,callp3)

            return "OclComparator.binarySearch(" + 
                    callp1 + ", " + callp2 + ", " + callp3 + ")"; 
          } 

          
          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression indof = new BinaryExpression("->indexOf", callarg1.expression, callarg2.expression); 
            expression = new BinaryExpression("-", indof, unit); 
            expression.setBrackets(true); 
          } 

          return "(" + callp1 + "->indexOf(" + callp2 + ") - 1)"; 
        }
        else if ("copyOfRange".equals(called) && 
                 "Arrays".equals(args) && 
                 cargs.size() >= 3)
        { // sq.subrange(i+1,j)
          ASTTerm.setType(thisliteral,"Sequence"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          ASTTerm callarg3 = (ASTTerm) cargs.get(2);
          String callp3 = callarg3.toKM3(); 
          
          if (callarg1.expression != null && 
              callarg2.expression != null && 
              callarg3.expression != null) 
          { Vector pars = new Vector(); 
            Expression unit = new BasicExpression(1);
            pars.add(new BinaryExpression("+", 
                            callarg2.expression,unit)); 
            pars.add(callarg3.expression); 
            callarg1.expression.setBrackets(true); 
            expression = 
              BasicExpression.newFunctionBasicExpression(
                                "subrange", 
                                callarg1.expression, pars); 
          } 

          return "(" + callp1 + ").subrange(" + callp2 + "+1," + callp3 + ")"; 
        }
        else if ("copyOf".equals(called) && 
                 "Arrays".equals(args) && 
                 cargs.size() >= 2)
        { // sq.subrange(1,i)
          ASTTerm.setType(thisliteral,"Sequence"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          
          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Vector pars = new Vector(); 
            Expression unit = new BasicExpression(1);
            pars.add(unit); 
            pars.add(callarg2.expression); 
            callarg1.expression.setBrackets(true); 
            expression = 
              BasicExpression.newFunctionBasicExpression(
                                "subrange", 
                                callarg1.expression, pars); 
          } 

          return "(" + callp1 + ").subrange(1," + callp2 + ")"; 
        }
        else if ("Paths".equals(args))
        { return pathsMethodCallFormKM3(called,cargs); } 
        else if ("Files".equals(args))
        { return filesMethodCallFormKM3(called,cargs); } 
        else if ("getByName".equals(called) && 
                 "InetAddress".equals(argliteral))
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 

          if (callargument1.expression != null) 
          { expression = callargument1.expression; } 
 
          return callp1; 
        } // What are these operations of?  
        else if ("valueOf".equals(called) && 
                 "String".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (cargs.size() == 1)
          { if (callarg1.expression != null) 
            { Expression emptyString = 
                BasicExpression.newValueBasicExpression("\"\""); 
              expression = new BinaryExpression("+", callarg1.expression, emptyString); 
              callarg1.expression.setBrackets(true); 
              expression.setBrackets(true); 
            } 
            return "((" + callp1 + ") + \"\")"; 
          } 
          else if (cargs.size() == 3)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2); 
            String callp3 = callarg3.toKM3();

            if (callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null)
            { Vector pars = new Vector(); 
              BasicExpression unit = new BasicExpression(1);
              Expression par1 = 
                new BinaryExpression("+", callarg2.expression,
                                     unit); 
              Expression par2 = 
                new BinaryExpression("+", callarg2.expression,
                                     callarg3.expression); 
              pars.add(par1); pars.add(par2); 
              callarg1.expression.setBrackets(true); 
              expression = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", callarg1.expression, 
                  pars); 
            } 

            return "(" + callp1 + ".subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ") + \"\")";  
          }
        } 
        else if ("valueOf".equals(called) && "Boolean".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 
 
          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->toBoolean", callarg1.expression);
            callarg1.expression.setBrackets(true); 
          } 

          return "((" + callp1 + ") + \"\")->toBoolean()"; 
        } 
        else if ("valueOf".equals(called) && 
                 "BigInteger".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"long"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = new UnaryExpression("->toLong", callarg1.expression); 
          } 

          return "((" + callp1 + ") + \"\")->toLong()"; 
        } 
        else if (("decode".equals(called) || 
                  "valueOf".equals(called) || 
                  "parseByte".equals(called)) && 
                 "Byte".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          {
            callarg1.expression.setBrackets(true); 

            expression = new UnaryExpression(
                "->toInteger", callarg1.expression);
          } 

          return "(" + callp1 + ")->toInteger()"; 
        } 
        else if (("decode".equals(called) || 
                  "valueOf".equals(called) || 
                  "parseInt".equals(called)) && 
                 "Integer".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          {
             callarg1.expression.setBrackets(true); 
             expression = new UnaryExpression(
                  "->toInteger", callarg1.expression);
          } 
          return "(" + callp1 + ")->toInteger()"; 
        } 
        else if (("decode".equals(called) || 
                  "valueOf".equals(called) || 
                  calls.startsWith("parseLong(")) &&
                 cargs.size() > 0 && 
                 "Long".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"long"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = new UnaryExpression("->toLong", callarg1.expression); 
          } 

          // JOptionPane.showInputDialog(">>> " + expression); 

          return "(" + callp1 + ")->toLong()"; 
        } 
        else if ("min".equals(called) &&
                 cargs.size() > 1 && 
                 "Long".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 
          
          ASTTerm.setType(thisliteral,"long"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { SetExpression sexpression = new SetExpression(false);
            sexpression.addElement(
                                   callarg1.expression);
            sexpression.addElement(
                                   callarg2.expression); 
            expression = 
              new UnaryExpression("->min", sexpression);   
          } 

          // JOptionPane.showInputDialog(">>> " + expression); 

          return "Set{" + callp1 + ", " + callp2 + "}->min()"; 
        } 
        else if ("max".equals(called) &&
                 cargs.size() > 1 && 
                 "Long".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 
          
          ASTTerm.setType(thisliteral,"long"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { SetExpression sexpression = new SetExpression(false);
            sexpression.addElement(
                                   callarg1.expression);
            sexpression.addElement(
                                   callarg2.expression); 
            expression = 
              new UnaryExpression("->max", sexpression);   
          } 

          // JOptionPane.showInputDialog(">>> " + expression); 

          return "Set{" + callp1 + ", " + callp2 + "}->max()"; 
        } 
        else if ("rotateRight".equals(called) && 
                 "Integer".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Vector rargs = new Vector(); 
            rargs.add(callarg1.expression); 
            rargs.add(callarg2.expression); 

            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "bitwiseRotateRight", "MathLib",
                rargs);  
          } 

          return "MathLib.bitwiseRotateRight(" + callp1 + "," + callp2 + ")"; 
        } 
        else if ("rotateLeft".equals(called) && 
                 "Integer".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Vector rargs = new Vector(); 
            rargs.add(callarg1.expression); 
            rargs.add(callarg2.expression); 

            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "bitwiseRotateLeft", "MathLib",
                rargs);  
          } 

          return "MathLib.bitwiseRotateLeft(" + callp1 + "," + callp2 + ")"; 
        } 
        else if ("longBitsToDouble".equals(called) && 
                 "Double".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "longBitsToDouble", "MathLib",
                callarg1.expression);  
          } 

          return "MathLib.longBitsToDouble(" + callp1 + ")"; 
        } 
        else if ("doubleToLongBits".equals(called) && 
                 "Double".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"long"); 

          if (callarg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "doubleToLongBits", "MathLib",
                callarg1.expression);  
          } 

          return "MathLib.doubleToLongBits(" + callp1 + ")"; 
        } 
        else if (("valueOf".equals(called) || 
                  "parseDouble".equals(called)) && 
                 "Double".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->toReal", callarg1.expression); 
          } 

          return "((" + callp1 + ") + \"\")->toReal()"; 
        } 
        else if (("valueOf".equals(called) || 
                  "parseFloat".equals(called)) && 
                 "Float".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"double"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = new UnaryExpression("->toReal", callarg1.expression); 
          } 

          return "((" + callp1 + ") + \"\")->toReal()"; 
        } 
        else if (("decode".equals(called) || 
                  "valueOf".equals(called) || 
                  "parseShort".equals(called)) && 
                 "Short".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          { callarg1.expression.setBrackets(true); 
            expression = new UnaryExpression("->toInteger", callarg1.expression); 
          } 

          return "(" + callp1 + ")->toInteger()"; 
        } 
        else if ("toBinaryString".equals(called) &&
                 cargs.size() > 0 &&   
                 ("Integer".equals(argliteral) || 
                  "Long".equals(argliteral)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(callarg1.expression); 
             
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                       "decimal2binary", "MathLib", parms); 
          } 

          // JOptionPane.showInputDialog(">> " + expression); 

          return "MathLib.decimal2binary(" + callp1 + ")"; 
        } 
        else if ("toHexString".equals(called) &&  
                 ("Integer".equals(argliteral) || 
                  "Long".equals(argliteral)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(callarg1.expression); 
             
            expression = BasicExpression.newStaticCallBasicExpression("decimal2hex", "MathLib", parms); 
          }

          return "MathLib.decimal2hex(" + callp1 + ")"; 
        } 
        else if ("toOctalString".equals(called) &&  
                 ("Integer".equals(argliteral) || 
                  "Long".equals(argliteral)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(callarg1.expression); 
             
            expression = BasicExpression.newStaticCallBasicExpression("decimal2octal", "MathLib", parms); 
          }

          return "MathLib.decimal2octal(" + callp1 + ")"; 
        } 
        else if ("toString".equals(called) && 
                 ("Byte".equals(argliteral) ||
                  "Float".equals(argliteral) || 
                  "Double".equals(argliteral) || 
                  "Integer".equals(argliteral) || 
                  "Long".equals(argliteral) || 
                  "Short".equals(argliteral)) ) 
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Expression emptyString = BasicExpression.newValueBasicExpression("\"\""); 
            callarg1.expression.setBrackets(true); 
            emptyString.setType(new Type("String", null)); 
            expression = new BinaryExpression("+", callarg1.expression, emptyString); 
            expression.setBrackets(true); 
          } 

          return "((" + callp1 + ") + \"\")"; 
        } 
        else if ("isNaN".equals(called) && 
                 ("Double".equals(argliteral) || 
                  "Float".equals(argliteral)) )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          {
            callarg1.expression.setBrackets(true); 
 
            expression = new UnaryExpression("->oclIsInvalid", callarg1.expression); 
          } 

          return "(" + callp1 + ")->oclIsInvalid()"; 
        } 
        else if ("isInfinite".equals(called) && 
                 ("Double".equals(argliteral) || 
                  "Float".equals(argliteral)) )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { Expression pinf = 
              BasicExpression.newValueBasicExpression("Math_PINFINITY"); 
            Expression eqPInf = 
              new BinaryExpression("=", arg.expression, pinf); 
            eqPInf.setBrackets(true); 
            Expression ninf = 
              BasicExpression.newValueBasicExpression("Math_NINFINITY"); 
            Expression eqNInf = 
              new BinaryExpression("=", arg.expression, ninf); 
            eqNInf.setBrackets(true); 

            expression = new BinaryExpression("or", eqPInf, eqNInf); 
            expression.setBrackets(true); 
          } 

          return "(((" + args + ") = Math_PINFINITY) or ((" + args + ") = Math_NINFINITY))"; 
        } 
        else if ("isNaN".equals(called))
        { 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->oclIsInvalid", arg.expression); } 

          return "(" + args + ")->oclIsInvalid()"; 
        } 
        else if ("isInfinite".equals(called))
        { 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { Expression pinf = 
              BasicExpression.newValueBasicExpression("Math_PINFINITY"); 
            Expression eqPInf = 
              new BinaryExpression("=", arg.expression, pinf); 
            eqPInf.setBrackets(true); 
            Expression ninf = 
              BasicExpression.newValueBasicExpression("Math_NINFINITY"); 
            Expression eqNInf = 
              new BinaryExpression("=", arg.expression, ninf); 
            eqNInf.setBrackets(true); 

            expression = new BinaryExpression("or", eqPInf, eqNInf); 
            expression.setBrackets(true); 
          } 

          return "((" + args + " = Math_PINFINITY) or (" + args + " = Math_NINFINITY))"; 
        } 
        else if ("compare".equals(called) && 
                 ("Double".equals(argliteral) || 
                  "Float".equals(argliteral)) )
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 
          
          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          {
            callarg1.expression.setBrackets(true); 

            expression = new BinaryExpression("->compareTo", callarg1.expression, callarg2.expression);
          } 

          return "(" + callp1 + ")->compareTo(" + callp2 + ")"; 
        } 
        else if ("reverse".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,
                          ASTTerm.getType(arg)); 
          
          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->reverse", callarg1.expression); 
            statement = new AssignStatement(callarg1.expression, expression); 
          }

          return callp1 + " := (" + callp1 + ")->reverse()"; 
        } 
        else if ("reverse".equals(called) && arg.isString())
        { 
          ASTTerm.setType(thisliteral,"String"); 
          
          if (arg.expression != null) 
          { expression = new UnaryExpression("->reverse", arg.expression); 
            statement = new AssignStatement(arg.expression, expression); 
          }

          return args + " := (" + args + ")->reverse()"; 
        } 
        else if ("copy".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          ASTTerm.setType(thisliteral,
                          ASTTerm.getType(arg)); 
          
          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = new UnaryExpression("->copy", callarg2.expression); 
            statement = new AssignStatement(callarg1.expression, expression); 
          }

          return callp1 + " := Sequence{}->union(" + callp2 + ")"; 
        } 
        else if ("fill".equals(called) && 
                 ("Collections".equals(args) || 
                  "Arrays".equals(args)))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"Sequence"); 
          
          if (cargs.size() == 2)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3();

            if (callarg1.expression != null && 
                callarg2.expression != null) 
            { expression = 
                new BinaryExpression("->collect", 
                                   callarg1.expression, 
                                   callarg2.expression); 
              statement = 
                new AssignStatement(callarg1.expression, 
                                    expression); 
            } 

            return callp1 + " := (" + callp1 + ")->collect(" + callp2 + ")"; 
          } 
          else if (cargs.size() > 2) 
          { ASTTerm lowind = (ASTTerm) cargs.get(1); 
            ASTTerm highind = (ASTTerm) cargs.get(2);
            ASTTerm elem = (ASTTerm) cargs.get(3);
            String lowval = lowind.toKM3(); 
            String highval = highind.toKM3(); 
            String val = elem.toKM3(); 

            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(lowind.expression); 

            Expression subrange1 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars1); 

            Vector pars2 = new Vector(); 
            pars2.add(new BinaryExpression("+",
                            lowind.expression,unitExpression)); 
            pars2.add(highind.expression); 

            Expression subrange2 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars2); 
 
            subrange2 = new BinaryExpression("->collect", subrange2, elem.expression); 
            subrange2.setBrackets(true); 

            Vector pars3 = new Vector(); 
            pars3.add(new BinaryExpression("+",
                            highind.expression,unitExpression)); 
            pars3.add(
               new UnaryExpression("->size",
                                   callarg1.expression)); 

            Expression subrange3 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callarg1.expression, pars3); 

            Expression cat1 = 
              new BinaryExpression("^", subrange2, subrange3); 
            expression = 
              new BinaryExpression("^", subrange1, cat1); 

            return callp1 + " := " + callp1 + ".subrange(1," + lowval + ")^(" + callp1 + ".subrange(" + lowval + "+1," + highval + ")->collect(" + val + "))^" + callp1 + ".subrange(" + highval + "+1," + callp1 + ".size)"; 
          }  
        } 
        else if ("nCopies".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          String elemT = ASTTerm.getType(callarg2); 
          if (elemT != null) 
          { ASTTerm.setType(thisliteral,
                            "Sequence(" + elemT + ")");
          } 
          else
          { ASTTerm.setType(thisliteral,"Sequence"); }

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BasicExpression(1)); 
            pars.add(callarg1.expression); 
            Expression subrang = BasicExpression.newFunctionBasicExpression("subrange", 
                "Integer", pars); 
            expression = new BinaryExpression("->collect", 
                subrang, callarg2.expression); 
          } 

          return "Integer.subrange(1," + callp1 + ")->collect(" + callp2 + ")"; 
        }  
        else if ("binarySearch".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 

          if (cargs.size() == 3) 
          { ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 

            Vector spars = new Vector(); 
            spars.add(callarg1.expression); 
            spars.add(callarg2.expression); 
            spars.add(callarg3.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "binarySearch", "OclComparator", spars); 
            // OclComparator.binarySearch(callp1,callp2,callp3)

            return "OclComparator.binarySearch(" + 
                    callp1 + ", " + callp2 + ", " + callp3 + ")"; 
          } 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression indof = new BinaryExpression("->indexOf", callarg1.expression, callarg2.expression); 
            expression = new BinaryExpression("-", indof, unit); 
            expression.setBrackets(true); 
          } 

          return "((" + callp1 + ")->indexOf(" + callp2 + ")-1)"; 
        } 
        else if ("search".equals(called) && arg.isSequence())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression unit = new BasicExpression(1);
            Expression incl = 
              new BinaryExpression("->includes", 
                    arg.expression, callarg1.expression);
            Expression argsze = 
              new UnaryExpression("->size", arg.expression);  
            Expression argind = 
              new BinaryExpression("->indexOf", arg.expression, callarg1.expression); 
            Expression szexpr = new BinaryExpression("-", argsze, argind); 
            szexpr = new BinaryExpression("+", szexpr, unit);

            expression = new ConditionalExpression(incl,
                               szexpr, 
                               new BasicExpression(-1)); 
          } 

          return "if (" + args + ")->includes(" + callp1 + ") then " + args + "->size() - " + args + "->indexOf(" + callp1 + ") + 1 else -1 endif"; 
        } 
        else if ("indexOfSubList".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression indof = new BinaryExpression("->indexOf", callarg1.expression, callarg2.expression); 
            expression = new BinaryExpression("-", indof, unit); 
            expression.setBrackets(true); 
          } 

          return "((" + callp1 + ")->indexOf(" + callp2 + ")-1)"; 
        }  
        else if ("lastIndexOfSubList".equals(called) && "Collections".equals(args))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression indof = new BinaryExpression("->lastIndexOf", callarg1.expression, callarg2.expression); 
            expression = new BinaryExpression("-", indof, unit); 
            expression.setBrackets(true); 
          } 

          return "((" + callp1 + ")->lastIndexOf(" + callp2 + ")-1)"; 
        }  
        else if ("Collections".equals(args) && 
                 isCollectionsWrapperOp(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this,ASTTerm.getType(callarg1)); 
     
          expression = callarg1.expression; 
    
          return callp1; 
        }  
        else if ("Collections".equals(args) && 
                 "singletonList".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemT = ASTTerm.getType(callarg1); 
          if (elemT != null) 
          { ASTTerm.setType(this, "Sequence(" + elemT + ")"); } 
          else
          { ASTTerm.setType(this,"Sequence"); }

          if (callarg1.expression != null) 
          { expression = new SetExpression(true); 
            ((SetExpression) expression).addElement(callarg1.expression); 
          }  
         
          return "Sequence{" + callp1 + "}"; 
        }  
        else if ("Collections".equals(args) && 
                 "singleton".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          String elemT = ASTTerm.getType(callarg1); 
          if (elemT != null) 
          { ASTTerm.setType(this, "Set(" + elemT + ")"); } 
          else
          { ASTTerm.setType(this,"Set"); } 

          if (callarg1.expression != null) 
          { expression = new SetExpression(); 
            ((SetExpression) expression).addElement(callarg1.expression); 
          }  
         
          return "Set{" + callp1 + "}"; 
        }  
        else if ("Collections".equals(args) && 
                 "singletonMap".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 
         
          ASTTerm.setType(this,"Map");

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = new SetExpression();
            expression.setType(new Type("Map", null));  
            ((SetExpression) expression).addMapElement(callarg1.expression, 
                                     callarg2.expression); 
          }  

          return "Map{ " + callp1 + " |-> " + callp2 + " }"; 
        }  
        else if ("toUpperCase".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->toUpperCase", callarg1.expression); } 

          return "(" + callp1 + " + \"\")->toUpperCase()"; 
        }  
        else if ("toLowerCase".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 
          if (callarg1.expression != null) 
          { expression = new UnaryExpression("->toLowerCase", callarg1.expression); } 

          return "(" + callp1 + " + \"\")->toLowerCase()"; 
        }  
        else if ("isDigit".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression digitString = 
              BasicExpression.newValueBasicExpression(
                                          "\"[0-9]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, digitString); 
          } 

          return "(" + callp1 + " + \"\")->isMatch(\"[0-9]\")"; 
        }  
        else if ("isLetter".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression letterString = 
              BasicExpression.newValueBasicExpression(
                                          "\"[a-zA-Z]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, letterString); 
          } 
          
          return "(" + callp1 + " + \"\")->isMatch(\"[a-zA-Z]\")"; 
        }  
        else if ("isLowerCase".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression lcExpr = 
              new UnaryExpression("->toLowerCase",
                                  callarg1.expression); 
            expression = 
              new BinaryExpression("=", lcExpr, 
                                   callarg1.expression); 
            expression.setBrackets(true); 
          } 

          return "(" + callp1 + "->toLowerCase() = " + callp1 + ")"; 
        }  
        else if ("isUpperCase".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
                    
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression ucExpr = 
              new UnaryExpression("->toUpperCase",
                                  callarg1.expression); 
            expression = 
              new BinaryExpression("=", ucExpr, 
                                   callarg1.expression);
            expression.setBrackets(true);  
          } 

          return "(" + callp1 + "->toUpperCase() = " + callp1 + ")"; 
        }  
        else if ("isLetterOrDigit".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression letterDigitString = 
              BasicExpression.newValueBasicExpression(
                                          "\"[a-zA-Z0-9]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, letterDigitString); 
          } 
          
          return "(" + callp1 + " + \"\")->isMatch(\"[a-zA-Z0-9]\")"; 
        }
        else if ("isJavaIdentifierPart".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression jpString = 
              BasicExpression.newValueBasicExpression(
                                    "\"[0-9a-zA-Z_$]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, jpString); 
          } 
          
          return "(" + callp1 + " + \"\")->isMatch(\"[0-9a-zA-Z_$]\")"; 
        }    
        else if ("isJavaIdentifierStart".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression jsString = 
              BasicExpression.newValueBasicExpression(
                                    "\"[a-zA-Z_$]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, jsString); 
          } 

          return "(" + callp1 + " + \"\")->isMatch(\"[a-zA-Z_$]\")"; 
        }    
        else if ("isSpaceChar".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"boolean"); 
          
          if (callarg1.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"[ \\t\\n\\r]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, spaceString); 
          } 

          return "(" + callp1 + " + \"\")->isMatch(\"[ \\t\\n\\r]\")"; 
        }    
        else if ("isWhitespace".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"boolean"); 

          if (callarg1.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"[ \\t\\n\\r]\""); 
            expression = 
              new BinaryExpression("->isMatch", 
                    callarg1.expression, spaceString); 
          } 

          return "(" + callp1 + " + \"\")->isMatch(\"[ \\t\\n\\r]\")"; 
        }    
        else if ("toString".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"\""); 
            expression = 
              new BinaryExpression("+", 
                    callarg1.expression, spaceString);
            expression.setBrackets(true);  
          } 

          return "(" + callp1 + " + \"\")"; 
        }  
        else if (("digit".equals(called) || 
                  "getNumericValue".equals(called)) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();

          ASTTerm.setType(thisliteral,"int"); 

          if (callarg1.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"\""); 
            Expression ux = 
              new BinaryExpression("+", 
                    callarg1.expression, spaceString);
            ux.setBrackets(true);
            expression = 
              new UnaryExpression("->toInteger", ux);   
          } 
          
          return "(" + callp1 + " + \"\")->toInteger()"; 
        }  
        else if ("forDigit".equals(called) && "Character".equals(argliteral))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          ASTTerm.setType(thisliteral,"String"); 

          if (callarg1.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"\""); 
            expression = 
              new BinaryExpression("+", 
                    callarg1.expression, spaceString);
            expression.setBrackets(true);  
          } 

          return "(" + callp1 + " + \"\")"; 
        }  
        else if ("getClass".equals(called))
        { ASTTerm.setType(thisliteral,"OclType"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->oclType", arg.expression); } 

          return "(" + args + ")->oclType()"; 
        } 
        else if ("finalize".equals(called))
        { if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->isDeleted", 
                                  arg.expression); 
            statement = 
              new ImplicitInvocationStatement(expression); 
          } 

          return "    execute " + args + "->isDeleted()"; 
        } 
        else if ("notify".equals(called))
        { if (arg.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "notify", "OclProcess", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression, arg.expression); 
          } 
          return "    OclProcess.notify(" + args + ")"; 
        } 
        else if ("notifyAll".equals(called))
        { if (arg.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "notifyAll", "OclProcess", arg.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression, arg.expression); 
          }
          return "    OclProcess.notifyAll(" + args + ")"; 
        } 
        else if ("wait".equals(called))
        { if (cargs.size() == 0)
          { if (arg.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(arg.expression); 
              pars.add(new BasicExpression(0)); 
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                            "wait", "OclProcess", pars); 
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars); 
            }
            return "    OclProcess.wait(" + args + ",0)"; 
          } 
          else if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            if (arg.expression != null && 
                callarg1.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(arg.expression); 
              pars.add(callarg1.expression); 
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                            "wait", "OclProcess", pars); 
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars); 
            }
            return "    OclProcess.wait(" + args + "," + callp1 + ")"; 
          } 
          else 
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(arg.expression); 
              Expression div = new BasicExpression(1000000.0);
              Expression arg2div = 
                new BinaryExpression("/", callarg2.expression, div); 
              Expression par2 = 
                new BinaryExpression("+", callarg1.expression, arg2div); 
              pars.add(par2);  
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                            "wait", "OclProcess", pars); 
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars); 
            } 
            return "    OclProcess.wait(" + args + "," + callp1 + " + " + callp2 + "/1000000.0)"; 
          }  
        } 
        else if (("schedule".equals(called) ||
                  "scheduleAtFixedRate".equals(called))
                 && arg.isProcess())
        { if (cargs.size() == 2)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newCallBasicExpression(
                            "setDelay", callarg1.expression, 
                            callarg2.expression); 
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, callarg2.expression); 
            } 
            return "    " + callp1 + ".setDelay(" + callp2 + ")"; 
          }  
          else if (cargs.size() == 3)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3();
            ASTTerm callarg3 = (ASTTerm) cargs.get(2); 
            String callp3 = callarg3.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(callarg2.expression); 
              Expression expression1 = 
                BasicExpression.newCallBasicExpression(
                            "setDelay", callarg1.expression, 
                            callarg2.expression); 
              Statement statement1 = 
                InvocationStatement.newInvocationStatement(
                  expression1, callarg2.expression); 
              Expression expression2 = 
                BasicExpression.newCallBasicExpression(
                            "setPeriod", callarg1.expression, 
                            callarg3.expression);
              Statement statement2 = 
                InvocationStatement.newInvocationStatement(
                  expression2, callarg3.expression);
              SequenceStatement sstat = 
                new SequenceStatement(); 
              sstat.addStatement(statement1); 
              sstat.addStatement(statement2);  
              statement = sstat; 
            } 
            return 
              "    " + callp1 + ".setDelay(" + callp2 + ") ;\n" +  
              "    " + callp1 + ".setPeriod(" + callp3 + ")"; 
          }  
        } 
        else if ("Thread".equals(args) && 
                 "enumerate".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();

          if (callarg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "allActiveThreads", "OclProcess"); 
            statement = 
              new AssignStatement(callarg1.expression, 
                                  expression); 
          } 
 
          return "    " + callp1 + " := OclProcess.allActiveThreads()"; 
        }   
        else if (arg.isProcess() && 
                 "join".equals(called))
        { if (cargs.size() == 0)
          { if (arg.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(new BasicExpression(0)); 
              expression = 
                BasicExpression.newCallBasicExpression(
                  "join", arg.expression, pars); 
              statement = 
                InvocationStatement.newInvocationStatement(
                                            expression,pars); 
            } 
 
            return "    " + arg + ".join(0)";
          }  
        }   
        else if (argliteral.equals("Array") || 
                 argliteral.endsWith("reflect.Array"))
        { return javalangreflectArray2KM3(arg, 
                                 call, args, 
                                 called, 
                                 cargs, 
                                 argliteral); 
        } 
        else if ("clone".equals(called))
        { if (arg.expression != null) 
          { expression = new UnaryExpression("->copy", arg.expression); } 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 

          return "(" + args + ")->copy()"; 
        } 
        else if ("doubleValue".equals(called) || "floatValue".equals(called))
        { ASTTerm.setType(thisliteral,"double"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->toReal", arg.expression); } 

          return "(" + args + " + \"\")->toReal()"; 
        } 
        else if ("booleanValue".equals(called))
        { ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->toBoolean", arg.expression); } 

          return "(" + args + " + \"\")->toBoolean()"; 
        } 
        else if ("charValue".equals(called))
        { ASTTerm.setType(thisliteral,"String"); 

          if (arg.expression != null) 
          { Expression spaceString = 
              BasicExpression.newValueBasicExpression(
                                    "\"\""); 
            expression = 
              new BinaryExpression("+", 
                    arg.expression, spaceString);
            expression.setBrackets(true);  
          } 

          return "(" + args + " + \"\")"; 
        } 
        else if ("longValue".equals(called))
        { ASTTerm.setType(thisliteral,"long"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->toLong", arg.expression); } 

          return "(" + args + " + \"\")->toLong()"; 
        } 
        else if ("byteValue".equals(called) ||
                 "intValue".equals(called) || 
                 "shortValue".equals(called))
        { ASTTerm.setType(thisliteral,"int"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->toInteger", arg.expression); } 

          return "(" + args + " + \"\")->toInteger()"; 
        } 
        else if ("hasNext".equals(called) || 
                 "hasMoreElements".equals(called) || 
                 "hasMoreTokens".equals(called))
        { String tt = ASTTerm.getType(args); 
          // JOptionPane.showInputDialog(">>> Type of " + args + " is: " + tt);  
           
          if ("OclIterator".equals(tt)) 
          { ASTTerm.setType(thisliteral,"boolean");
            if (arg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression("hasNext", arg.expression);  
            } 
            return args + ".hasNext()"; 
          } 
          else 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(called, arg.expression);  
            }
            return args + "." + calls;
          }  
        } 
        else if (arg.isFile() || 
                 "OclFile".equals(ASTTerm.getType(args) + ""))
        { return fileFeatureAccessToKM3(arg,args,call,called,
                                        callterms,cargs); 
        } 
        else if ("Assert".equals(argliteral))
        { return assertFeatureAccessToKM3(arg,args,
                                        call,called,
                                        callterms,cargs); 
        } 
        else if ("next".equals(called) || 
                 "nextElement".equals(called) || 
                 "nextToken".equals(called))
        { String tt = ASTTerm.getType(args); 
          System.out.println(">>> Type of " + args + " is: " + tt);  

          if ("OclIterator".equals(tt)) 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                                  "next", arg.expression);  
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, new Vector()); 
            } 
            ASTTerm.setType(this,"OclAny"); 

            return args + ".next()"; 
          } 
          else 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                                 called, arg.expression);  
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, new Vector()); 
            }

            return args + "." + calls; 
          } 
        } 
        else if ("countTokens".equals(called))
        { String tt = ASTTerm.getType(args); 
          // System.out.println(">>> Type of " + args + " is: " + tt);  
          // if ("OclIterator".equals(tt))
          ASTTerm.setType(thisliteral,"int"); 
           
          if (arg.expression != null) 
          { expression = 
               BasicExpression.newCallBasicExpression(
                         "length", arg.expression);   
          }

          return args + ".length()"; 
        } 
        else if ("get".equals(called) || 
                 "elementAt".equals(called)) 
        { ASTTerm callarg = (ASTTerm) callterms.get(2);
          String tt = ASTTerm.getType(args); 
          System.out.println(">>> Type of " + args + " is: " + tt);  
          String callp = callarg.toKM3();

          String elemType = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemType); 

          // System.out.println(">>>--->>> element type of " + this + " is " + elemType); 
          System.out.println(); 
 
          if (args.startsWith("Map{") && 
              args.endsWith("}"))
          { if (arg.expression != null && 
                callarg.expression != null) 
            { expression = 
                new BinaryExpression("->at", arg.expression, callarg.expression);
            }   
            return args + "->at(" + callp + ")"; 
          } 
          else if (tt != null && 
              ("Map".equals(tt) || tt.startsWith("Map(")))
          { if (arg.expression != null && 
                callarg.expression != null) 
            { expression = 
                new BinaryExpression("->at", arg.expression, callarg.expression);
            }   
            return args + "->at(" + callp + ")"; 
          } 
          else if ("OclIterator".equals(tt))
          { if (arg.expression != null && 
                callarg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                  "at", arg.expression, callarg.expression);
            }   
            return args + ".at(" + callp + ")"; 
          } 
          else if (arg.isCollection()) // ONLY for sequences
          { if (arg.expression != null && 
                callarg.expression != null) 
            { Expression unit = new BasicExpression(1); 
              Expression incr = 
                new BinaryExpression("+", callarg.expression, unit);  
              expression = 
                new BinaryExpression("->at", arg.expression, incr);
            }   
            return args + "->at(" + callp + "+1)"; 
          }  
          else 
          { expression = 
              BasicExpression.newCallBasicExpression("get",
                                     arg.expression,
                                     callarg.expression); 
            return args + ".get(" + callp + ")"; 
          } 
        }  
        else if ("size".equals(called)) 
        { ASTTerm.setType(thisliteral,"int"); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->size", arg.expression); } 

          return args + "->size()"; 
        }  
        else if ("toArray".equals(called))
           // && arg.isCollection())
        { String elemT = ASTTerm.getElementType(arg); 
          if (elemT != null) 
          { ASTTerm.setType(thisliteral,
                            "Sequence(" + elemT + ")");
          }  
          else 
          { ASTTerm.setType(thisliteral,"Sequence"); }

          if (arg.expression != null) 
          { expression = new UnaryExpression("->asSequence", arg.expression); } 

          return args + "->asSequence()"; 
        } // But with parameter, take the type from the par.
        else if ("getOrDefault".equals(called) && 
                 callterms.size() >= 2 && arg.isMap())
        { // ASTTerm.setType(thisliteral,"Sequence"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3();

          String p2type = ASTTerm.getType(callp2);  
          ASTTerm.setType(thisliteral, p2type); 

          // JOptionPane.showInputDialog("Type of " + thisliteral + " is " + p2type); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression keysexpression = 
              new UnaryExpression("->keys", arg.expression);
            Expression test = 
              new BinaryExpression("->includes", keysexpression,
                                   callarg1.expression); 
            expression = 
              new ConditionalExpression(test, 
                new BinaryExpression("->at", arg.expression,
                                     callarg1.expression), 
                callarg2.expression);  
            expression.setBrackets(true); 
          } 

          return "(if " + args + "->keys()->includes(" + 
                                            callp1 + " then " +
                 args + "->at(" + callp1 + ") else " + callp2 +
                 " endif)"; 
        } 
        else if (("put".equals(called) || 
                  "setProperty".equals(called)) && 
                 callterms.size() >= 3 &&
                 arg.isMap())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, callarg1.expression);
            expression = callarg2.expression;  
            statement = 
              new AssignStatement(lhs, callarg2.expression); 
          } 

          return args + "[" + callp1 + "] := " + callp2; 
        }  
        else if ("putIfAbsent".equals(called) && 
                 callterms.size() >= 2 &&
                 arg.isMap())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, callarg1.expression);
            Expression keysexpression = 
              new UnaryExpression("->keys", arg.expression);
            Expression test = 
              new BinaryExpression("->includes", keysexpression,
                                   callarg1.expression); 
            expression = 
              new ConditionalExpression(test, lhs, nullExpression);  
            Statement assignstatement = 
              new AssignStatement(lhs, callarg2.expression);
            statement = 
              new ConditionalStatement(test, skipStatement,
                                       assignstatement);  
          } 

          return "if " + args + "->keys()->includes(" + callp1 + ") then skip else " + args + "[" + callp1 + "] := " + callp2; 
        }  
        else if ("getProperty".equals(called) && 
                 cargs.size() >= 1 &&
                 arg.isMap())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = BasicExpression.newIndexedBasicExpression(arg.expression, callarg1.expression);
          } 

          return args + "[" + callp1 + "]"; 
        }  
        else if ("getCount".equals(called) && 
                 cargs.size() >= 1 &&
                 arg.isSortedSequence())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->count", 
                    arg.expression, callarg1.expression);
          } 

          return args + "->count(" + callp1 + ")"; 
        }  
        else if ("store".equals(called) && 
                 cargs.size() >= 1 && 
                 arg.isMap())
        { // store in a file as a Map

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          expression = 
            BasicExpression.newCallBasicExpression(
              "writeMap", callarg1.expression, arg.expression);
          statement = 
            InvocationStatement.newInvocationStatement(
                  expression, callarg1.expression);  
          return callp1 + ".writeMap(" + args + ")";  
        } 
        else if ("load".equals(called) && 
                 cargs.size() >= 1 && 
                 arg.isMap())
        { // read from a file as a Map

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          expression = 
                BasicExpression.newCallBasicExpression(
                  "readMap", callarg1.expression);
          statement = 
            new AssignStatement(arg.expression, expression); 

          return args + " := " + callp1 + ".readMap()";  
        } 
        else if ("set".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 

            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(callarg1.expression); 
             
            Expression subrange1 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars1); 

            Vector pars2 = new Vector(); 
            pars2.add(new BinaryExpression("+",
                            callarg1.expression,unitExpression)); 
            pars2.add(callarg2.expression); 

            Expression subrange2 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars2); 
 
            subrange2 = 
              new BinaryExpression("->collect", subrange2,
                                   trueExpression); 
            subrange2.setBrackets(true); 

            Vector pars3 = new Vector(); 
            pars3.add(new BinaryExpression("+",
                            callarg2.expression,unitExpression)); 
            pars3.add(
               new UnaryExpression("->size",
                                   arg.expression)); 

            Expression subrange3 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars3); 

            Expression cat1 = 
              new BinaryExpression("->union", subrange2, subrange3); 
            expression = 
              new BinaryExpression("->union", subrange1, cat1);
 
            statement = 
                new AssignStatement(arg.expression, expression);

            return args + " := " + args + ".subrange(1," + callp1 + ")->union(Integer.subrange(" + callp1 + "+1," + callp2 + ")->collect( true ))->union(" + args + ".subrange(" + callp2 + "+1))"; 
          }  
          else 
          { if (arg.expression != null && 
              callarg1.expression != null) 
            { Expression unit = new BasicExpression(1); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression, unit);  
              Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, incr); 
              Expression truebe = new BasicExpression(true); 
              statement = 
                new AssignStatement(lhs, truebe); 
            } 
            return args + "[" + callp1 + "+1] := true"; 
          }  
        }
        else if ("set".equals(called) && arg.isCollection() && callterms.size() >= 3)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression incr = 
              new BinaryExpression("+", callarg1.expression, unit);  
            Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, incr); 
            expression = callarg2.expression; 
            statement = 
              new AssignStatement(lhs, callarg2.expression); 
          } 

          return args + "[" + callp1 + "+1] := " + callp2 + ""; 
        }  
        else if ("setElementAt".equals(called) && arg.isCollection() && cargs.size() >= 2)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression incr = 
                new BinaryExpression("+", callarg2.expression, unit);  
            Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, incr); 
            expression = callarg1.expression; 
            statement = 
              new AssignStatement(lhs, callarg1.expression); 
          } 


          return args + "[" + callp2 + "+1] := " + callp1 + ""; 
        }  
        else if ("setCharAt".equals(called) && arg.isString() && cargs.size() >= 2)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null &&
              callarg2.expression != null) 
          { Vector pars = new Vector(); 
            Expression par1 = new BinaryExpression("+", callarg1.expression, new BasicExpression(1)); 
            pars.add(par1); 
            pars.add(callarg2.expression);  
            expression = BasicExpression.newFunctionBasicExpression("setAt", arg.expression, pars); 
            statement = new AssignStatement(arg.expression, expression); 
          }

          return args + " := " + args + ".setAt(" + callp1 + "+1, " + callp2 + ")"; 
        }  
        else if (("putInt".equals(called) || 
                  "putChar".equals(called) || 
                  "putLong".equals(called) || 
                  "putShort".equals(called) || 
                  "putFloat".equals(called) || 
                  "putDouble".equals(called)) && 
                 arg.isSequence() && cargs.size() >= 2)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp1 = callarg1.toKM3(); 
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null &&
              callarg2.expression != null) 
          { Vector pars = new Vector(); 
            Expression par1 = 
              new BinaryExpression("+", callarg1.expression, 
                                   new BasicExpression(1)); 
            pars.add(par1); 
         
            Vector pars1 = new Vector();
            pars1.add(callarg2.expression); 
            if ("putInt".equals(called) ||             
                "putFloat".equals(called))
            { pars1.add(new BasicExpression(4)); } 
            else if ("putChar".equals(called) || 
                     "putShort".equals(called))
            { pars1.add(new BasicExpression(2)); } 
            else if ("putLong".equals(called) || 
                     "putDouble".equals(called))
            { pars1.add(new BasicExpression(8)); } 
  
            Expression int2byts = 
                BasicExpression.newStaticCallBasicExpression(
                  "integer2Nbytes", "MathLib", pars1);
            pars.add(int2byts); 
            expression = BasicExpression.newFunctionBasicExpression(
                 "insertInto", arg.expression, pars); 
            statement = new AssignStatement(arg.expression, expression); 
          }

          return args + " := " + args + ".insertInto((" + callp1 + ") + 1, MathLib.integer2Nbytes(" + callp2 + ",4))"; 

          // return args + " := " + args + ".setAt(" + callp1 + "+1, " + callp2 + ")"; 
        }  // Plus cloning operations asFloatBuffer, etc
        else if ("setLength".equals(called) && arg.isString() && cargs.size() >= 1)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression argsize = 
              new UnaryExpression("->size", 
                    arg.expression); 
            Expression tst = 
              new BinaryExpression("<", argsize, 
                               callarg1.expression);
            Expression incr = 
              new BinaryExpression("+", argsize, 
                               unitExpression);  
            Expression defaultValue = 
              BasicExpression.newValueBasicExpression(
                                              "\"\""); 
            Vector pars = new Vector(); 
            pars.add(incr); 
            pars.add(callarg1.expression); 
            Expression subr = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", "Integer", pars); 
            Expression col =
              new BinaryExpression("->collect", subr, 
                                   defaultValue); 
            Expression ifexpr = 
              new BinaryExpression("+", arg.expression, 
                                   col); 
            Expression elseexpr = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", unitExpression, 
                callarg1.expression); 
            expression = 
              new ConditionalExpression(tst, ifexpr, elseexpr); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 
          
          return args + " := if " + args + "->size() < " + callp1 + " then " + args + " + Integer.subrange(" + args + ".size + 1," + callp1 + ")->collect(\"\\0\") else " + args + ".subrange(1," + callp1 + ") endif"; 
        }  
        else if ("reverse".equals(called) && arg.isString())
        { if (arg.expression != null) 
          { Expression rev = new UnaryExpression("->reverse", arg.expression); 
            expression = rev; 
            statement = new AssignStatement(arg.expression, rev); 
          }
          return args + " := " + args + "->reverse()"; 
        }  
        else if ("add".equals(called) && 
                 arg.isSortedSequence())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 

            if (cargs.size() > 1)
            { // arg.add(elem, cnt) becomes
              // arg := arg->union(Integer.subrange(1,cnt)->collect(elem))

              ASTTerm callarg2 = (ASTTerm) cargs.get(1);
              String callp2 = callarg2.toKM3(); 

              if (arg.expression != null && 
                  callarg1.expression != null &&
                  callarg2.expression != null) 
              { Vector pars = new Vector(); 
                pars.add(unitExpression); 
                pars.add(callarg2.expression);  
                Expression subr = BasicExpression.newFunctionBasicExpression(
                           "subrange", "Integer", pars);
                Expression collexpr = 
                  new BinaryExpression("->collect", subr, 
                                       callarg1.expression);  
                expression = 
                  new BinaryExpression("->union", arg.expression, 
                                       collexpr); 
                statement = new AssignStatement(arg.expression, expression); 
              }

              return args + " := " + args + "->union(Integer.subrange(1," + callp2 + ")->collect(" + callp1 + "))"; 
            } 
            else 
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { Expression incl = 
                  new BinaryExpression("->including", arg.expression, callarg1.expression); 
                statement = 
                  new AssignStatement(arg.expression, incl);
                expression = incl; // not the query form 
              } 
              
              return args + " := " + args + "->including(" + callp1 + ")"; 
            } 
          } 
        }
        else if (("add".equals(called) ||
                  "offerLast".equals(called) || 
                  "addLast".equals(called)) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 

            if (cargs.size() > 1)
            { // arg.add(indx, elem) becomes
              // arg := arg.insertAt(indx+1, elem)

              ASTTerm callarg2 = (ASTTerm) cargs.get(1);
              String callp2 = callarg2.toKM3(); 

              if (arg.expression != null && 
                  callarg1.expression != null &&
                  callarg2.expression != null) 
              { Vector pars = new Vector(); 
                Expression par1 = 
                  new BinaryExpression("+", callarg1.expression, unitExpression); 
                pars.add(par1); 
                pars.add(callarg2.expression);  
                expression = BasicExpression.newFunctionBasicExpression("insertAt", arg.expression, pars); 
                statement = new AssignStatement(arg.expression, expression); 
              }

              return args + " := " + args + ".insertAt(" + callp1 + " + 1, " + callp2 + ")"; 
            } 
            else 
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { Expression incl = 
                  new BinaryExpression("->including", arg.expression, callarg1.expression); 
                statement = 
                  new AssignStatement(arg.expression, incl);
                expression = incl; // not the query form 
              } 
              
              return args + " := " + args + "->including(" + callp1 + ")"; 
            } 
          } 
        }
        else if ("add".equals(called) && arg.isNumber())
        { // ASTTerm.setType(thisliteral,"real"); 
          if (cargs.size() > 0)
          { ASTTerm.setType(this, ASTTerm.getType(arg)); 

            ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null)
            { expression = new BinaryExpression("+", 
                                   arg.expression, 
                                   callarg1.expression); 
            } 
  
            return args + " + " + callp1;  
          } 
        }
        else if ("min".equals(called) && arg.isNumber())
        { if (cargs.size() > 0)
          { ASTTerm.setType(this, ASTTerm.getType(arg)); 

            ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
  
            if (arg.expression != null && 
                callarg1.expression != null)
            { SetExpression sexpr = new SetExpression(); 
              sexpr.addElement(arg.expression); 
              sexpr.addElement(callarg1.expression);
              expression = new UnaryExpression("->min", sexpr);  
            } 
  
            return "Set{" + args + ", " + callp1 + "}->min()";  
          } 
        }
        else if ("max".equals(called) && arg.isNumber())
        { if (cargs.size() > 0)
          { ASTTerm.setType(this, ASTTerm.getType(arg)); 
            ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
  
            if (arg.expression != null && 
                callarg1.expression != null)
            { SetExpression sexpr = new SetExpression(); 
              sexpr.addElement(arg.expression); 
              sexpr.addElement(callarg1.expression);
              expression = new UnaryExpression("->max", sexpr);  
            } 

            return "Set{" + args + ", " + callp1 + "}->max()";  
          } 
        }
        else if ("negate".equals(called) && arg.isNumber())
        { ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("-", arg.expression); } 

          return "-" + args; 
        }
        else if ("not".equals(called) && arg.isNumber())
        { ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null) 
          { BinaryExpression incr = 
              new BinaryExpression("+", arg.expression, 
                                   unitExpression); 
            expression = new UnaryExpression("-", incr); 
          } 

          return "-(" + args + " + 1)"; 
        }
        else if ("toBigInteger".equals(called) && arg.isNumber())
        { ASTTerm.setType(this, "long"); 

          if (arg.expression != null) 
          { BasicExpression longType = new BasicExpression(new Type("long", null)); 
            expression = new BinaryExpression("->oclAsType", arg.expression, longType); 
           } 

           return args + "->oclAsType(long)"; 
        }
        else if ("insert".equals(called) && arg.isString())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            if (cargs.size() > 1)
            { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
              String callp2 = callarg2.toKM3(); 

              if (arg.expression != null && 
                  callarg1.expression != null && 
                  callarg2.expression != null) 
              { Vector pars = new Vector(); 
                pars.add(new BinaryExpression("+", 
                           callarg1.expression, 
                           unitExpression)); 
                pars.add(callarg2.expression); 
                expression = 
                  BasicExpression.newFunctionBasicExpression(
                    "insertAt", arg.expression, pars); 
                statement = 
                  new AssignStatement(arg.expression, expression); 
              } 

              return args + " := " + args + ".insertAt(" + callp1 + " + 1, (\"\"+" + callp2 + "))"; 
            } 
          } 
        }
        else if ("insertElementAt".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null && 
              callarg2.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BinaryExpression("+", 
                           callarg2.expression, 
                           unitExpression)); 
            pars.add(callarg1.expression); 
            expression = 
               BasicExpression.newFunctionBasicExpression(
                    "insertAt", arg.expression, pars); 
            statement = 
               new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + ".insertAt(" + callp2 + " + 1, " + callp1 + ")"; 
        } 
        else if (("addFirst".equals(called) || 
                  "offerFirst".equals(called)) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                new BinaryExpression("->prepend",
                                arg.expression, 
                                callarg1.expression); 
              statement = 
                new AssignStatement(arg.expression, 
                                    expression); 
            } 
 
            return args + " := " + args + "->prepend(" + callp1 + ")"; 
          } 
        }
        else if (("addLast".equals(called) ||
                  "offerLast".equals(called) ||
                  "addElement".equals(called))
                 && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                new BinaryExpression("->append",
                                arg.expression, 
                                callarg1.expression); 
              statement = 
                new AssignStatement(arg.expression, 
                                    expression); 
            } 

            return args + " := " + args + "->append(" + callp1 + ")"; 
          } 
        }
        else if (("removeFirst".equals(called) || 
                  "pollFirst".equals(called)) && 
                 arg.isCollection())
        { if (arg.expression != null) 
          { expression = 
                new UnaryExpression("->tail", 
                                arg.expression); 
            statement = 
                new AssignStatement(arg.expression, 
                                    expression); 
          } 
 
          return args + " := " + args + "->tail()";  
        }
        else if (("removeLast".equals(called) || 
                  "pollLast".equals(called)) && 
                 arg.isCollection())
        { if (arg.expression != null) 
          { expression = 
                new UnaryExpression("->front", 
                                arg.expression); 
            statement = 
                new AssignStatement(arg.expression, 
                                    expression); 
          }

          return args + " := " + args + "->front()";  
        }
        else if ("addAll".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          if (cargs.size() > 0)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            if (cargs.size() > 1)
            { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
              String callp2 = callarg2.toKM3();

              if (arg.expression != null && 
                  callarg1.expression != null && 
                  callarg2.expression != null) 
              { Vector pars1 = new Vector(); 
                pars1.add(unitExpression); 
                pars1.add(callarg1.expression); 
                Expression subr1 = 
                  BasicExpression.newFunctionBasicExpression(
                    "subrange", arg.expression, pars1); 
                Vector pars2 = new Vector(); 
                pars2.add(new BinaryExpression("+", 
                            callarg1.expression,
                            unitExpression)); 
                Expression subr2 = 
                  BasicExpression.newFunctionBasicExpression(
                    "subrange", arg.expression, pars2); 
   
                expression = 
                  new BinaryExpression("->union", subr1, 
                    new BinaryExpression("->union", 
                      callarg2.expression, subr2)); 
                statement = 
                  new AssignStatement(arg.expression, expression); 
              } 
 
              return args + " := " + args + ".insertInto(" + callp1 + "+1, " + callp2 + ")"; 
            } 
            else 
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { expression = 
                  new BinaryExpression("->union", 
                                  arg.expression, 
                                  callarg1.expression); 
                statement = 
                  new AssignStatement(arg.expression, 
                                      expression); 
              } 

              return args + " := " + 
                       args + "->union(" + callp1 + ")"; 
            } 
          } 
        }
        else if ("add".equals(called) && arg.isNumber()) 
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null && callarg.expression != null)
          { expression = new BinaryExpression("+", arg.expression, callarg.expression); 
            expression.setBrackets(true); 
          } 

          return "(" + args + " + " + callp + ")"; 
        }
        else if ("divide".equals(called))  // BigInteger
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null && callarg.expression != null)
          { expression = new BinaryExpression("/", arg.expression, callarg.expression); 
            expression.setBrackets(true); 
          } 

          return "(" + args + " / " + callp + ")"; 
        }
        else if ("multiply".equals(called))  // BigInteger
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null && callarg.expression != null)
          { expression = new BinaryExpression("*", arg.expression, callarg.expression); 
            expression.setBrackets(true); 
          } 

          return "(" + args + " * " + callp + ")"; 
        }
        else if ("modInverse".equals(called) && arg.isNumber()) 
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, "long"); 

          if (arg.expression != null && callarg1.expression != null)
          { Vector pars = new Vector(); 
            pars.add(arg.expression); 
            pars.add(callarg1.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "modInverse", "MathLib", pars); 
          } 

          return "MathLib.modInverse(" + args + ", " + callp1 + ")"; 
        }
        else if ("modPow".equals(called) && arg.isNumber()) 
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3(); 

          ASTTerm.setType(this, "long"); 

          if (arg.expression != null && callarg1.expression != null)
          { Vector pars = new Vector(); 
            pars.add(arg.expression); 
            pars.add(callarg1.expression); 
            pars.add(callarg2.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "modPow", "MathLib", pars); 
          } 

          return "MathLib.modPow(" + args + ", " + callp1 + ", " + callp2 + ")"; 
        }
        else if ("movePointLeft".equals(called))  
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, ASTTerm.getType(arg)); 

          if (arg.expression != null && callarg1.expression != null)
          { Expression powexpr = new BinaryExpression("->pow", new BasicExpression(10), callarg1.expression); 
            BinaryExpression pexpression = new BinaryExpression("/", arg.expression, powexpr);
            pexpression.setBrackets(true); 
            expression = new BinaryExpression("->oclAsType", 
                                 pexpression, 
              BasicExpression.newTypeBasicExpression("long"));  
          } 

          return "(" + args + " * (10->pow(-" + callp1 + ")))->oclAsType(long)"; 
        }
        else if ("movePointRight".equals(called))  
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          ASTTerm.setType(this, ASTTerm.getType(arg)); 


          if (arg.expression != null && callarg1.expression != null)
          { Expression powexpr = new BinaryExpression("->pow", new BasicExpression(10), callarg1.expression); 
            BinaryExpression pexpression = 
              new BinaryExpression("*", arg.expression, powexpr); 
            pexpression.setBrackets(true); 
            expression = new BinaryExpression("->oclAsType", 
                                 pexpression, 
              BasicExpression.newTypeBasicExpression("long"));  
          } 

          return "(" + args + " * (10->pow(" + callp1 + ")))->oclAsType(long)"; 
        }
        else if ("and".equals(called) && arg.isInteger())
        { ASTTerm.setType(this, "long");

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(arg.expression); 
            parms.add(callarg1.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseAnd", "MathLib", parms); 
          } 

          return "MathLib.bitwiseAnd(" + args + ", " + callp1 + ")"; 
        } 
        else if ("or".equals(called) && arg.isInteger())
        { ASTTerm.setType(this, "long");

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(arg.expression); 
            parms.add(callarg1.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseOr", "MathLib", parms); 
          } 

          return "MathLib.bitwiseOr(" + args + ", " + callp1 + ")"; 
        } 
        else if ("xor".equals(called) && arg.isInteger())
        { ASTTerm.setType(this, "long");

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(arg.expression); 
            parms.add(callarg1.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseXor", "MathLib", parms); 
          } 

          return "MathLib.bitwiseXor(" + args + ", " + callp1 + ")"; 
        } 
        else if ("signum".equals(called))  
        { ASTTerm.setType(this, "int"); 

          if (arg.expression != null) 
          { expression = 
              new BinaryExpression("->compareTo", arg.expression,
                    new BasicExpression(0)); 
          }

          return args + "->compareTo(0)";
        }
        else if ("bitLength".equals(called) && arg.isInteger())  
        { ASTTerm.setType(this, "int"); 

          if (arg.expression != null) 
          { Expression tobitseq = 
              BasicExpression.newStaticCallBasicExpression(
                "toBitSequence", "MathLib", arg.expression);  
            expression = 
              new UnaryExpression("->size", tobitseq); 
          }

          return "MathLib.toBitSequence(" + args + ")->size()";
        }
        else if ("bitCount".equals(called) && arg.isInteger())  
        { ASTTerm.setType(this, "int"); 

          if (arg.expression != null) 
          { Expression tobitseq = 
              BasicExpression.newStaticCallBasicExpression(
                "toBitSequence", "MathLib", arg.expression);  
            expression = 
              new BinaryExpression("->count", tobitseq, 
                    new BasicExpression(true)); 
          }

          return "MathLib.toBitSequence(" + args + ")->count(true)";
        }
        else if ("getLowestSetBit".equals(called) && arg.isInteger())  
        { ASTTerm.setType(this, "int"); 

          if (arg.expression != null) 
          { Expression tobitseq = 
              BasicExpression.newStaticCallBasicExpression(
                "toBitSequence", "MathLib", arg.expression);
            Expression revtobitseq = 
              new UnaryExpression("->reverse", tobitseq);   
            Expression indofexpression = 
              new BinaryExpression("->indexOf", revtobitseq, 
                    new BasicExpression(true)); 
            expression = new BinaryExpression("-", 
                           indofexpression, unitExpression); 
            expression.setBrackets(true); 
          }

          return "(MathLib.toBitSequence(" + args + ")->reverse()->indexOf(true) - 1)";
        }
        else if ("subtract".equals(called) && arg.isNumber())  // BigInteger
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg));

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = new BinaryExpression("-", 
                                 arg.expression, 
                                 callarg.expression); 
            expression.setBrackets(true); 
          } 
 
          return "(" + args + " - " + callp + ")"; 
        }
        else if ("and".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression == null || 
              callarg1.expression == null) 
          { 
            return args + " := Integer.subrange(1, Set{" + args + ".size," + 
              callp1 + ".size}->min())->collect( _i | " + 
              args + "[_i] and " + callp1 + "[_i] )"; 
          } 

          Expression argsize = 
            new UnaryExpression("->size", arg.expression); 
          argsize.setType(new Type("int", null)); 
          Expression p1size = 
            new UnaryExpression("->size", 
                                callarg1.expression); 
          p1size.setType(new Type("int", null)); 

          SetExpression setexpr = new SetExpression(); 
          setexpr.addElement(argsize); 
          setexpr.addElement(p1size); 
          Expression minExpr = 
            new UnaryExpression("->min", setexpr); 
                     
          Vector pars = new Vector(); 
          pars.add(unitExpression); 
          pars.add(minExpr); 

          Expression subr = 
            BasicExpression.newFunctionBasicExpression(
              "subrange", "Integer", pars); 

          String ivar = 
            Identifier.nextIdentifier("_i"); 
          BasicExpression ix = new BasicExpression(ivar); 
          Expression coldom =
            new BinaryExpression(":", ix, subr); 

          Expression argi = 
            BasicExpression.newIndexedBasicExpression(
                                arg.expression, ix); 

          Expression pari = 
            BasicExpression.newIndexedBasicExpression(
                                callarg1.expression, ix); 

          Expression colrng = 
            new BinaryExpression("&", argi, pari); 
          colrng.setType(new Type("boolean", null)); 

          expression = 
            new BinaryExpression("|C", coldom, colrng); 
          statement = 
            new AssignStatement(arg.expression, expression); 

          return args + " := Integer.subrange(1, Set{" + args + ".size," + callp1 + ".size}->min())->collect( _i | " + args + "[_i] and " + callp1 + "[_i] )"; 
        }
        else if ("andNot".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression == null || 
              callarg1.expression == null) 
          { 
            return args + " := Integer.subrange(1, Set{" + args + ".size," + 
              callp1 + ".size}->min())->collect( _i | " + 
              args + "[_i] and not(" + callp1 + "[_i]) )"; 
          } 

          Expression argsize = 
            new UnaryExpression("->size", arg.expression); 
          argsize.setType(new Type("int", null)); 
          Expression p1size = 
            new UnaryExpression("->size", 
                                callarg1.expression); 
          p1size.setType(new Type("int", null)); 

          SetExpression setexpr = new SetExpression(); 
          setexpr.addElement(argsize); 
          setexpr.addElement(p1size); 
          Expression minExpr = 
            new UnaryExpression("->min", setexpr); 
                     
          Vector pars = new Vector(); 
          pars.add(unitExpression); 
          pars.add(minExpr); 

          Expression subr = 
            BasicExpression.newFunctionBasicExpression(
              "subrange", "Integer", pars); 

          String ivar = 
            Identifier.nextIdentifier("_i"); 
          BasicExpression ix = new BasicExpression(ivar); 
          Expression coldom =
            new BinaryExpression(":", ix, subr); 

          Expression argi = 
            BasicExpression.newIndexedBasicExpression(
                                arg.expression, ix); 

          Expression pari = 
            BasicExpression.newIndexedBasicExpression(
                                callarg1.expression, ix); 

          Expression notpari = 
            new UnaryExpression("not", pari); 
          notpari.setBrackets(true); 

          Expression colrng = 
            new BinaryExpression("&", argi, notpari); 
          colrng.setType(new Type("boolean", null)); 

          expression = 
            new BinaryExpression("|C", coldom, colrng); 
          statement = 
            new AssignStatement(arg.expression, expression); 

          return args + " := Integer.subrange(1, Set{" + args + ".size," + callp1 + ".size}->min())->collect( _i | " + args + "[_i] and not(" + callp1 + "[_i]) )"; 
        }
        else if ("or".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression == null || 
              callarg1.expression == null) 
          { 
            return args + " := Integer.subrange(1, Set{" + args + ".size," + 
              callp1 + ".size}->min())->collect( _i | " + 
              args + "[_i] or " + callp1 + "[_i] )"; 
          } 

          Expression argsize = 
            new UnaryExpression("->size", arg.expression); 
          argsize.setType(new Type("int", null)); 
          Expression p1size = 
            new UnaryExpression("->size", 
                                callarg1.expression); 
          p1size.setType(new Type("int", null)); 

          SetExpression setexpr = new SetExpression(); 
          setexpr.addElement(argsize); 
          setexpr.addElement(p1size); 
          Expression minExpr = 
            new UnaryExpression("->min", setexpr); 
                     
          Vector pars = new Vector(); 
          pars.add(unitExpression); 
          pars.add(minExpr); 

          Expression subr = 
            BasicExpression.newFunctionBasicExpression(
              "subrange", "Integer", pars); 

          String ivar = 
            Identifier.nextIdentifier("_i"); 
          BasicExpression ix = new BasicExpression(ivar); 
          Expression coldom =
            new BinaryExpression(":", ix, subr); 

          Expression argi = 
            BasicExpression.newIndexedBasicExpression(
                                arg.expression, ix); 

          Expression pari = 
            BasicExpression.newIndexedBasicExpression(
                                callarg1.expression, ix); 

          Expression colrng = 
            new BinaryExpression("or", argi, pari); 
          colrng.setType(new Type("boolean", null)); 

          expression = 
            new BinaryExpression("|C", coldom, colrng); 
          statement = 
            new AssignStatement(arg.expression, expression); 

          return args + " := Integer.subrange(1, Set{" + args + ".size," + callp1 + ".size}->min())->collect( _i | " + args + "[_i] or " + callp1 + "[_i] )"; 
        }
        else if ("xor".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (arg.expression == null || 
              callarg1.expression == null) 
          { 
            return args + " := Integer.subrange(1, Set{" + args + ".size," + 
              callp1 + ".size}->min())->collect( _i | " + 
              args + "[_i] xor " + callp1 + "[_i] )"; 
          } 

          Expression argsize = 
            new UnaryExpression("->size", arg.expression); 
          argsize.setType(new Type("int", null)); 
          Expression p1size = 
            new UnaryExpression("->size", 
                                callarg1.expression); 
          p1size.setType(new Type("int", null)); 

          SetExpression setexpr = new SetExpression(); 
          setexpr.addElement(argsize); 
          setexpr.addElement(p1size); 
          Expression minExpr = 
            new UnaryExpression("->min", setexpr); 
                     
          Vector pars = new Vector(); 
          pars.add(unitExpression); 
          pars.add(minExpr); 

          Expression subr = 
            BasicExpression.newFunctionBasicExpression(
              "subrange", "Integer", pars); 

          String ivar = 
            Identifier.nextIdentifier("_i"); 
          BasicExpression ix = new BasicExpression(ivar); 
          Expression coldom =
            new BinaryExpression(":", ix, subr); 

          Expression argi = 
            BasicExpression.newIndexedBasicExpression(
                                arg.expression, ix); 

          Expression pari = 
            BasicExpression.newIndexedBasicExpression(
                                callarg1.expression, ix); 

          Expression colrng = 
            new BinaryExpression("xor", argi, pari); 
          colrng.setType(new Type("boolean", null)); 

          expression = 
            new BinaryExpression("|C", coldom, colrng); 
          statement = 
            new AssignStatement(arg.expression, expression); 

          return args + " := Integer.subrange(1, Set{" + args + ".size," + callp1 + ".size}->min())->collect( _i | " + args + "[_i] xor " + callp1 + "[_i] )"; 
        }
        else if ("flip".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 
          
            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(callarg1.expression); 
             
            Expression subrange1 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars1); 

            Vector pars2 = new Vector(); 
            pars2.add(new BinaryExpression("+",
                            callarg1.expression,unitExpression)); 
            pars2.add(callarg2.expression); 

            Expression subrange2 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars2); 

            String ivar = 
              Identifier.nextIdentifier("_i"); 
            BasicExpression ix = new BasicExpression(ivar); 

            Expression argi = 
              BasicExpression.newIndexedBasicExpression(
                                arg.expression, ix); 
 
            Expression notargsi = 
               new UnaryExpression("not", argi); 

            Expression coldom = 
              new BinaryExpression(":", ix, subrange2); 

            subrange2 = 
              new BinaryExpression("|C", coldom,
                                   notargsi); 
            subrange2.setBrackets(true); 

            Vector pars3 = new Vector(); 
            pars3.add(new BinaryExpression("+",
                         callarg2.expression,unitExpression)); 
            pars3.add(
               new UnaryExpression("->size",
                                   arg.expression)); 

            Expression subrange3 = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars3); 

            Expression cat1 = 
              new BinaryExpression("->union", subrange2, subrange3); 
            expression = 
              new BinaryExpression("->union", subrange1, cat1);
 
            statement = 
                new AssignStatement(arg.expression, expression);

            return args + " := " + args + ".subrange(1," + callp1 + ")->union(Integer.subrange(" + callp1 + "+1," + callp2 + ")->collect( _i | not(" + args + "[_i])))->union(" + args + ".subrange(" + callp2 + "+1))"; 
          }  
          else 
          { if (arg.expression != null && 
              callarg1.expression != null) 
            { Expression unit = new BasicExpression(1); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression, unit);  
              Expression lhs = BasicExpression.newIndexedBasicExpression(arg.expression, incr); 
              Expression notExpr = 
                new UnaryExpression("not", lhs); 
              statement = 
                new AssignStatement(lhs, notExpr); 
            } 
            return args + "[" + callp1 + "+1] := not(" + args + "[" + callp1 + "+1])"; 
          }  
        }
        else if ("cardinality".equals(called) && arg.isBitSet())  // BitSet
        { ASTTerm.setType(thisliteral,"int"); 
          if (arg.expression != null) 
          { Expression truebe = new BasicExpression(true); 
            expression = 
              new BinaryExpression("->count", 
                                   arg.expression, truebe); 
          } 
       
          return args + "->count( true )";   
        }
        else if ("putAll".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          ASTTerm.setType(thisliteral,ASTTerm.getType(arg)); 
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->union", 
                                   arg.expression, 
                                   callarg.expression); 
          } 
       
          return args + " := " + args + "->union(" + callp + ")"; 
        }
        else if ("charAt".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.queryForm();
          args = arg.queryForm();  
          ASTTerm.setType(thisliteral,"String");       

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression indx = 
              new BinaryExpression("+", callarg.expression, 
                                   unitExpression); 
            expression = 
              new BinaryExpression("->at", 
                                  arg.expression, indx); 
          } 
 
          return args + "->at(" + callp + " + 1)"; 
        }
        else if ("characters".equals(called) || "toCharArray".equals(called))
        { ASTTerm.setType(thisliteral,"Sequence(String)"); 
          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->characters", 
                                   arg.expression); 
          } 
          return args + "->characters()"; 
        }
        else if ("toUpperCase".equals(called) || "toLowerCase".equals(called))
        { ASTTerm.setType(thisliteral,"String"); 
          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->" + called, 
                                   arg.expression); 
          } 
          return args + "->" + called + "()";
        }
        else if ("indexOf".equals(called))
        { ASTTerm.setType(thisliteral,"int"); 
          
          if (cargs.size() == 1)
          { ASTTerm arg1 = (ASTTerm) cargs.get(0); 
            String callp = arg1.toKM3(); 

            if (arg.expression != null && 
                arg1.expression != null) 
            { Expression indof = 
                new BinaryExpression("->indexOf", 
                                 arg.expression, 
                                 arg1.expression); 
              expression = 
                new BinaryExpression("-", indof, 
                                     unitExpression); 
              expression.setBrackets(true); 
            } 
          
            return "(" + args + "->indexOf(" + callp + ") - 1)"; 
          }
          else if (cargs.size() == 2) 
          { ASTTerm arg1 = (ASTTerm) cargs.get(0); 
            String callp1 = arg1.toKM3(); 
            ASTTerm arg2 = (ASTTerm) cargs.get(1); 
            String callp2 = arg2.toKM3(); 
          
            if (arg.expression != null && 
                arg1.expression != null && 
                arg2.expression != null) 
            { BasicExpression elseExpr = 
                new BasicExpression(-1); 
              Vector pars1 = new Vector(); 
              pars1.add(new BinaryExpression("+", 
                          arg2.expression, unitExpression)); 
              Expression subr1 = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars1);
              Expression indof = 
                new BinaryExpression("->indexOf", 
                      subr1, arg1.expression);  
              Expression tst = 
                new BinaryExpression(">", indof, 
                      new BasicExpression(0)); 
              Expression ifExpr = 
                new BinaryExpression("+", 
                      indof, arg2.expression); 
              ifExpr = 
                new BinaryExpression("-", 
                      ifExpr, unitExpression); 
              
              expression = 
                new ConditionalExpression(tst, ifExpr, 
                                          elseExpr); 
            } 

            return "if " + args + ".subrange(" + callp2 + "+1, " + args + ".size)->indexOf(" + callp1 + "+\"\") > 0 then (" + args + ".subrange(" + callp2 + "+1, " + args + ".size)->indexOf(" + callp1 + "+\"\") + " + callp2 + " - 1) else -1 endif"; 
          }
        }
        else if ("lastIndexOf".equals(called))
        { ASTTerm.setType(thisliteral,"int"); 

          if (cargs.size() == 1)
          { ASTTerm arg1 = (ASTTerm) cargs.get(0); 
            String callp = arg1.toKM3(); 
     
            if (arg.expression != null && 
                arg1.expression != null) 
            { Expression indof = 
                new BinaryExpression("->lastIndexOf", 
                                 arg.expression, 
                                 arg1.expression); 
              expression = 
                new BinaryExpression("-", indof, 
                                     unitExpression); 
              expression.setBrackets(true); 
            } 
          
            return "(" + args + "->lastIndexOf(" + callp + ") - 1)"; }
          else if (cargs.size() == 2) 
          { ASTTerm arg1 = (ASTTerm) cargs.get(0); 
            String callp1 = arg1.toKM3(); 
            ASTTerm arg2 = (ASTTerm) cargs.get(1); 
            String callp2 = arg2.toKM3(); 

            if (arg.expression != null && 
                arg1.expression != null && 
                arg2.expression != null) 
            { Vector pars1 = new Vector();
              pars1.add(unitExpression);  
              pars1.add(new BinaryExpression("+", 
                          arg2.expression, unitExpression)); 
              Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars1);
              Expression ifExpr = 
                new BinaryExpression("->lastIndexOf", 
                      subr, arg1.expression); 
              expression = 
                new BinaryExpression("-", 
                      ifExpr, unitExpression); 
              expression.setBrackets(true); 
            } 
          
            return "(" + args + ".subrange(1, " + callp2 + "+1)->lastIndexOf(" + callp1 + "+\"\") - 1)"; 
          }
        }
        else if ("substring".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"String"); 
    
          BasicExpression unit = new BasicExpression(1); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression, 
                                     unit); 
              pars.add(incr); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newCallBasicExpression(
                     "subrange", 
                     arg.expression, pars); 
            } 

            return args + ".subrange(" + callp1 + " + 1, " + callp2 + ")";
          } 
          else 
          { if (arg.expression != null && 
                callarg1.expression != null) 
            { Vector pars = new Vector(); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression, 
                                     unit); 
              pars.add(incr); 
              Expression sze = 
                new UnaryExpression("->size", callarg1.expression); 
              pars.add(sze); 

              expression = 
                BasicExpression.newCallBasicExpression(
                     "subrange", 
                     arg.expression, pars); 
            } 
            return args + ".subrange(" + callp1 + " + 1, " + args + "->size())"; 
          } 
        }  
        else if ("replaceAll".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"String"); 
    
          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(callarg1.expression); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newCallBasicExpression(
                     "replaceAllMatches", 
                     arg.expression, pars); 
            } 

            return args + ".replaceAllMatches(" + callp1 + ", " + callp2 + ")";
          } 
        }  
        else if ("replaceFirst".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"String"); 
    
          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(callarg1.expression); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newCallBasicExpression(
                     "replaceFirstMatch", 
                     arg.expression, pars); 
            } 
          
            return args + ".replaceFirstMatch(" + callp1 + ", " + callp2 + ")";
          } 
        }  
        else if ("split".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"Sequence(String)"); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->split", arg.expression, callarg1.expression); 
          } 
    
          return args + "->split(" + callp1 + ")";
        }  
        else if ("trim".equals(called))
        { ASTTerm.setType(thisliteral,"String"); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->trim", arg.expression); 
          } 

          return args + "->trim()"; 
        }  
        else if ("isEmpty".equals(called))
        { ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { expression = 
              new BinaryExpression("=", arg.expression, 
                                   emptyStringExpression);
            expression.setBrackets(true);  
          } 

          return args + " = \"\""; 
        }  
        else if ("intern".equals(called))
        { ASTTerm.setType(thisliteral,"String"); 
          expression = arg.expression; 

          return "(" + args + " + \"\")"; 
        }  
        else if ("concat".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"String"); 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("+", arg.expression, callarg.expression);
            expression.setBrackets(true);  
          } 

          return "(" + args + " + " + callp + ")"; 
        }
        else if ("endsWith".equals(called) && arg.isString())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"boolean");

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->hasSuffix", arg.expression, callarg.expression); 
          } 

          return args + "->hasSuffix(" + callp + ")";   
        }
        else if ("equals".equals(called) && 
                 "Arrays".equals(arg.literalForm()))
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          
          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = 
              new BinaryExpression("=", callarg1.expression, callarg2.expression); 
          } 

          return "(" + callp1 + " = " + callp2 + ")"; 
        }
        else if ("equals".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.isIdentifier() && callarg1.isIdentifier() && 
              (arg.isCollection() || callarg1.isCollection())
             )
          { if (arg.expression != null && 
              callarg1.expression != null) 
            { expression = 
                new BinaryExpression("<>=", 
                  arg.expression, 
                  callarg1.expression); 
            } 
            return args + " <>= " + callp1; 
          }  

          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("=", arg.expression, callarg1.expression); 
          } 

          return args + " = " + callp; 
        }
        else if ("equalsIgnoreCase".equals(called) && 
                 arg.isString())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
            
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("=", 
                new UnaryExpression("->toLowerCase", arg.expression), 
                new UnaryExpression("->toLowerCase", callarg.expression)); 
            expression.setBrackets(true); 
          } 
            
          return "(" + args + "->toLowerCase() = " + callp + "->toLowerCase())"; 
        }
        else if ("compareTo".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"int");
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->compareTo", arg.expression, callarg.expression); 
          } 

          return args + "->compareTo(" + callp + ")"; 
        }
        else if ("compareToIgnoreCase".equals(called) && 
                 arg.isString())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"int");
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->compareTo", 
                new UnaryExpression("->toLowerCase", arg.expression), 
                new UnaryExpression("->toLowerCase", callarg.expression)); 
            expression.setBrackets(true); 
          } 

          return args + "->toLowerCase()->compareTo(" + callp + "->toLowerCase())"; 
        }
        else if ("regionMatches".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
            
          ASTTerm.setType(thisliteral,"boolean"); 

          if (cargs.size() > 3) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 
            ASTTerm callarg4 = (ASTTerm) cargs.get(3);
            String callp4 = callarg4.toKM3(); 

            return "(" + args + ".subrange(" + callp1 + "+1," + callp1 + "+" + callp4 + ") = " + callp2 + ".subrange(" + callp3 + "+1, " + callp3 + "+" + callp4 + "))";
          } 
        }
        else if ("subList".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
            
          ASTTerm.setType(thisliteral,"Sequence"); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression par1 = 
                new BinaryExpression("+", 
                    callarg1.expression, unitExpression); 
              Vector pars = new Vector(); 
              pars.add(par1); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars); 
            } 

            return args + ".subrange(" + callp1 + " + 1, " + callp2 + ")";
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression par1 = 
              new BinaryExpression("+", 
                    callarg1.expression, unitExpression); 
            Expression par2 = 
              new UnaryExpression("->size", arg.expression); 
            Vector pars = new Vector(); 
            pars.add(par1); 
            pars.add(par2); 
            expression = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars); 
          } 

          return args + ".subrange(" + callp1 + " + 1, " + args + "->size())"; 
        }
        else if ("subSequence".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
            
          ASTTerm.setType(thisliteral,"String"); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression par1 = 
                new BinaryExpression("+", 
                    callarg1.expression, unitExpression); 
              Vector pars = new Vector(); 
              pars.add(par1); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars); 
            } 

            return args + ".subrange(" + callp1 + " + 1, " + callp2 + ")";
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression par1 = 
              new BinaryExpression("+", 
                    callarg1.expression, unitExpression); 
            Expression par2 = 
              new UnaryExpression("->size", arg.expression); 
            Vector pars = new Vector(); 
            pars.add(par1); 
            pars.add(par2); 
            expression = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", arg.expression, pars); 
          } 

          return args + ".subrange(" + callp1 + " + 1, " + args + "->size())"; 
        }
        else if ("headSet".equals(called) && arg.isSet())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"Set"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression x0Expr = 
              BasicExpression.newVariableBasicExpression("x_0"); 
            Expression tst = 
              new BinaryExpression("<", 
                    x0Expr, callarg.expression); 
            Expression par2 = 
              new BinaryExpression(":", x0Expr, arg.expression); 
            expression = 
              new BinaryExpression("|", par2, tst); 
          } 

          return args + "->select( x_0 | x_0 < " + callp + ")"; 
        }
        else if ("tailSet".equals(called) && arg.isSet())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"Set"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression x0Expr = 
              BasicExpression.newVariableBasicExpression("x_0"); 
            Expression tst = 
              new BinaryExpression(">=", 
                    x0Expr, callarg.expression); 
            Expression par2 = 
              new BinaryExpression(":", x0Expr, arg.expression); 
            expression = 
              new BinaryExpression("|", par2, tst); 
          } 

          return args + "->select( x_0 | x_0 >= " + callp + ")"; 
        }
        else if ("subSet".equals(called) && arg.isSet())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"Set"); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression keyExpr = 
                BasicExpression.newVariableBasicExpression(
                                          "_key"); 
              Expression tst1 = 
                new BinaryExpression(">=", 
                    keyExpr, callarg1.expression); 
              Expression tst2 = 
                new BinaryExpression("<", 
                    keyExpr, callarg2.expression); 
              Expression par2 = 
                new BinaryExpression(":", keyExpr,  
                                     arg.expression);
              BinaryExpression tst = 
                new BinaryExpression("&", tst1, tst2);  
              expression = 
                new BinaryExpression("|", par2, 
                                     tst);
            } 

            return args + "->select( _key | _key >= " + callp1 + " & _key < " + callp2 + ")";
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression keyExpr = 
              BasicExpression.newVariableBasicExpression("_key"); 
            Expression tst = 
              new BinaryExpression(">=", 
                    keyExpr, callarg1.expression); 
            Expression par2 = 
              new BinaryExpression(":", keyExpr, 
                                   arg.expression); 
            expression = 
              new BinaryExpression("|", par2, tst);  
          } 

          return args + "->select( _key | _key >= " + callp1 + ") )"; 
        }
        else if ("headMap".equals(called) && arg.isMap())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"Map"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression keyExpr = 
              BasicExpression.newVariableBasicExpression("_key"); 
            Expression tst = 
              new BinaryExpression("<", 
                    keyExpr, callarg.expression); 
            Expression par2 = 
              new BinaryExpression(":", keyExpr, 
                new UnaryExpression("->keys", 
                                    arg.expression)); 
            Expression selExpr = 
              new BinaryExpression("|", par2, tst);
            expression = 
              new BinaryExpression("->restrict", 
                    arg.expression, selExpr);  
          } 


          return args + "->restrict( " + args + "->keys()->select( _key | _key < " + callp + ") )"; 
        }
        else if ("subMap".equals(called) && arg.isMap())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm.setType(thisliteral,"Map"); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression keyExpr = 
              BasicExpression.newVariableBasicExpression("_key"); 
              Expression tst1 = 
                new BinaryExpression(">=", 
                    keyExpr, callarg1.expression); 
              Expression tst2 = 
                new BinaryExpression("<", 
                    keyExpr, callarg2.expression); 
              Expression par2 = 
                new BinaryExpression(":", keyExpr, 
                  new UnaryExpression("->keys", 
                                    arg.expression)); 
              Expression selExpr = 
                new BinaryExpression("|", par2, 
                  new BinaryExpression("&", tst1, tst2));
              expression = 
                new BinaryExpression("->restrict", 
                    arg.expression, selExpr);  
            } 

            return args + "->restrict( " + args + "->keys()->select( _key | _key >= " + callp1 + " & _key < " + callp2 + ") )";
          } 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression keyExpr = 
              BasicExpression.newVariableBasicExpression("_key"); 
            Expression tst = 
              new BinaryExpression(">=", 
                    keyExpr, callarg1.expression); 
            Expression par2 = 
              new BinaryExpression(":", keyExpr, 
                new UnaryExpression("->keys", 
                                    arg.expression)); 
            Expression selExpr = 
              new BinaryExpression("|", par2, tst);
            expression = 
              new BinaryExpression("->restrict", 
                    arg.expression, selExpr);  
          } 

          return args + "->restrict( " + args + "->keys()->select( _key | _key >= " + callp1 + ") )"; 
        }
        else if ("tailMap".equals(called) && arg.isMap())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"Map"); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression keyExpr = 
              BasicExpression.newVariableBasicExpression("_key"); 
            Expression tst = 
              new BinaryExpression(">=", 
                    keyExpr, callarg.expression); 
            Expression par2 = 
              new BinaryExpression(":", keyExpr, 
                new UnaryExpression("->keys", 
                                    arg.expression)); 
            Expression selExpr = 
              new BinaryExpression("|", par2, tst);
            expression = 
              new BinaryExpression("->restrict", 
                    arg.expression, selExpr);  
          } 


          return args + "->restrict( " + args + "->keys()->select( _key | _key >= " + callp + ") )"; 
        }
        else if ("removeRange".equals(called))
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
                      
          ASTTerm.setType(thisliteral,
                          ASTTerm.getType(arg)); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(unitExpression); 
              pars.add(callarg1.expression); 
              Expression subr1 = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars);
              Expression par = 
                new BinaryExpression("+", callarg2.expression,
                                     unitExpression); 
              Expression subr2 = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, par); 
              expression = 
                new BinaryExpression("->union", subr1, subr2); 
            }

            return args + ".subrange(1," + callp1 + ")->union(" + args + ".subrange(" + callp2 + "+1))";
          } 

          expression = arg.expression; 
          return args; 
        }
        else if ("trimToSize".equals(called))
        { return "// " + args + ".trimToSize()"; }
        else if ("ensureCapacity".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          return "// " + args + ".ensureCapacity(" + callp1 + ")"; 
        } 
        else if ("delete".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
                      
          ASTTerm.setType(thisliteral,"String"); 

          if (cargs.size() > 1) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars1 = new Vector(); 
              pars1.add(unitExpression); 
              pars1.add(callarg1.expression); 
              Expression subr1 = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars1); 
              Vector pars2 = new Vector(); 
              pars2.add(new BinaryExpression("+", 
                          callarg2.expression, 
                          unitExpression)); 
              Expression subr2 = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, pars2); 
              expression = new BinaryExpression("+", 
                                 subr1, subr2); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            } 

            return args + " := " + args + ".subrange(1," + callp1 + ") + " + 
                   args + ".subrange(" + callp2 + "+1)";
          } 
          return args; 
        }
        else if ("removeAll".equals(called) && 
                 callterms.size() > 2)
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("-", arg.expression, callarg.expression);
            statement = 
              new AssignStatement(arg.expression, expression);  
          } 

          return args + " := " + args + " - " + callp; 
        }
        else if (("clear".equals(called) && 
                  (arg.isCollection() || arg.isMap()) ) || 
                 "removeAllElements".equals(called))
        { if (arg.expression != null) 
          { expression = 
              new BinaryExpression("->intersection", 
                    arg.expression, 
                    new SetExpression()); 
            statement = 
              new AssignStatement(arg.expression, 
                                  expression); 
          } 

          return args + " := " + args + "->intersection(Set{})"; 
        }
        else if ("entrySet".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"Set"); 
          ASTTerm.setElementType(this,
                     ASTTerm.getElementType(arg)); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->asSet", arg.expression); 
          } 
          // mm->keys()->collect(k| Map{k |-> mm[k]})->asSet()

          return args + "->asSet()"; 
        } // a set of singleton maps. 
        else if ("uniqueSet".equals(called) && arg.isSequence())
        { ASTTerm.setType(thisliteral,"Set"); 
          ASTTerm.setElementType(this,
                     ASTTerm.getElementType(arg)); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->asSet", arg.expression); 
          } 

          return args + "->asSet()"; 
        } 
        else if ("getKey".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"String"); // usually  

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->any", 
                new UnaryExpression("->keys",
                                    arg.expression)); 
          } 

          return args + "->keys()->any()"; 
        } // on singleton map. 
        else if ("getValue".equals(called) && arg.isMap())
        { ASTTerm.setType(this,ASTTerm.getElementType(arg)); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->any", 
                new UnaryExpression("->values",
                                    arg.expression)); 
          } 

          return args + "->values()->any()"; 
        } // on a singleton map. 
        else if ("getBoolean".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(boolean)"; 
        } // for JsonObjects
        else if ("getInt".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"int"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(int)"; 
        } // for JsonObjects
        else if ("getJsonNumber".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"double"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(double)"; 
        } // for JsonObjects
        else if ("getJsonArray".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"Sequence"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(Sequence)"; 
        } // for JsonObjects
        else if ("getJsonObject".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"Map"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(Map)"; 
        } // for JsonObjects
        else if (("getJsonString".equals(called) ||
                  "getString".equals(called)) && arg.isMap())
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { expression = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression); 
          } 

          return args + "->at(" + callp1 + ")->oclAsType(String)"; 
        } // for JsonObjects
        else if ("isNull".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression mapelem = 
              new BinaryExpression("->at", arg.expression, 
                                   callarg1.expression);
            expression = 
              new UnaryExpression("->oclIsUndefined", mapelem);  
          } 

          return args + "->at(" + callp1 + ")->oclIsUndefined()"; 
        } // for JsonObjects
        else if ("getBoolean".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(boolean)"; 
        } // for JsonArray
        else if ("getInt".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"int"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(int)"; 
        } // for JsonArray
        else if ("getJsonArray".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"Sequence"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(Sequence)"; 
        } // for JsonArray
        else if ("getJsonNumber".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"double"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(double)"; 
        } // for JsonArray
        else if ("getJsonObject".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"Map"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(Map)"; 
        } // for JsonArray
        else if (("getJsonString".equals(called) ||
                  "getString".equals(called)) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            expression = 
              new BinaryExpression("->at", arg.expression, 
                                   incr); 
          } 

          return args + "->at(" + callp1 + "+1)->oclAsType(String)"; 
        } // for JsonArray
        else if ("getValuesAs".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"Sequence"); 
          expression = arg.expression; 

          return args; 
        } // for JsonArray
        else if ("isNull".equals(called) && 
                 arg.isSequence())
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression incr = 
              new BinaryExpression("+", 
                     callarg1.expression, unitExpression); 
            Expression elem = 
              new BinaryExpression("->at", arg.expression, 
                                   incr);
            expression = 
              new UnaryExpression("->oclIsUndefined", elem);  
          } 

          return args + "->at(" + callp1 + "+1)->oclIsUndefined()"; 
        } // for JsonArray
        else if (arg.isOclIterator())
        { return oclIteratorKM3(arg, call, args, 
                                called, cargs, 
                                calls); 
        } 
        else if ("query".equals(called) && 
                 arg.isOclDatasource()) 
        { ASTTerm.setType(this,"OclIterator"); 

          if (cargs.size() == 1) 
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            String cpar1 = carg1.toKM3();

            if (arg.expression != null && 
                carg1.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                  "query_String", arg.expression, 
                  carg1.expression); 
            }  
            return args + ".query_String(" + cpar1 + ")"; 
          } 

          if (cargs.size() == 2) 
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            String cpar1 = carg1.toKM3();
            ASTTerm carg2 = (ASTTerm) cargs.get(1); 
            String cpar2 = carg2.toKM3();

            if (arg.expression != null && 
                carg1.expression != null && 
                carg2.expression != null) 
            { Vector newpars = new Vector(); 
              newpars.add(carg1.expression); 
              newpars.add(carg2.expression); 

              expression = 
                BasicExpression.newCallBasicExpression(
                  "query_String_Sequence", arg.expression, 
                  newpars); 
            }  
            return args + ".query_String_Sequence(" + cpar1 + "," + cpar2 + ")"; 
          } 
        } 
        else if ("remove".equals(called) && 
                 (arg.isCollection() || arg.isMap())
                )
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          String tt = ASTTerm.getType(args); 
          String pt = ASTTerm.getType(callarg); 
          // System.out.println(">>> Type of " + args + " is: " + tt);  
          // System.out.println(">>> Type of " + callp + " is: " + pt);  
          if (cargs.size() == 0) // it.remove() for iterator
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                                "remove",arg.expression); 
              statement = 
                InvocationStatement.newInvocationStatement(
                          expression, new Vector()); 
            }  
            return args + ".remove()"; 
          }
 
          if (arg.isMap() && cargs.size() > 0)
          { return args + " := " + args + "->antirestrict(Set{" + callp + "})"; } 
          else if (arg.isSet() && cargs.size() > 0)
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            if (arg.expression != null && 
                carg1.expression != null) 
            { expression = 
                new BinaryExpression("->excluding", 
                      arg.expression,carg1.expression); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }  
           
            return args + " := " + args + "->excluding(" + callp + ")"; 
          }
          else if (arg.isSortedSequence() && cargs.size() > 1) 
          { // bag.remove(elem,n) is 
            // bag := bag - Integer.subrange(1,n)->collect(elem)

            ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            ASTTerm carg2 = (ASTTerm) cargs.get(1); 
            
            if (arg.expression != null && 
                carg1.expression != null && 
                carg2.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(unitExpression); 
              pars.add(carg2.expression); 
              BasicExpression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars); 
              expression = 
                new BinaryExpression("-", 
                      arg.expression,
                        new BinaryExpression("->collect", 
                          subr, carg1.expression)); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }  

            return args + " := " + args + 
              " - Integer.subrange(1, " + carg2.expression + ")->collect(" + carg1.expression + ")"; 
          }   
          else if (arg.isSequence() && ASTTerm.isInteger(pt) && cargs.size() > 0) 
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            if (arg.expression != null && 
                carg1.expression != null) 
            { expression = 
                new BinaryExpression("->excludingAt", 
                      arg.expression,
                        new BinaryExpression("+", 
                          carg1.expression, 
                          unitExpression)); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }  

            return args + " := " + args + "->excludingAt(" + callp + "+1)"; 
          }   
          else if (arg.isSequence() && cargs.size() > 0)
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            if (arg.expression != null && 
                carg1.expression != null) 
            { expression = 
                new BinaryExpression("->excludingFirst", 
                      arg.expression,carg1.expression); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }
            return args + " := " + args + "->excludingFirst(" + callp + ")"; 
          }   
          else 
          { return args + ".remove(" + callp + ")"; } 
        }
        else if ("removeFirstOccurrence".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          String tt = ASTTerm.getType(args); 
          String pt = ASTTerm.getType(callarg); 
          System.out.println(">>> Type of " + args + " is: " + tt);  
          System.out.println(">>> Type of " + callp + " is: " + pt);  

          if (arg.isSequence() && cargs.size() > 0)
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            if (arg.expression != null && 
                carg1.expression != null) 
            { expression = 
                new BinaryExpression("->excludingFirst", 
                      arg.expression,carg1.expression); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }
            return args + " := " + args + "->excludingFirst(" + callp + ")"; 
          }   
          else 
          { return args + ".remove(" + callp + ")"; } 
        }
        else if ("removeLastOccurrence".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          String tt = ASTTerm.getType(args); 
          String pt = ASTTerm.getType(callarg); 
          System.out.println(">>> Type of " + args + " is: " + tt);  
          System.out.println(">>> Type of " + callp + " is: " + pt);  

          if (arg.isSequence() && cargs.size() > 0)
          { ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            if (arg.expression != null && 
                carg1.expression != null) 
            { Expression expr1 = 
                new UnaryExpression("->reverse", 
                                    arg.expression); 
              Expression expr2 = 
                new BinaryExpression("->excludingFirst", 
                      expr1,carg1.expression); 
              expression = 
                new UnaryExpression("->reverse", 
                                    expr2); 
              statement = 
                new AssignStatement(arg.expression, expression); 
            }
            return args + " := " + args + "->reverse()->excludingFirst(" + callp + ")->reverse()"; 
          }   
          else 
          { return args + ".remove(" + callp + ")"; } 
        }
        else if (arg.isCollection() && 
                 ("pop".equals(called) || 
                  "take".equals(called) || 
                  "pollLast".equals(called) ||
                  "removeLast".equals(called)))
        { // _1 = _2.pop(); is 
          // _1 := _2->last() ; _2 := _2->front()

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->front", arg.expression); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->front()";   
        }
        else if (arg.isSortedSequence() && 
                 "poll".equals(called))
        { // _1 = _2.poll(); is 
          // _1 := _2->min() ; 
          // _2 := _2->excludingFirst(_2->min())

          if (arg.expression != null) 
          { Expression minelem = 
              new UnaryExpression("->min", arg.expression); 
            expression = new BinaryExpression(
              "->excludingFirst", arg.expression, minelem); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->excludingFirst(" + args + "->min())";   
        }
        else if ("poll".equals(called) ||    
            "pollFirst".equals(called) ||
            "removeFirst".equals(called))
        { // _1 = _2.poll(); is 
          // _1 := _2->first() ; _2 := _2->tail()

          String elemT = ASTTerm.getElementType(arg); 
          ASTTerm.setType(this, elemT); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->first", arg.expression);             
            Expression tailexpr = 
              new UnaryExpression("->tail", arg.expression);             
            statement = 
              new AssignStatement(arg.expression, 
                                  tailexpr); 
          } 

          return args + " := " + args + "->tail()";   
        }
        else if ("push".equals(called) && arg.isSequence())
        { // For a stack, add to the end (should be front)

          ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->append", arg.expression, callarg.expression); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->append(" + callp + ")";   
        }
        else if (("addFirst".equals(called) || 
                  "offerFirst".equals(called)) && 
                 arg.isSequence())
        { // prepend to front for a deque
          ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->prepend", arg.expression, callarg.expression); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->prepend(" + callp + ")";   
        }
        else if (("offer".equals(called) || 
                  "addLast".equals(called) ||
                  "offerLast".equals(called))
                 && arg.isSequence())
        { // Add to end. 

          ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->including", arg.expression, callarg.expression); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->including(" + callp + ")";   
        }
        else if ("contains".equals(called) && 
                 (arg.isCollection() || arg.isMap()))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          String tt = ASTTerm.getType(args); 
          String pt = ASTTerm.getType(callarg); 
          System.out.println(">>> Type of " + args + " is: " + tt);  
          System.out.println(">>> Type of " + callp + " is: " + pt);  
          ASTTerm.setType(thisliteral,"boolean"); 

          if ("Map".equals(tt))
          { if (arg.expression != null && 
                callarg.expression != null)
            { Expression kys = 
                new UnaryExpression("->values",
                               arg.expression);
              expression = 
                new BinaryExpression("->includes", kys, 
                                   callarg.expression); 
            } 
            return args + "->values()->includes(" + callp + ")"; 
          } 
          else 
          { if (arg.expression != null && 
                callarg.expression != null) 
            { expression = 
                new BinaryExpression("->includes", 
                      arg.expression, callarg.expression); 
            } 
            return args + "->includes(" + callp + ")"; 
          }   
        }
        else if ("contains".equals(called) && 
                 cargs.size() >= 1 && 
                 (arg.isString() ||
                  ((ASTTerm) cargs.get(0)).isString()
                 )
                )
        { ASTTerm.setType(thisliteral,"boolean"); 
          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          
          if (arg.expression != null && 
              callarg1.expression != null)
          { Expression kys = 
                new BinaryExpression("->indexOf",
                      arg.expression, callarg1.expression);
            expression = 
                new BinaryExpression(">", kys, 
                                     zeroExpression);
            expression.setBrackets(true);  
          }
 
          return "(" + args + "->indexOf(" + callp1 + ") > 0)";   
        }
        else if (arg.isCollection() && 
                 ("isEmpty".equals(called) || 
                  "empty".equals(called)))
        { ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->isEmpty", arg.expression); 
          } 

          return args + "->isEmpty()"; 
        }
        else if ("values".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"Sequence"); 

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->values", arg.expression); 
          } 

          return args + "->values()"; 
        } // actually a Bag
        else if ("values".equals(called) && 
                 ModelElement.lookupByName(
                     args,ASTTerm.enumtypes) != null)
        { ASTTerm.setType(thisliteral,"Sequence(" + args + ")"); 

          if (arg.expression != null) 
          { expression = 
              BasicExpression.newFunctionBasicExpression(
                               "allInstances", arg.expression); 
          } 

          return args + ".allInstances()"; 
        } 
        else if ("EnumSet".equals(argliteral))
        { return enumSetFeatureAccess(arg, call, args, calls, called, cargs); } 
        else if ("Stream".equals(argliteral) || 
                 "IntStream".equals(argliteral) || 
                 "LongStream".equals(argliteral) || 
                 "DoubleStream".equals(argliteral))
        { return streamFeatureAccess(arg, call, args, calls, called, cargs); } 
        else if ("Spliterators".equals(argliteral))
        { return spliteratorsFeatureAccess(arg, call, args, calls, called, cargs); } 
        else if ("keySet".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"Set");

          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("->keys", arg.expression); 
          } 
 
          return args + "->keys()"; 
        }
        else if ("keys".equals(called) && arg.isMap())
        { ASTTerm.setType(thisliteral,"OclIterator");

          if (arg.expression != null) 
          { Expression ks = 
              new UnaryExpression("->keys", arg.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclIterator_Set", "OclIterator", ks); 
          } 
 
          return "OclIterator.newOclIterator_Set(" + args + "->keys())"; 
        }
        else if ("elements".equals(called) || 
                 "iterator".equals(called))  // Maps: the values
        { ASTTerm.setType(thisliteral,"OclIterator"); 
          ASTTerm callarg = (ASTTerm) callterms.get(2);
          String constr = "Set";
 
          if (arg.isSequence())
          { constr = "Sequence"; } 

          if (arg.isOclIterator())
          { constr = "Sequence"; 
            if (arg.expression != null) 
            { Expression elems = 
                BasicExpression.newAttributeBasicExpression(
                            "elements", arg.expression); 
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_" + constr, "OclIterator", 
                  elems); 
            } 

            return "OclIterator.newOclIterator_" + constr + "(" + args + ".elements)"; 
          }
 
          if (cargs.size() == 0) 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_" + constr, "OclIterator", 
                  arg.expression); 
            } 

            return "OclIterator.newOclIterator_" + constr + "(" + args + ")"; 
          } 
          else 
          { String callp = callarg.toKM3(); 

            if (arg.expression != null && 
                callarg.expression != null) 
            { Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression,
                     new BinaryExpression("+", 
                       callarg.expression, unitExpression)); 
 
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_" + constr, "OclIterator", 
                  subr); 
            }

            return "OclIterator.newOclIterator_" + constr + "(" + args + ".subrange(" + callp + "+1, " + args + ".size))"; 
          } 
        }
        else if ("listIterator".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          
          ASTTerm.setType(thisliteral,"OclIterator"); 
          
          if (cargs.size() == 0) 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_Sequence", 
                  "OclIterator", arg.expression); 
            } 

            return "OclIterator.newOclIterator_Sequence(" + args + ")"; 
          } 
          else 
          { if (arg.expression != null && 
                callarg.expression != null) 
            { Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression,
                     new BinaryExpression("+", 
                       callarg.expression, unitExpression)); 
 
              expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_Sequence", "OclIterator", 
                  subr); 
            }

            return "OclIterator.newOclIterator_Sequence(" + args + ".subrange(" + callp + "+1, " + args + ".size))"; 
          } 
        }
        else if ("descendingIterator".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          
          ASTTerm.setType(thisliteral,"OclIterator"); 
          
          if (cargs.size() == 0) 
          { if (arg.expression != null) 
            { expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclIterator_Sequence", 
                  "OclIterator", 
                    new UnaryExpression("->reverse", 
                                        arg.expression)); 
            } 

            return "OclIterator.newOclIterator_Sequence(" + args + "->reverse())"; 
          } 
        }
        else if ("containsValue".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          // String tt = ASTTerm.getType(args); 
          // String pt = ASTTerm.getType(callarg); 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null && 
              callarg.expression != null)
          { Expression kys = 
              new UnaryExpression("->values", arg.expression);
            expression = 
              new BinaryExpression("->includes", kys, 
                                   callarg.expression); 
          } 

          return args + "->values()->includes(" + callp + ")";    
        }
        else if ("containsKey".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          // String tt = ASTTerm.getType(args); 
          // String pt = ASTTerm.getType(callarg); 
          ASTTerm.setType(thisliteral,"boolean");

          if (arg.expression != null && 
              callarg.expression != null)
          { Expression kys = 
              new UnaryExpression("->keys", arg.expression);
            expression = 
              new BinaryExpression("->includes", kys, 
                                   callarg.expression); 
          } 
                                     
          return args + "->keys()->includes(" + callp + ")";  
        }
        else if ("containsAll".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          // String tt = ASTTerm.getType(args); 
          // String pt = ASTTerm.getType(callarg); 
          ASTTerm.setType(thisliteral,"boolean"); 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->includesAll", 
                    arg.expression, 
                    callarg.expression); 
          }

          return args + "->includesAll(" + callp + ")"; 
        }
        else if ("firstKey".equals(called))
        { if (arg.expression != null) 
          { Expression ks = 
              new UnaryExpression("->keys", arg.expression); 
            expression = 
              new UnaryExpression("->min", ks); 
          } 
          return args + "->keys()->min()"; 
        }
        else if ("lastKey".equals(called))
        { if (arg.expression != null) 
          { Expression ks = 
              new UnaryExpression("->keys", arg.expression); 
            expression = 
              new UnaryExpression("->max", ks); 
          } 
          return args + "->keys()->max()";
        }
        else if ("setSize".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          if (arg.expression != null && 
              callarg.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(unitExpression); 
            pars.add(callarg.expression); 
            expression = 
              BasicExpression.newCallBasicExpression(
                  "subrange", callarg.expression, pars); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 
          return args + " := " + args + ".subrange(1," + callp + ");"; 
        }   
        else if ("removeElementAt".equals(called) || 
                 "deleteCharAt".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression newind = 
              new BinaryExpression("+", callarg.expression, unit); 
            expression = 
              new BinaryExpression("->excludingAt", 
                                   arg.expression, 
                                   newind); 
            statement =
              new AssignStatement(arg.expression, expression); 
          } 
          return args + " := " + args + "->excludingAt(" + callp + "+1)"; 
        }   
        else if ("removeElement".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();

          if (arg.expression != null && 
              callarg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            Expression newind = 
              new BinaryExpression("+", callarg.expression, unit); 
            expression = 
              new BinaryExpression("->excludingFirst", 
                                   arg.expression, 
                                   newind); 
            statement =
              new AssignStatement(arg.expression, expression); 
          } 
              
          return args + " := " + args + "->excludingFirst(" + callp + ")"; 
        } 
        else if ("append".equals(called) && arg.isString())
        { // ASTTerm callargs = (ASTTerm) callterms.get(2);

          ASTTerm upd = arg.updatedObject(); 
          String qf = upd.queryForm(); 

          System.out.println(">>> Side-effecting call of append on string " + qf); 

          String callp = callargs.toKM3(); 

          if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (callarg1.isStringSequence())
            { if (upd.expression != null && 
                  callarg1.expression != null) 
              { Expression sumexpr = 
                  new UnaryExpression("->sum", callarg1.expression); 
                expression = 
                  new BinaryExpression("+", arg.expression,
                                       sumexpr); 
                expression.setBrackets(true); 
                statement = 
                  new AssignStatement(upd.expression, expression); 
              }
 
              return qf + 
                " := (" + args + " + " + callp1 + "->sum())"; 
            }   

            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                  new BinaryExpression("+", arg.expression,
                                       callarg1.expression); 
              expression.setBrackets(true); 
              statement = 
                new AssignStatement(upd.expression, expression); 
            }

            return qf + " := (" + args + " + (\"\" + " + callp1 + "))"; 
          } 
          else if (cargs.size() >= 3) 
          { // subrange of first argument
            ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null) 
            { Vector pars = new Vector(); 
              pars.add(new BinaryExpression("+", 
                             callarg2.expression, 
                             unitExpression)); 
              pars.add(new BinaryExpression("+", 
                             callarg2.expression, 
                             callarg3.expression)); 

              Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", callarg1.expression, pars);
              Expression ue = 
                new UnaryExpression("->sum", subr); 
              expression = 
                new BinaryExpression("+", arg.expression, ue); 
              statement = 
                new AssignStatement(upd.expression, expression);  
            } 
 
            return qf + " := (" + args + " + " + callp1 + ".subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ")->sum())"; 
          }   

          return qf + " := (" + args + " + StringLib.newString(" + callp + "))";  
        }  
        else if ("insert".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (cargs.size() == 2)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 

            if (arg.expression != null &&  
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression,
                                     unitExpression); 
              pars.add(incr); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newFunctionBasicExpression(
                  "insertAt", 
                  arg.expression, pars);  
              statement = 
                new AssignStatement(arg.expression, expression); 
            } 

            return args + " := " + args + ".insertAt(" + callp1 + " +1, \"\" + " + callp2 + ")"; 
          } 
          else if (cargs.size() >= 4)
          { // subrange of 2nd argument
            ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 
            ASTTerm callarg4 = (ASTTerm) cargs.get(3);
            String callp4 = callarg4.toKM3(); 
            return args + " := " + args + ".insertAt(" + callp1 + "+1, " + callp2 + ".subrange(" + callp3 + "+1, " + callp3 + "+" + callp4 + ")->sum())"; 
          }     

          return args + " := " + args + ".insertAt(" + callp1 + " +1, " + callp1 + ")";  
        }
        else if ("replace".equals(called) && arg.isString() && cargs.size() == 3)
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          ASTTerm callarg3 = (ASTTerm) cargs.get(2);
          String callp3 = callarg3.toKM3(); 
          
          return args + " := (" + args + ".subrange(1," + callp1 + ") + " + args + ".subrange(" + callp2 + " + 1)).insertAt(" + callp1 + " +1, " + callp3 + ")";  
        }
        else if ("retainAll".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->intersection", 
                                   arg.expression, 
                                   callarg.expression); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->intersection(" + callp + ")"; 
        }
        else if ("removeIf".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType);

              ((UnaryExpression) callarg.expression).setElementType("boolean"); 
            } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|R", rlhs, rrhs); 
            statement = 
              new AssignStatement(arg.expression, expression); 
          } 

          return args + " := " + args + "->reject(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("filter".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType);

              ((UnaryExpression) callarg.expression).setElementType("boolean"); 
            } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|", rlhs, rrhs); 
          } 

          return args + "->select(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("mapToInt".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, "Sequence(int)"); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType);

              ((UnaryExpression) callarg.expression).setElementType("int"); 
            } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|C", rlhs, rrhs); 
          } 

          return args + "->collect(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("mapToLong".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, "Sequence(long)"); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType);

              ((UnaryExpression) callarg.expression).setElementType("long"); 
            } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|C", rlhs, rrhs); 
          } 

          return args + "->collect(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("mapToDouble".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, "Sequence(double)"); 
          String elemType = ASTTerm.getElementType(arg);
 
          // JOptionPane.showMessageDialog(null, this + 
          //      " " + arg.expression + " " + callp + " " + 
          //      callarg.expression, 
          //      " ", JOptionPane.ERROR_MESSAGE);

          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType);

              ((UnaryExpression) callarg.expression).setElementType("double"); 
            } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|C", rlhs, rrhs); 
          } 
          else if (arg.expression != null) 
          { BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              new BinaryExpression("->apply", 
                new BasicExpression(callp), varexpr);   
            expression = 
              new BinaryExpression("|C", rlhs, rrhs); 
          } 

          return args + "->collect(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("map".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
           
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType); } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("|C", rlhs, rrhs); 
          } 

          return args + "->collect(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("reduce".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
           
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
          Type elemT = 
            Type.getTypeFor(elemType,
                   ASTTerm.enumtypes,ASTTerm.entities); 
          if (elemT == null) 
          { elemT = new Type("OclAny", null); } 
          Expression defaultV = 
              elemT.getDefaultValueExpression(null);

          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
 
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setElementType(elemType); } 

            BasicExpression accexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_acc");
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            Expression rrhs1 = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            Expression rrhs = 
              Expression.simplifyApply( 
                          rrhs1, accexpr);   
            BinaryExpression iter = 
              new BinaryExpression("->iterate",
                                   arg.expression, rrhs);
            iter.iteratorVariable = "_var"; 
            iter.accumulator = 
              new Attribute("_acc", elemT, 
                            ModelElement.INTERNAL);
            expression = iter;   
          } 

          return args + "->iterate(_var; _acc = " + defaultV + " | (" + callp + ")->apply(_var)->apply(_acc) )"; 
        }
        else if ("forEach".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          Statement callStat = callarg.statement; 

          Vector lamPars = 
            ((ASTCompositeTerm) callarg).lambdaExpressionPars(); 
          String varName = "_fvar"; 
          if (lamPars != null && 
              lamPars.size() > 0)
          { varName = lamPars.get(0) + ""; } 

          Expression loopVar = 
            BasicExpression.newVariableBasicExpression(
                                                varName); 
          if (arg.expression != null &&
              callarg.expression != null)
          { BinaryExpression forTest = 
              new BinaryExpression(":", loopVar, arg.expression); 
            forTest.setType(
                            new Type("boolean", null));
            Expression lambdaApp = 
              Expression.simplifyApply( 
                          callarg.expression, loopVar);   
            Statement lBody = 
              new ImplicitInvocationStatement(lambdaApp); 
            if (callStat != null) 
            { lBody = callStat; }  
            WhileStatement ws = 
              new WhileStatement(forTest, lBody);
            ws.setLoopKind(Statement.FOR);  
            ws.setIterationRange(arg.expression);
            statement = ws; 
          } 
          return statement + "";   
        } 
        else if ("allMatch".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType); } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("!", rlhs, rrhs); 
          } 

          return args + "->forAll(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("anyMatch".equals(called) && arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType); } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);   
            expression = 
              new BinaryExpression("#", rlhs, rrhs); 
          } 

          return args + "->exists(_var | (" + callp + ")->apply(_var))"; 
        }
        else if ("noneMatch".equals(called) && 
                 arg.isCollection())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(this, ASTTerm.getType(arg)); 
          String elemType = ASTTerm.getElementType(arg);
 
          if (arg.expression != null && 
              callarg.expression != null) 
          { callarg.expression.setBrackets(true);
            if (callarg.expression instanceof UnaryExpression)
            { ((UnaryExpression) callarg.expression).setKeyType(elemType); } 
 
            BasicExpression varexpr = 
              BasicExpression.newVariableBasicExpression( 
                                   "_var");
            BinaryExpression rlhs = 
              new BinaryExpression(":", varexpr, 
                                   arg.expression);
            Expression rrhs = 
              Expression.simplifyApply( 
                          callarg.expression, varexpr);
            UnaryExpression nrrhs = 
              new UnaryExpression("not", rrhs);    
            expression = 
              new BinaryExpression("!", rlhs, nrrhs); 
          } 

          return args + "->exists(_var | not((" + callp + ")->apply(_var)))"; 
        }
        else if (("apply".equals(called) || 
                  "test".equals(called)) && arg.isFunction())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
        
          if (arg.expression != null && 
              callarg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new BinaryExpression("->apply", 
                          arg.expression, callarg.expression);   
          } 

          return "(" + args + ")->apply(" + callp + ")"; 
        }
        else if ("sum".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->sum", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,etype); } 

          return "(" + args + ")->sum()"; 
        }
        else if ("max".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->max", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,etype); } 

          return "(" + args + ")->max()"; 
        }
        else if ("min".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->min", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,etype); } 

          return "(" + args + ")->min()"; 
        }
        else if ("findAny".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->any", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,etype); } 

          return "(" + args + ")->any()"; 
        }
        else if ("findFirst".equals(called) && 
                 arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->first", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,etype); } 

          return "(" + args + ")->first()"; 
        }
        else if ("distinct".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->asOrderedSet", 
                                  arg.expression);   
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,"Sequence(" + etype + ")"); }
          else 
          { ASTTerm.setType(this,"Sequence"); }  

          return "(" + args + ")->asOrderedSet()"; 
        }
        else if ("sorted".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->sort", 
                                  arg.expression);
            expression.setSorted(true);    
          } 

          String etype = ASTTerm.getElementType(arg); 
          if (etype != null) 
          { ASTTerm.setType(this,"Sequence(" + etype + ")"); }
          else 
          { ASTTerm.setType(this,"Sequence"); }  

          return "(" + args + ")->sort()"; 
        }
        else if ("count".equals(called) && arg.isCollection())
        { if (arg.expression != null) 
          { arg.expression.setBrackets(true);
            expression = 
              new UnaryExpression("->size", 
                                  arg.expression);   
          } 

          ASTTerm.setType(this,"long");  

          return "(" + args + ")->size()"; 
        }
        else if ("limit".equals(called) && arg.isCollection())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(unitExpression); 
            pars.add(callarg1.expression); 
            expression = 
              BasicExpression.newCallBasicExpression(
                  "subrange",arg.expression,pars);   
          } 

          ASTTerm.setType(this,ASTTerm.getType(arg));  

          return args + ".subrange(1," + callp1 + ")"; 
        }
        else if ("skip".equals(called) && arg.isCollection())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 
          
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Expression plus1 = 
              new BinaryExpression("+", callarg1.expression,
                                   unitExpression); 
            expression = 
              BasicExpression.newCallBasicExpression(
                  "subrange",arg.expression,plus1);   
          } 

          ASTTerm.setType(this,ASTTerm.getType(arg));  

          return args + ".subrange(" + callp1 + "+1)"; 
        }
        else if ("unordered".equals(called) || 
                 "parallel".equals(called) || 
                 "sequential".equals(called))
        { ASTTerm.setType(this, "Sequence"); 
          expression = arg.expression;
          return "" + expression; 
        } 
        else if ("incrementAndGet".equals(called))
        { ASTTerm.setType(this, ASTTerm.getType(arg)); 
          expression = 
            new BinaryExpression("+", arg.expression, 
                                 new BasicExpression(1));
          statement = 
            new AssignStatement(arg.expression, expression); 
          return "" + expression; 
        } 
        else if ("decrementAndGet".equals(called))
        { ASTTerm.setType(this, ASTTerm.getType(arg)); 
          expression = 
            new BinaryExpression("-", arg.expression, 
                                 new BasicExpression(1));
          statement = 
            new AssignStatement(arg.expression, expression); 
          return "" + expression; 
        } 
        else if ("stream".equals(called))
        { ASTTerm.setType(this, "Sequence"); 

          // JOptionPane.showMessageDialog(null, this + 
          //      " " + args + " " + argliteral + " " + 
          //      arg.expression, 
          //      " ", JOptionPane.ERROR_MESSAGE);

          if ("Arrays".equals(argliteral) && cargs.size() > 0)
          { // Arrays.stream(arr)
            ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            String callp1 = carg1.toKM3(); 
            expression = carg1.expression;
            return callp1; 
          } 
          else if ("StreamSupport".equals(argliteral) && cargs.size() > 0)
          { // StreamSupport.stream(arr)
            ASTTerm carg1 = (ASTTerm) cargs.get(0); 
            String callp1 = carg1.toKM3();
            if ("OclIterator".equals(ASTTerm.getType(carg1)))
            { expression = 
                BasicExpression.newBasicExpression( 
                                        carg1.expression, 
                                        "elements");
              return "(" + callp1 + ").elements";  
            }  
            expression = carg1.expression;
            return callp1; 
          } 
          else if (arg.expression != null) 
          { expression = arg.expression; } 
          else 
          { expression = new BasicExpression(args); } 

          return args; 
        }
        else if ("setCharAt".equals(called) && arg.isString())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3(); 

          if (cargs.size() == 2)
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
          
            if (arg.expression != null &&  
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Vector pars = new Vector(); 
              Expression incr = 
                new BinaryExpression("+", callarg1.expression,
                                     unitExpression); 
              pars.add(incr); 
              pars.add(callarg2.expression); 
              expression = 
                BasicExpression.newFunctionBasicExpression(
                  "setAt", 
                  arg.expression, pars);  
              statement = 
                new AssignStatement(arg.expression, expression); 
            } 
          

            return args + " := " + args + ".setAt(" + callp1 + " +1, (\"\" + " + callp2 + "))"; 
          } 
        }     
        else if ("println".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();

          Statement sideEffect = callarg.statement; 

          if (cargs.size() == 0)
          { if (arg.expression != null) 
            { Vector pars = new Vector(); 
              Expression par = 
                BasicExpression.newValueBasicExpression("\"\""); 
              pars.add(par); 
              expression = 
                BasicExpression.newCallBasicExpression(
                           "println", arg.expression, pars); 
              Statement stat = 
                InvocationStatement.newInvocationStatement(
                                   expression, pars);
              if (sideEffect == null) 
              { statement = stat; } 
              else 
              { statement = 
                  new SequenceStatement(stat,sideEffect); 
              }  
            } 
            return args + ".println(\"\")"; 
          }
 
          ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 
 
          if (callargument1.isStringSequence())
          { if (arg.expression != null && 
                callargument1.expression != null) 
            { Expression sumexpr = 
                new UnaryExpression("->sum",
                         callargument1.expression); 
              Vector pars = new Vector(); 
              pars.add(sumexpr); 
              expression = 
                 BasicExpression.newCallBasicExpression(
                          "println", arg.expression, pars);
              Statement stat = 
                InvocationStatement.newInvocationStatement(
                                   expression, pars);
              if (sideEffect == null) 
              { statement = stat; } 
              else 
              { statement = 
                  new SequenceStatement(sideEffect,stat); 
              }
            } 

            return args + ".println(" + callp1 + "->sum())"; 
          }
 
          if (callargument1.isIntegerSequence() && cargs.size() == 3) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3();


            Vector spars = new Vector(); 
            spars.add(new BinaryExpression("+", 
                           callarg2.expression, 
                           unitExpression)); 
            spars.add(new BinaryExpression("+", 
                           callarg2.expression, 
                           callarg3.expression)); 

            Expression subr = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callargument1.expression, spars); 

            String xvar = Identifier.nextIdentifier("_x"); 
            BasicExpression xx = 
              BasicExpression.newVariableBasicExpression(
                                                    xvar); 
 
            Expression colrng = 
               new UnaryExpression("->byte2char", xx); 
            Expression coldom = 
               new BinaryExpression(":", xx, subr);

            Expression colexpr = 
              new BinaryExpression("|C", coldom, colrng); 
            Expression printarg = 
              new UnaryExpression("->sum", colexpr); 

            Vector pars = new Vector(); 
            pars.add(printarg); 

            expression = 
                 BasicExpression.newCallBasicExpression(
                     "println", arg.expression, pars);
            statement = 
                InvocationStatement.newInvocationStatement(
                      expression, pars); 
             
            return args + ".println(" + callp1 + ".subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ")->collect( _x | _x->byte2char() )->sum())"; 
          } 

          if (arg.expression != null && 
              callargument1.expression != null) 
          { Expression emptyStr = 
                BasicExpression.newValueBasicExpression("\"\""); 
            Expression sumexpr = 
                new BinaryExpression("+", callargument1.expression, emptyStr); 
            Vector pars = new Vector(); 
            pars.add(sumexpr); 
            expression = 
                 BasicExpression.newCallBasicExpression(
                     "println", arg.expression, pars);
            Statement stat = 
                InvocationStatement.newInvocationStatement(
                                   expression, pars);
            if (sideEffect == null) 
            { statement = stat; } 
            else 
            { statement = 
                  new SequenceStatement(stat,sideEffect); 
            } 
          } 
             
          return args + ".println(\"\"+" + callp + ")"; 
        }
        else if ("print".equals(called))
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3();
          ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 
 
          if (callargument1.isStringSequence())
          { if (arg.expression != null && 
                callargument1.expression != null) 
            { Expression sumexpr = 
                new UnaryExpression("->sum", callargument1.expression); 
              Vector pars = new Vector(); 
              pars.add(sumexpr); 
              expression = 
                 BasicExpression.newCallBasicExpression("print", arg.expression, pars);
              statement = 
                InvocationStatement.newInvocationStatement(expression, pars); 
            } 
            return args + ".print(" + callp1 + "->sum())"; 
          }
 
          if (callargument1.isIntegerSequence() && 
              cargs.size() == 3) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 


            Vector spars = new Vector(); 
            spars.add(new BinaryExpression("+", 
                           callarg2.expression, 
                           unitExpression)); 
            spars.add(new BinaryExpression("+", 
                           callarg2.expression, 
                           callarg3.expression)); 

            Expression subr = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", callargument1.expression, spars); 

            String xvar = Identifier.nextIdentifier("_x"); 
            BasicExpression xx = 
              BasicExpression.newVariableBasicExpression(
                                                    xvar); 
 
            Expression colrng = 
               new UnaryExpression("->byte2char", xx); 
            Expression coldom = 
               new BinaryExpression(":", xx, subr);

            Expression colexpr = 
              new BinaryExpression("|C", coldom, colrng); 
            Expression printarg = 
              new UnaryExpression("->sum", colexpr); 

            Vector pars = new Vector(); 
            pars.add(printarg); 

            expression = 
                 BasicExpression.newCallBasicExpression(
                     "print", arg.expression, pars);
            statement = 
                InvocationStatement.newInvocationStatement(
                      expression, pars); 

            return args + ".print(" + callp1 + ".subrange(" + callp2 + "+1, " + callp2 + "+" + callp3 + ")->collect( _x | _x->byte2char() )->sum())"; 
          } 
             
          if (arg.expression != null && 
              callargument1.expression != null) 
          { Expression emptyStr = 
                BasicExpression.newValueBasicExpression("\"\""); 
            Expression sumexpr = 
                new BinaryExpression("+", callargument1.expression, emptyStr); 
            Vector pars = new Vector(); 
            pars.add(sumexpr); 
            expression = 
                 BasicExpression.newCallBasicExpression("print", arg.expression, pars);
            statement = 
                InvocationStatement.newInvocationStatement(expression, pars); 
          } 

          return args + ".print(\"\"+" + callp + ")"; 
        }
        else if (("printf".equals(called) || 
                  "format".equals(called)) && 
                 arg.isOclFile())
        { ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 

          SetExpression printItems = new SetExpression(true); 
          String itemseq = "Sequence{"; 
          for (int q = 1; q < cargs.size(); q++) 
          { ASTTerm cargq = (ASTTerm) cargs.get(q); 
            itemseq = itemseq + cargq.toKM3(); 
            if (q < cargs.size()-1) 
            { itemseq = itemseq + ", "; } 
            if (cargq.expression != null) 
            { printItems.addElement(cargq.expression); } 
          } 
          itemseq = itemseq + "}"; 

          if (arg.expression != null && 
              callargument1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(callargument1.expression); 
            pars.add(printItems); 
            expression = 
              BasicExpression.newCallBasicExpression("printf",
                                arg.expression, pars); 
            statement = 
              InvocationStatement.newInvocationStatement(
                                expression, pars); 
          } 
 
          return args + ".printf(" + callp1 + ", " + itemseq + ")"; 
        }  
        else if ("format".equals(called) && 
                 "String".equals(args))
        { ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 

          SetExpression printItems = new SetExpression(true); 
          String itemseq = "Sequence{"; 
          for (int q = 1; q < cargs.size(); q++) 
          { ASTTerm cargq = (ASTTerm) cargs.get(q); 
            itemseq = itemseq + cargq.toKM3(); 
            if (q < cargs.size()-1) 
            { itemseq = itemseq + ", "; } 
            if (cargq.expression != null) 
            { printItems.addElement(cargq.expression); } 
          } 
          itemseq = itemseq + "}"; 

          if (callargument1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(callargument1.expression); 
            pars.add(printItems); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                 "format", "StringLib", 
                 pars); 
            statement = 
              InvocationStatement.newInvocationStatement(
                                expression, pars); 
          } 
 
          return "StringLib.format(" + callp1 + ", " + itemseq + ")"; 
        }  
        else if ("getByName".equals(called) && 
                 "InetAddress".equals(args))
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm callargument1 = (ASTTerm) cargs.get(0);
          String callp1 = callargument1.toKM3(); 

          if (callargument1.expression != null) 
          { expression = callargument1.expression; } 
 
          return callp1; 
        }  
        else if ("createTempFile".equals(called) && 
                 "File".equals(args))
        { ASTTerm fname = (ASTTerm) cargs.get(0);
          ASTTerm fext = (ASTTerm) cargs.get(1);
          String filename = fname.toKM3(); 
          String fileext = fext.toKM3(); 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (fname.expression != null && 
              fext.expression != null) 
          { Vector pars = new Vector(); 
            
            pars.add(fname); 
            pars.add(fext); 
            expression =
              BasicExpression.newStaticCallBasicExpression(
                  "createTemporaryFile", "OclFile", pars);
          }  

          return "OclFile.createTemporaryFile(" + filename + "," +
                                         fileext + ")"; 
        }
        else if ("copyInto".equals(called) && 
                 arg.isSequence())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          if (arg.expression != null && 
              callarg.expression != null) 
          { expression = 
              new BinaryExpression("->union", 
                   new SetExpression(true), 
                   callarg.expression); 
            statement = 
              new AssignStatement(arg.expression, 
                                  expression); 
          } 

          return args + " := Sequence{}->union(" + callp + ")"; 
        }
        else if ("startsWith".equals(called) && 
                 arg.isString())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          
          ASTTerm.setType(thisliteral,"boolean"); 
          
          if (cargs.size() == 1) 
          { String callp = callarg.toKM3(); 

            if (arg.expression != null && 
                callarg.expression != null) 
            { expression = 
                new BinaryExpression("->hasPrefix", 
                                     arg.expression, 
                                     callarg.expression); 
            } 

            return args + "->hasPrefix(" + callp + ")"; 
          } 
          else if (cargs.size() == 2) 
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3();

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null) 
            { Expression subr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", arg.expression, 
                     new BinaryExpression("+", 
                           callarg2.expression, 
                           unitExpression)); 
              expression = 
                new BinaryExpression("->hasPrefix", 
                                     subr, 
                                     callarg1.expression); 
            } 

            return args + ".subrange(" + callp2 + "+1, " + args + ".size)->hasPrefix(" + callp1 + ")"; 
          } 
        }
        else if ("length".equals(called) && arg.isBitSet())
        { ASTTerm.setType(thisliteral,"int"); 

          if (arg.expression != null) 
          { expression = new BinaryExpression("->lastIndexOf", 
                                 arg.expression,
                                 new BasicExpression(true)); 
          } 

          return args + "->lastIndexOf(true)";  
        } 
        else if ("length".equals(called) || 
                 "size".equals(called) || 
                 "capacity".equals(called) ||
                 "elementCount".equals(called))
        { if (arg.isString() || arg.isCollection() || arg.isMap())
          { ASTTerm.setType(thisliteral,"int");

            if (arg.expression != null) 
            { expression = new UnaryExpression("->size", 
                                   arg.expression); 
            } 
 
            return args + "->size()";
          } 

          if (arg.expression != null) 
          { expression = 
              BasicExpression.newCallBasicExpression(
                 called, arg.expression); 
          } 

          return args + "." + called + "()";  
        }
        else if ("first".equals(called) && arg.isSet())
        { ASTTerm.setType(thisliteral,
                          ASTTerm.getElementType(arg));

          if (arg.expression != null) 
          { expression = new UnaryExpression("->min", 
                                 arg.expression); 
          } 
 
          return args + "->min()"; 
        }
        else if ("last".equals(called) && arg.isSet())
        { ASTTerm.setType(thisliteral,
                     ASTTerm.getElementType(arg)); 

          if (arg.expression != null) 
          { expression = new UnaryExpression("->max", 
                                 arg.expression); 
          } 

          return args + "->max()"; 
        }
        else if (("getFirst".equals(called) || 
                  "first".equals(called) || 
                  "firstElement".equals(called)) && 
                  (arg.isCollection() || arg.isString())
                 )
        { // ASTTerm callarg = (ASTTerm) callterms.get(2); 
          // String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,
                          ASTTerm.getElementType(arg));
 
          if (arg.expression != null) 
          { expression = new UnaryExpression("->first", 
                                 arg.expression); 
          } 

          return args + "->first()"; 
        }
        else if (("getLast".equals(called) || 
                  "last".equals(called) || 
                  "lastElement".equals(called)) && 
                  (arg.isCollection() || arg.isString())
                 ) 
        { // ASTTerm callarg = (ASTTerm) callterms.get(2); 
          // String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral, 
                          ASTTerm.getElementType(arg));

          if (arg.expression != null) 
          { expression = new UnaryExpression("->last", 
                                 arg.expression); 
          } 
 
          return args + "->last()"; 
        }
        else if ("peek".equals(called) && 
                 (arg.isCollection() || arg.isMap()))
        { // for sorted collections/maps

          ASTTerm.setType(thisliteral, 
                          ASTTerm.getElementType(arg));

          if (arg.expression != null) 
          { expression = new UnaryExpression("->min", 
                                 arg.expression); 
          } 
 
          return args + "->min()"; 
        }
        else if ("peekFirst".equals(called) && 
                 arg.isCollection())
        { // for deques

          ASTTerm.setType(thisliteral, 
                          ASTTerm.getElementType(arg));

          if (arg.expression != null) 
          { expression = new UnaryExpression("->first", 
                                 arg.expression); 
          } 
 
          return args + "->first()"; 
        }
        else if ("peekLast".equals(called) && 
                 arg.isCollection())
        { // for deques

          ASTTerm.setType(thisliteral, 
                          ASTTerm.getElementType(arg));

          if (arg.expression != null) 
          { expression = new UnaryExpression("->last", 
                                 arg.expression); 
          } 
 
          return args + "->last()"; 
        }
        else if ("toString".equals(called))
        { // ASTTerm callarg = (ASTTerm) callterms.get(2); 
          // String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"String"); 

          if (arg.expression != null) 
          { Expression emptyString = 
              BasicExpression.newValueBasicExpression(
                 "\"\""); 
            expression = new BinaryExpression("+", 
                                 arg.expression,
                                 emptyString); 
            expression.setBrackets(true); 
          } 

          return "(" + args + " + \"\")"; 
        }
        else if ("currentTimeMillis".equals(called) && 
                 "System".equals(args))
        { ASTTerm.setType(thisliteral,"long"); 

          Expression dateExpr = 
            new BasicExpression(new Type("OclDate", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "getSystemTime", dateExpr); 
          
          return "OclDate.getSystemTime()"; 
        } 
        else if (("getProperty".equals(called) || 
                  "getenv".equals(called)) && 
                 "System".equals(args))
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 
       
          Expression procExpr = 
            new BasicExpression(new Type("OclProcess", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "getEnvironmentProperty", procExpr, arg1.expression); 
          
          return "OclProcess.getEnvironmentProperty(" + callp1 + ")"; 
        } 
        else if ("getProperties".equals(called) && 
                 "System".equals(args))
        { ASTTerm.setType(thisliteral,"Map(String,String)"); 
          
          Expression procExpr = 
            new BasicExpression(new Type("OclProcess", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "getEnvironmentProperties", procExpr); 
          
          return "OclProcess.getEnvironmentProperties()"; 
        } 
        else if ("setProperty".equals(called) && 
                 "System".equals(args))
        { ASTTerm.setType(thisliteral,"String"); 
          ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 
          ASTTerm arg2 = (ASTTerm) cargs.get(1);
          String callp2 = arg2.toKM3(); 
       
          Vector setpars = new Vector(); 
          setpars.add(arg1.expression); 
          setpars.add(arg2.expression); 

          Expression procExpr = 
            new BasicExpression(new Type("OclProcess", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "setEnvironmentProperty", procExpr, setpars); 

          statement =               
            InvocationStatement.newInvocationStatement(
                expression, setpars); 
          
          return "OclProcess.setEnvironmentProperty(" + callp1 + "," + callp2 + ")"; 
        } 
        else if ("clearProperty".equals(called) && 
                 "System".equals(args))
        { ASTTerm.setType(thisliteral,"String"); 

          ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 
          
          Expression procExpr = 
            new BasicExpression(new Type("OclProcess", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "clearEnvironmentProperty", 
                procExpr, arg1.expression); 
          
          statement =               
            InvocationStatement.newInvocationStatement(
                expression, arg1.expression); 

          return "OclProcess.clearEnvironmentProperty(" + callp1 + ")"; 
        } 
        else if ("exit".equals(called) && 
                 "System".equals(args))
        { // ASTTerm.setType(thisliteral,"String"); 
          ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 
       
          Expression procExpr = 
            new BasicExpression(new Type("OclProcess", null)); 
          
          expression = 
              BasicExpression.newStaticCallBasicExpression(
                "exit", procExpr, arg1.expression); 
          statement =               
            InvocationStatement.newInvocationStatement(
                expression, arg1.expression); 


          return "OclProcess.exit(" + callp1 + ")"; 
        } // Also arraycopy
        else if ("arraycopy".equals(called) && 
                 "System".equals(args) && 
                 cargs.size() == 5)
        { // System.arraycopy(u, i, v, j, k) is 
          // for _x : Integer.subrange(1,k) do 
          //   v[j +_x] := u[i + _x] 
 
          ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 

          ASTTerm arg2 = (ASTTerm) cargs.get(1);
          String callp2 = arg2.toKM3(); 

          ASTTerm arg3 = (ASTTerm) cargs.get(2);
          String callp3 = arg3.toKM3(); 
       
          ASTTerm arg4 = (ASTTerm) cargs.get(3);
          String callp4 = arg4.toKM3(); 

          ASTTerm arg5 = (ASTTerm) cargs.get(4);
          String callp5 = arg5.toKM3(); 

          Expression uExpr = arg1.expression;
          uExpr.setType(new Type("Sequence", null));  
          Expression iExpr = arg2.expression; 
          Expression vExpr = arg3.expression; 
          Expression jExpr = arg4.expression; 
          Expression kExpr = arg5.expression; 

          BasicExpression xExpr = 
            BasicExpression.newVariableBasicExpression("_x", 
                               new Type("int", null)); 

          if (uExpr != null && iExpr != null &&
              vExpr != null && jExpr != null &&
              kExpr != null) 
          {  
            Expression uIndexExpr = 
              new BinaryExpression("+", iExpr, xExpr); 
            Expression vIndexExpr = 
              new BinaryExpression("+", jExpr, xExpr); 
            Expression uElement = 
              new BinaryExpression("->at", uExpr,
                                           uIndexExpr); 
            Expression vElement = 
              new BinaryExpression("->at", vExpr,
                                           vIndexExpr);
            AssignStatement asgn = 
              new AssignStatement(vElement,uElement); 
            Vector rpars = new Vector(); 
            rpars.add(unitExpression); 
            rpars.add(kExpr); 
            Expression loopRange = 
              BasicExpression.newFunctionBasicExpression(
                                   "subrange","Integer",rpars);
            Expression loopTest = 
              new BinaryExpression(":", xExpr, loopRange);   
            WhileStatement ws = 
               new WhileStatement(loopTest, asgn); 
            ws.setLoopKind(Statement.FOR); 
            ws.setLoopRange(loopRange); 
            ws.setLoopVar(xExpr); 
            statement = ws;      
            return "for _x : " + loopRange + " do " + 
                 asgn; 
          } 
          return ""; 
        } // Also arraycopy
        else if (arg.isDate() && 
                 ("getTimeInMillis".equals(called) || 
                  "computeTime".equals(called) || 
                  "getTime".equals(called)))
        { ASTTerm.setType(thisliteral,"long"); 

          if (arg.expression != null) 
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "getTime", arg.expression); 
          } 

          return args + ".getTime()"; 
        } 
        else if (arg.isDate() && 
                 "setTimeInMillis".equals(called))
        { ASTTerm arg1 = (ASTTerm) cargs.get(0);
          String callp1 = arg1.toKM3(); 
       
          if (arg.expression != null && 
              arg1.expression != null) 
          { expression = 
              BasicExpression.newCallBasicExpression(
                 "setTime", arg.expression, arg1.expression); 
            statement = 
              InvocationStatement.newInvocationStatement(
                expression, arg1.expression); 
          } 

          return args + ".setTime(" + callp1 + ")"; 
        } 
        else if ("after".equals(called) && arg.isDate())
        { ASTTerm.setType(thisliteral,"boolean");  
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
       
          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(callarg1.expression); 
            expression = 
              BasicExpression.newCallBasicExpression(
                  "dateAfter", arg.expression, pars); 
          } 
            
          return args + ".dateAfter(" + callp1 + ")"; 
        }
        else if ("before".equals(called) && arg.isDate())
        { ASTTerm.setType(thisliteral,"boolean");  
          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 

          if (arg.expression != null && 
              callarg1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(callarg1.expression); 
            expression = 
              BasicExpression.newCallBasicExpression(
                  "dateAfter", arg.expression, pars); 
          } 
            
          return args + ".dateBefore(" + callp1 + ")"; 
        }
        else if (("Calendar".equals(args) ||
                  "GregorianCalendar".equals(args))
                 && "getInstance".equals(called))
        { ASTTerm.setType(thisliteral,"OclDate");  
          expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclDate", "OclDate"); 
          return "OclDate.newOclDate()"; 
        } 

        System.out.println(">>> internal method call: " + arg + "." + called + cargs); 

        Vector xpars = new Vector(); 
        for (int i = 0; i < cargs.size(); i++) 
        { ASTTerm cargi = (ASTTerm) cargs.get(i); 
          if (cargi.expression != null) 
          { xpars.add(cargi.expression); } 
        } 
          
        String cname = ASTTerm.getType(args); 
        if (cname != null) 
        { Entity cent = 
            (Entity) ModelElement.lookupByName(cname,ASTTerm.entities); 
          if (cent != null) 
          { cent.refineOperation(called,xpars); } 
        } 

        if (arg.expression != null) 
        { expression = BasicExpression.newCallBasicExpression(
                called, arg.expression, xpars); 
          ((BasicExpression) expression).setIsEvent();  
          statement = 
            InvocationStatement.newInvocationStatement(
                expression, xpars);  
              
          System.out.println(">>> internal method call: " + arg.expression + "." + called + xpars); 
          return args + "." + calls; 
        } 
      }
      else // call is ASTCompositeTerm 
      { Vector pars = callterm.getParameterExpressions();
        ASTTerm mterm = (ASTTerm) ((ASTCompositeTerm) call).terms.get(0); 
        String called = mterm.toKM3();

        if (arg.expression != null)   
        { expression = BasicExpression.newCallBasicExpression(called, arg.expression, pars); 

          if (ModelElement.lookupByName(args, ASTTerm.entities) != null) 
          { expression.setStatic(true);
            ((BasicExpression) expression).setIsEvent();  
            arg.expression.setUmlKind(Expression.CLASSID); 
          } 
          statement = 
            InvocationStatement.newInvocationStatement(
                                 expression, pars);  
        } 

        return args + "." + calls; 
      } 
    }

    if ("System".equals(args) && "out".equals(calls))
    { ASTTerm.setType(thisliteral,"OclFile");  
      Entity ocltypeent = new Entity("OclFile"); 
      Type ocltype = new Type(ocltypeent); 
      expression = new BasicExpression(ocltype); 
      expression.setUmlKind(Expression.CLASSID);
      BasicExpression sysfile = new BasicExpression("\"System.out\""); 
      sysfile.setType(new Type("String", null)); 
 
      ((BasicExpression) expression).setArrayIndex(sysfile); 
          
      return "OclFile[\"System.out\"]"; 
    } 
    else if ("System".equals(args) && "in".equals(calls))
    { ASTTerm.setType(thisliteral,"OclFile");  
      Entity ocltypeent = new Entity("OclFile"); 
      Type ocltype = new Type(ocltypeent); 
      expression = new BasicExpression(ocltype); 
      expression.setUmlKind(Expression.CLASSID);
      BasicExpression sysfile = new BasicExpression("\"System.in\""); 
      sysfile.setType(new Type("String", null)); 
 
      ((BasicExpression) expression).setArrayIndex(sysfile); 
      return "OclFile[\"System.in\"]"; 
    } 
    else if ("System".equals(args) && "err".equals(calls))
    { ASTTerm.setType(thisliteral,"OclFile");  
      Entity ocltypeent = new Entity("OclFile"); 
      Type ocltype = new Type(ocltypeent); 
      expression = new BasicExpression(ocltype); 
      expression.setUmlKind(Expression.CLASSID);
      BasicExpression sysfile = new BasicExpression("\"System.err\""); 
      sysfile.setType(new Type("String", null)); 
 
      ((BasicExpression) expression).setArrayIndex(sysfile); 
      return "OclFile[\"System.err\"]"; 
    } 

    args = arg.queryForm(); 
    calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls; 
  } 

  public String javalangreflectArray2KM3(ASTTerm arg, 
                                 ASTTerm call, 
                                 String args, 
                                 String called, 
                                 Vector cargs, 
                                 String argliteral)
  { 
    if (( argliteral.equals("Array") || 
          argliteral.endsWith("reflect.Array") ) && 
                 "getLength".equals(called) && 
                 cargs.size() == 1)
     { // arg1->size()
          ASTTerm.setType(this, "int"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();

          if (callarg1.expression != null) 
          { expression = 
              new UnaryExpression("->size", 
                           callarg1.expression); 
          } 
 
          return callp1 + "->size()";  
        }   
        else if (( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 "get".equals(called) && 
                 cargs.size() == 2)
        { // arg1->at(arg2+1)

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { expression = 
              new BinaryExpression("->at", 
                           callarg1.expression, 
                new BinaryExpression("+", 
                               callarg2.expression,
                               unitExpression)); 
          } 
 
          return callp1 + "->at(" + callp2 + "+1)";  
        }   
        else if (( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 ( "getInt".equals(called) || 
                   "getByte".equals(called) || 
                   "getChar".equals(called) ||
                   "getShort".equals(called) ) && 
                 cargs.size() == 2)
        { // arg1->at(arg2+1)
          ASTTerm.setType(this, "int"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression atexpression = 
              new BinaryExpression("->at", 
                           callarg1.expression, 
                new BinaryExpression("+", 
                               callarg2.expression,
                               unitExpression));
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression, 
                                   intTypeExpression);  
          } 
 
          return callp1 + "->at(" + callp2 + "+1)->oclAsType(int)";  
        }   
        else if (( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 ( "getFloat".equals(called) || 
                   "getDouble".equals(called) ) && 
                 cargs.size() == 2)
        { // arg1->at(arg2+1)
          ASTTerm.setType(this, "double"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression atexpression = 
              new BinaryExpression("->at", 
                           callarg1.expression, 
                new BinaryExpression("+", 
                               callarg2.expression,
                               unitExpression));
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression, 
                                   doubleTypeExpression);  
          } 
 
          return callp1 + "->at(" + callp2 + "+1)->oclAsType(double)";  
        }   
        else if (( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 "getBoolean".equals(called) && 
                 cargs.size() == 2)
        { // arg1->at(arg2+1)
          ASTTerm.setType(this, "boolean"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression atexpression = 
              new BinaryExpression("->at", 
                           callarg1.expression, 
                new BinaryExpression("+", 
                               callarg2.expression,
                               unitExpression));
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression, 
                                   booleanTypeExpression);  
          } 
 
          return callp1 + "->at(" + callp2 + "+1)->oclAsType(boolean)";  
        }   
        else if (( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 "getLong".equals(called) && 
                 cargs.size() == 2)
        { // arg1->at(arg2+1)
          ASTTerm.setType(this, "long"); 

          ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
          String callp1 = callarg1.toKM3();
          ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
          String callp2 = callarg2.toKM3();

          if (callarg1.expression != null && 
              callarg2.expression != null) 
          { Expression atexpression = 
              new BinaryExpression("->at", 
                           callarg1.expression, 
                new BinaryExpression("+", 
                               callarg2.expression,
                               unitExpression));
            expression = 
              new BinaryExpression("->oclAsType", 
                                   atexpression, 
                                   longTypeExpression);  
          } 
 
          return callp1 + "->at(" + callp2 + "+1)->oclAsType(long)";  
        }   
        else if (("setInt".equals(called) ||
                  "setDouble".equals(called) ||
                  "setLong".equals(called) || 
                  "set".equals(called) || 
                  "setBoolean".equals(called) || 
                  "setByte".equals(called) || 
                  "setFloat".equals(called) || 
                  "setShort".equals(called)) && 
                 ( argliteral.equals("Array") || 
                   argliteral.endsWith("reflect.Array") ) && 
                 cargs.size() > 2)
        { // same as arg1[arg2] := arg3

          ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
          ASTTerm callarg2 = (ASTTerm) cargs.get(1);
          String callp2 = callarg2.toKM3(); 
          ASTTerm callarg3 = (ASTTerm) cargs.get(2);
          String callp3 = callarg3.toKM3(); 
          
          if (callarg1.expression != null && 
              callarg2.expression != null && 
              callarg3.expression != null) 
          { Expression upd = 
              BasicExpression.newIndexedBasicExpression(
                callarg1.expression, callarg2.expression); 
            statement = 
              new AssignStatement(upd,callarg3.expression);  
          } 
          return callp1 + "[" + callp2 + "] := " + callp3 + ";\n"; 
        } 

    args = arg.queryForm(); 
    String calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls; 
  } 


  public Vector literalValues()
  { Vector res = new Vector(); 

    if ("enumConstants".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm lit = (ASTTerm) terms.get(i); 
        if (",".equals(lit + "")) { } 
        else
        { res.add(lit.toKM3()); } 
      } 
    }
    return res;   
  }

  public Vector getParameterExpressions()
  { Vector res = new Vector(); 
    if ("arguments".equals(tag) && 
        terms.size() >= 3 && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + ""))
    { ASTTerm exprs = (ASTTerm) terms.get(1); 
      return exprs.getParameterExpressions(); 
    } 

    if ("expressionList".equals(tag))
    { 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm telem = (ASTTerm) terms.get(i); 
        if (telem instanceof ASTSymbolTerm) { } 
        else 
        { if (telem.expression != null) 
          { res.add(telem.expression); }
        }  
      } 
    }

    return res; 
  } 

  public Vector getTypeParameterTypes()
  { Vector res = new Vector(); 
    if ("typeArguments".equals(tag) || 
        "nonWildcardTypeArguments".equals(tag))
    { 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm telem = (ASTTerm) terms.get(i); 
        if (telem instanceof ASTSymbolTerm) { } 
        else 
        { if (telem.modelElement instanceof Type) 
          { res.add(telem.modelElement); }
          else if (telem.modelElement instanceof Entity) 
          { res.add(new Type((Entity) telem.modelElement)); }
        }  
      } 
    }
    return res; 
  } 

  public Vector getCreatorArgumentExpressions()
  { Vector res = new Vector();
 
    if (tag.equals("classCreatorRest"))
    { int carguments = terms.size();
      if (carguments > 0 && terms.get(0) instanceof ASTCompositeTerm) 
      { ASTCompositeTerm arguments = (ASTCompositeTerm) terms.get(0); 
        return arguments.getCreatorArgumentExpressions(); 
      } 
    }
    else if (tag.equals("arguments"))
    { int carguments = terms.size(); 
      if (carguments > 1 && terms.get(1) instanceof ASTCompositeTerm)
      { ASTCompositeTerm exprlist = (ASTCompositeTerm) terms.get(1);
        return exprlist.getParameterExpressions(); 
      } 
    }

    return res; 
  }  

  public String creatorQueryForm()
  { if ("creator".equals(tag) || "innerCreator".equals(tag))
    { // 2 arguments, the type, and any constructor pars

      ASTTerm cls = (ASTTerm) terms.get(0);
      String clsliteral = cls.literalForm(); 
         // Java createdName, can have type parameters
 
      String clsname = cls.toKM3type(); 
      ASTTerm.setType(this,clsname); 

      String cident = clsname; 
      if (cls.modelElement != null) 
      { cident = cls.modelElement.getName(); } 
      // System.out.println(">>> " + this + " has type " + cident); 

      int carguments = 0; 
      Vector cargs = new Vector(); 

      ASTTerm args = (ASTTerm) terms.get(1);
      if (args instanceof ASTCompositeTerm)
      { ASTCompositeTerm argsterms = (ASTCompositeTerm) args; 
        carguments = argsterms.terms.size();
        if (carguments > 0 && argsterms.terms.get(0) instanceof ASTCompositeTerm) 
        { ASTCompositeTerm arguments = (ASTCompositeTerm) argsterms.terms.get(0); 
          carguments = arguments.terms.size(); 
          if (carguments > 1 && arguments.terms.get(1) instanceof ASTCompositeTerm)
          { ASTCompositeTerm exprlist = (ASTCompositeTerm) arguments.terms.get(1);
            cargs = getCallArguments(exprlist);  
            carguments = exprlist.terms.size(); 
          } 
          else 
          { carguments = 0; } 
        } 
        else 
        { carguments = 0; } 
      } 


      // JOptionPane.showInputDialog(">>::: Constructor " + this + " for " + clsname + " " + clsliteral + " has " + cargs.size() + " arguments: " + cargs); 

      // String basicres = clsname + ".new" + clsname + "()"; 
        
      if (args instanceof ASTCompositeTerm && 
          "arrayCreatorRest".equals(((ASTCompositeTerm) args).tag))
      { ASTCompositeTerm argsterm = (ASTCompositeTerm) args;

        String res = "Sequence{}"; 
        expression = new SetExpression(true); 

        if (argsterm.arity() == 3 && 
            "[".equals(argsterm.terms.get(0) + "") && 
            "]".equals(argsterm.terms.get(2) + ""))
        { ASTTerm sze = (ASTTerm) argsterm.terms.get(1);
          String defaultValue = getDefaultValue(clsname);  
          res = "Integer.subrange(1," + sze.toKM3() + ")->collect(" + defaultValue + ")";
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,clsname);  // ??

          if (sze.expression != null) 
          { BasicExpression unit = new BasicExpression(1); 
            Vector pars = new Vector(); 
            pars.add(unit); 
            pars.add(sze.expression);
          
            BasicExpression rng = BasicExpression.newFunctionBasicExpression("subrange", "Integer", pars);  
            BasicExpression def = new BasicExpression(defaultValue); 
            expression = new BinaryExpression("->collect", rng, def);  
            expression.setType(new Type("Sequence",null)); 
          } 
        } 
        else if (argsterm.arity() == 3 && 
                   "[".equals(argsterm.terms.get(0) + "") && 
                   "]".equals(argsterm.terms.get(1) + ""))
        { // new T[] {elems}
          ASTTerm arrayInit = (ASTTerm) argsterm.terms.get(2); 
          res = arrayInit.toKM3(); 
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,clsname);  // ??
          expression = arrayInit.expression; 
        } 
        else if (argsterm.arity() == 6 && 
            "[".equals(argsterm.terms.get(0) + "") && 
            "]".equals(argsterm.terms.get(2) + "") && 
            "[".equals(argsterm.terms.get(3) + "") &&
            "]".equals(argsterm.terms.get(5) + ""))
        { ASTTerm sze1 = (ASTTerm) argsterm.terms.get(1);
          ASTTerm sze2 = (ASTTerm) argsterm.terms.get(4);
          String defaultValue = getDefaultValue(clsname);  
          res = "Integer.subrange(1," + sze1.toKM3() + ")->collect(Integer.subrange(1," + sze2.toKM3() + ")->collect(" + defaultValue + "))";
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(" + clsname + ")");  // ??

          if (sze1.expression != null &&
              sze2.expression != null) 
          { Vector pars2 = new Vector(); 
            pars2.add(unitExpression); 
            pars2.add(sze2.expression);
          
            BasicExpression rng2 = 
              BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars2);  
            BasicExpression def = 
              new BasicExpression(defaultValue); 
            Expression col = 
              new BinaryExpression("->collect", rng2, def);  
            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(sze1.expression);
          
            BasicExpression rng1 = 
              BasicExpression.newFunctionBasicExpression(
                 "subrange", "Integer", pars1);
            expression = 
              new BinaryExpression("->collect", rng1, col);
            expression.setType(new Type("Sequence",null)); 
          } 
        } 
        else if (argsterm.arity() == 5 && 
                   "[".equals(argsterm.terms.get(0) + "") && 
                   "]".equals(argsterm.terms.get(2) + "") &&
                   "[".equals(argsterm.terms.get(3) + "") &&
                   "]".equals(argsterm.terms.get(4) + ""))
        { // new T[n] [] 
          ASTTerm arraySze = (ASTTerm) argsterm.terms.get(1); 
          String sze = arraySze.toKM3(); 
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(" + clsname + ")");  // ??
          res = "Integer.subrange(1," + sze + ")->collect(Sequence{})";
          Vector pars1 = new Vector(); 
          pars1.add(unitExpression); 
          pars1.add(arraySze.expression);

          Expression arrayDom = 
              BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars1);  
          Expression emptySequence = new SetExpression(true); 
          expression = 
            new BinaryExpression("->collect", arrayDom, 
                                 emptySequence); 
            expression.setType(new Type("Sequence",null)); 
        } 
        else if (argsterm.arity() == 5 && 
                   "[".equals(argsterm.terms.get(0) + "") && 
                   "]".equals(argsterm.terms.get(1) + "") &&
                   "[".equals(argsterm.terms.get(2) + "") && 
                   "]".equals(argsterm.terms.get(3) + ""))
        { // new T[][] {elems}
          ASTTerm arrayInit = (ASTTerm) argsterm.terms.get(4); 
          res = arrayInit.toKM3(); 
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(" + clsname + ")");  
          expression = arrayInit.expression; 
        } 
        else if (argsterm.arity() == 9 && 
            "[".equals(argsterm.terms.get(0) + "") && 
            "]".equals(argsterm.terms.get(2) + "") && 
            "[".equals(argsterm.terms.get(3) + "") &&
            "]".equals(argsterm.terms.get(5) + "") && 
            "[".equals(argsterm.terms.get(6) + "") &&
            "]".equals(argsterm.terms.get(8) + ""))
        { ASTTerm sze1 = (ASTTerm) argsterm.terms.get(1);
          ASTTerm sze2 = (ASTTerm) argsterm.terms.get(4);
          ASTTerm sze3 = (ASTTerm) argsterm.terms.get(7);
          
          String defaultValue = getDefaultValue(clsname);  
          res = "Integer.subrange(1," + sze1.toKM3() + ")->collect(Integer.subrange(1," + sze2.toKM3() + ")->collect(Integer.subrange(1," + sze3.toKM3() + ")->collect(" + defaultValue + ")))";
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(Sequence(" + clsname + "))");  

          if (sze1.expression != null &&
              sze2.expression != null && 
              sze3.expression != null) 
          { Vector pars3 = new Vector(); 
            pars3.add(unitExpression); 
            pars3.add(sze3.expression);
          
            BasicExpression rng3 = 
              BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars3);  
          
            Vector pars2 = new Vector(); 
            pars2.add(unitExpression); 
            pars2.add(sze2.expression);
          
            BasicExpression rng2 = 
              BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars2);  
            BasicExpression def = 
              new BasicExpression(defaultValue); 
            Expression col = 
              new BinaryExpression("->collect", rng3, def);  
            Expression col1 = 
              new BinaryExpression("->collect", rng2, col); 
 
            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(sze1.expression);
          
            BasicExpression rng1 = 
              BasicExpression.newFunctionBasicExpression(
                 "subrange", "Integer", pars1);
            expression = 
              new BinaryExpression("->collect", rng1, col1);
            expression.setType(new Type("Sequence",null)); 
          } 
        } 
        else if (argsterm.arity() == 8 && 
            "[".equals(argsterm.terms.get(0) + "") && 
            "]".equals(argsterm.terms.get(2) + "") && 
            "[".equals(argsterm.terms.get(3) + "") &&
            "]".equals(argsterm.terms.get(5) + "") && 
            "[".equals(argsterm.terms.get(6) + "") &&
            "]".equals(argsterm.terms.get(7) + ""))
        { ASTTerm sze1 = (ASTTerm) argsterm.terms.get(1);
          ASTTerm sze2 = (ASTTerm) argsterm.terms.get(4);
          
          String defaultValue = getDefaultValue(clsname);  
          res = "Integer.subrange(1," + sze1.toKM3() + ")->collect(Integer.subrange(1," + sze2.toKM3() + ")->collect(Sequence{}))";
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(Sequence(" + clsname + "))");  

          if (sze1.expression != null &&
              sze2.expression != null) 
          { Vector pars2 = new Vector(); 
            pars2.add(unitExpression); 
            pars2.add(sze2.expression);
          
            BasicExpression rng2 = 
              BasicExpression.newFunctionBasicExpression(
                  "subrange", "Integer", pars2);  
            Expression col = 
              new SetExpression(true);  
            Expression col1 = 
              new BinaryExpression("->collect", rng2, col); 
 
            Vector pars1 = new Vector(); 
            pars1.add(unitExpression); 
            pars1.add(sze1.expression);
          
            BasicExpression rng1 = 
              BasicExpression.newFunctionBasicExpression(
                 "subrange", "Integer", pars1);
            expression = 
              new BinaryExpression("->collect", rng1, col1);
            expression.setType(new Type("Sequence",null)); 
          } 
        } 
        else if (argsterm.arity() == 7 && 
                   "[".equals(argsterm.terms.get(0) + "") && 
                   "]".equals(argsterm.terms.get(1) + "") &&
                   "[".equals(argsterm.terms.get(2) + "") && 
                   "]".equals(argsterm.terms.get(3) + "") &&
                   "[".equals(argsterm.terms.get(4) + "") && 
                   "]".equals(argsterm.terms.get(5) + ""))
        { // new T[][][] {elems}
          ASTTerm arrayInit = (ASTTerm) argsterm.terms.get(6); 
          res = arrayInit.toKM3(); 
          ASTTerm.setType(this,"Sequence");
          ASTTerm.setElementType(this,"Sequence(Sequence(" + clsname + "))");  
          expression = arrayInit.expression; 
        } 

        return res;  
      } 


      if (args instanceof ASTCompositeTerm && 
          "classCreatorRest".equals(((ASTCompositeTerm) args).tag))
      { ASTCompositeTerm argsterm = (ASTCompositeTerm) args;
        if (argsterm.arity() == 2) // inner class
        { cident = "";
          Entity newc = null; 
 
          if (args.modelElement != null && 
              args.modelElement instanceof Entity) 
          { newc = (Entity) args.modelElement; 
            cident = newc.getName(); 
          } 
          else 
          { cident = 
              Identifier.nextIdentifier("_Class"); 
            newc = new Entity(cident);
            args.modelElement = newc; 

            System.out.println("+++ Anonymous inner class: " + cident + " from " + cls); 

            if ("Object".equals(cls.literalForm())) { }
            else if ("Runnable".equals(cls.literalForm()))
            { newc.addStereotype("active"); }  
            else if (cls.literalForm().startsWith("Comparator"))
            { Entity oclcomparator = new Entity("OclComparator"); 
              newc.setSuperclass(oclcomparator); 
            }  
            else 
            { Entity sup = (Entity)
                ModelElement.lookupByName(clsname, 
                                   ASTTerm.entities); 
              if (sup != null) 
              { newc.setSuperclass(sup); } 
            } 
            ASTTerm clsbody = (ASTTerm) argsterm.terms.get(1); 
            String body = clsbody.toKM3();
          
            ASTTerm.entities.add(newc); 
            newc.addModelElements(clsbody.modelElements);
            
            if (modelElements == null) 
            { modelElements = new Vector(); } 
            modelElements.add(newc);  
          }

          // System.out.println("::>> Creator modelElements: " + modelElements); 

          Vector creatorArguments = new Vector(); 
          if (args instanceof ASTCompositeTerm)
          { creatorArguments = 
              ((ASTCompositeTerm) args).getCreatorArgumentExpressions(); 
            System.out.println("::>> Creator arguments: " + creatorArguments); 
          } 

          if (args.expressions != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                 "new" + cident, cident, 
                 args.expressions); 

            ASTTerm.setType(this,cident); 
            expression.setType(new Type(newc)); 
           
            return "" + expression;  
          } 
          else
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "new" + cident, cident, creatorArguments); 

            ASTTerm.setType(this,cident); 
            expression.setType(new Type(newc)); 

            return cident + ".new" + cident + "()";  
          } 
        }
        
        // return baseres;  
      } 


      String args1 = args.toKM3();
 

      if ("BigInteger".equals(clsliteral))
      { ASTTerm.setType(this,"long");

        if (args.expression != null) 
        { expression = new UnaryExpression("->toLong", args.expression); 
          expression.setType(new Type("long", null)); 
        } 
 
        return args1 + "->toLong()"; 
      } 

      if ("AtomicInteger".equals(clsliteral))
      { ASTTerm.setType(this,"int");

        if (args.expression != null) 
        { expression = args.expression; 
          expression.setType(new Type("int", null)); 
        } 
 
        return args1; 
      } 

      if ("AtomicLong".equals(clsliteral))
      { ASTTerm.setType(this,"long");

        if (args.expression != null) 
        { expression = args.expression; 
          expression.setType(new Type("long", null)); 
        } 
 
        return args1; 
      } 

      if ("BufferedReader".equals(clsliteral) || 
          "LittleEndianInput".equals(clsliteral) ||
          "BigEndianInput".equals(clsliteral))
      { ASTTerm.setType(this,"OclFile"); 
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String sarg = arg1.toKM3(); 

        expression = arg1.expression; 

        return sarg; 
      }

      if ("BufferedWriter".equals(clsliteral) ||
          "LittleEndianOutput".equals(clsliteral) ||
          "BigEndianOutput".equals(clsliteral))
      { ASTTerm.setType(this,"OclFile"); 
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String sarg = arg1.toKM3();
        expression = arg1.expression; 

        return sarg;  
      }

      if ("PrintStream".equals(clsliteral))
      { ASTTerm.setType(this,"OclFile"); 
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String sarg = arg1.toKM3();
        expression = arg1.expression; 

        return sarg; 
      }

      if ("Socket".equals(clsliteral) && 
          cargs.size() > 1)
      { ASTTerm.setType(this,"OclDatasource");

        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String hostarg = arg1.toKM3(); // String
        ASTTerm arg2 = (ASTTerm) cargs.get(1); 
        String portarg = arg2.toKM3(); // int
      
        if (arg1.expression != null && 
            arg2.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          pars.add(arg2.expression); 

          expression =   
            BasicExpression.newStaticCallBasicExpression(
              "newSocket", "OclDatasource", pars); 
          expression.setType(new Type("OclDatasource", null)); 
        } 
        return "OclDatasource.newSocket(" + hostarg + "," + 
                                          portarg + ")"; 
      }  

      if ("ServerSocket".equals(clsliteral) && 
          cargs.size() > 1)
      { ASTTerm.setType(this,"OclDatasource");

        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String hostarg = arg1.toKM3(); // String
        ASTTerm arg2 = (ASTTerm) cargs.get(1); 
        String portarg = arg2.toKM3(); // int
      
        if (arg1.expression != null && 
            arg2.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          pars.add(arg2.expression); 

          expression =   
            BasicExpression.newStaticCallBasicExpression(
              "newServerSocket", "OclDatasource", pars); 
          expression.setType(new Type("OclDatasource", null)); 
        } 
        return "OclDatasource.newServerSocket(" + hostarg + "," + 
                                          portarg + ")"; 
      }  
        
      // And DatagramSockets

      if ("FileReader".equals(clsliteral))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String sarg = arg1.toKM3();
      
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
              BasicExpression.newStaticCallBasicExpression(
                  "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                      "newOclFile_Read", "OclFile", pars);  
            expression.setType(new Type("OclFile", null)); 
          } 
          return "OclFile.newOclFile_Read(OclFile.newOclFile" + sarg + ")"; 
        }  

        // assume argument is a file 
        if (arg1.expression != null) 
        { expression = 
             BasicExpression.newStaticCallBasicExpression(
               "newOclFile_Read", "OclFile", arg1.expression);
          expression.setType(new Type("OclFile", null)); 
        } 
 
        return "OclFile.newOclFile_Read" + args1; 
      }

      if ("RandomAccessFile".equals(clsliteral))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        String sarg = arg1.toKM3();
      
        boolean writer = false; 
        if (cargs.size() > 1) 
        { ASTTerm arg2 = (ASTTerm) cargs.get(1); 
          String sarg2 = arg2.literalForm(); 
          if (sarg2.indexOf("w") >= 0) 
          { writer = true; } 
        } 

        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
               BasicExpression.newStaticCallBasicExpression(
                  "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 

            if (writer) 
            { expression = 
                BasicExpression.newStaticCallBasicExpression(
                  "newOclFile_Write", "OclFile", pars);  
              expression.setType(new Type("OclFile", null));
              return "OclFile.newOclFile_Write(" +                    
                        "OclFile.newOclFile(" + sarg + "))"; 
            } 
            else 
            { expression =    
                BasicExpression.newStaticCallBasicExpression(
                  "newOclFile_Read", "OclFile", pars);
              expression.setType(new Type("OclFile", null));
              return "OclFile.newOclFile_Read(" +                    
                        "OclFile.newOclFile(" + sarg + "))"; 
            }   
          } 
        }  

        // else assume argument1 is a file 
        if (arg1.expression != null) 
        { if (writer) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", 
                arg1.expression); 
            expression.setType(new Type("OclFile", null));
            return "OclFile.newOclFile_Write" + args1; 
          } 
          else 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Read", "OclFile", 
                arg1.expression); 
            expression.setType(new Type("OclFile", null));
            return "OclFile.newOclFile_Read" + args1; 
          } 
        } 
      }

      if ("Scanner".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");

        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = BasicExpression.newStaticCallBasicExpression("newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = 
               BasicExpression.newStaticCallBasicExpression(
                   "newOclFile_Read", "OclFile", pars);
            expression.setType(new Type("OclFile", null));  
          } 

          return "OclFile.newOclFile_Read(OclFile.newOclFile(" + arg1.toKM3() + "))"; 
        }

        if (arg1.expression != null) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
               "newOclFile_Read", "OclFile", arg1.expression);
          expression.setType(new Type("OclFile", null)); 
        } 
  
        return "OclFile.newOclFile_Read(" + arg1.toKM3() + ")"; 
      }

      if ("InputStreamReader".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
              BasicExpression.newStaticCallBasicExpression(
               "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = BasicExpression.newStaticCallBasicExpression("newOclFile_Read", "OclFile", pars);
            expression.setType(new Type("OclFile", null));  
          } 
          return "OclFile.newOclFile_Read(OclFile.newOclFile" + args1 + ")"; 
        }  

        if (arg1.expression != null) 
        { expression = 
             BasicExpression.newStaticCallBasicExpression(
               "newOclFile_Read", "OclFile", arg1.expression);
          expression.setType(new Type("OclFile", null)); 
        } 

        return "OclFile.newOclFile_Read" + args1; 
      } // _Stream perhaps. 

      if ("ObjectInputStream".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                      "newOclFile_ReadB", "OclFile", pars);
            expression.setType(new Type("OclFile", null));  
          } 
          return "OclFile.newOclFile_ReadB(OclFile.newOclFile" + args1 + ")"; 
        }
  
        if (arg1.expression != null) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclFile_ReadB", "OclFile", arg1.expression);
          expression.setType(new Type("OclFile", null)); 
        } 

        return "OclFile.newOclFile_ReadB" + args1; 
      } // _Stream perhaps. 

      if ("StringWriter".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        return "OclFile.newOclFile_Write(OclFile.newOclFile(\"_tmp.txt\"))"; 
      }

      if ("FileWriter".equals(cls.literalForm()) ||
          "PrintWriter".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", pars);
            expression.setType(new Type("OclFile", null));  
          }
          return "OclFile.newOclFile_Write(OclFile.newOclFile(" + arg1.toKM3() + "))"; 
        }
  
        if (arg1.expression != null) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclFile_Write", "OclFile", arg1.expression); 
          expression.setType(new Type("OclFile", null));
        } 

        return "OclFile.newOclFile_Write(" + arg1.toKM3() + ")"; 
      }

      if ("FileOutputStream".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { ASTTerm.setType(args,"String");
          if (arg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", arg1.expression);
            expression.setType(new Type("OclFile", null));   
          }
          return "OclFile.newOclFile(" + arg1.toKM3() + ")"; 
        }
  
        // Else, arg1 is already an OclFile 
        ASTTerm.setType(args,"OclFile");
          
        if (arg1.expression != null) 
        { expression = arg1.expression; }  

        return arg1.toKM3(); 
      }

      if ("FileInputStream".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", arg1.expression);
            expression.setType(new Type("OclFile", null));   
          }
          return "OclFile.newOclFile(" + arg1.toKM3() + ")"; 
        }
  
        // Else, arg1 is already an OclFile 

        if (arg1.expression != null) 
        { expression = arg1.expression; }  

        return arg1.toKM3(); 
      }

      if ("Formatter".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression par = 
              BasicExpression.newStaticCallBasicExpression(
                 "newOclFile", "OclFile", arg1.expression); 
            pars.add(par); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", pars);
            expression.setType(new Type("OclFile", null));  
          }
          return "OclFile.newOclFile_Write(OclFile.newOclFile(" + arg1.toKM3() + "))"; 
        }  

        if (arg1.expression != null) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclFile_Write", "OclFile", arg1.expression);
          expression.setType(new Type("OclFile", null)); 
        } 

        return "OclFile.newOclFile_Write(" + arg1.toKM3() + ")"; 
      }

      if ("OutputStreamWriter".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(arg1.expression);
            Expression innerCall = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", pars);  
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", innerCall);
            expression.setType(new Type("OclFile", null));
          } 
          return "OclFile.newOclFile_Write(OclFile.newOclFile" + args1 + ")"; 
        }

        if (arg1.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          expression = 
            BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", pars);
          expression.setType(new Type("OclFile", null));
        } 
  
        return "OclFile.newOclFile_Write" + args1; 
      } // but mark it as a stream, not a file. 

      if ("ObjectOutputStream".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclFile");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        if (arg1.isString())
        { ASTTerm.setType(args,"String");
          
          if (arg1.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(arg1.expression);
            Expression innerCall = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile", "OclFile", pars);  
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_WriteB", "OclFile", innerCall);
            expression.setType(new Type("OclFile", null));
          } 
          return "OclFile.newOclFile_WriteB(OclFile.newOclFile" + args1 + ")"; }  

        ASTTerm.setType(args,"OclFile");
          
        if (arg1.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          expression = 
            BasicExpression.newStaticCallBasicExpression(
                "newOclFile_WriteB", "OclFile", pars);
          expression.setType(new Type("OclFile", null));
        } 

        return "OclFile.newOclFile_WriteB" + args1; 
      } // but mark it as a stream, not a file. 

      if ("Thread".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclProcess");
        ASTTerm arg1 = (ASTTerm) cargs.get(0);

        if (cargs.size() > 1) // Runnable, String
        { ASTTerm arg2 = (ASTTerm) cargs.get(1); 
          
          if (arg1.expression != null && 
              arg2.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(arg1.expression); 
            pars.add(arg2.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclProcess", "OclProcess", pars); 
          } 
          return "OclProcess.newOclProcess" + args1; 
        }  

        if (arg1.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          long now = (new java.util.Date()).getTime(); 
          pars.add(new BasicExpression("\"Thread-" + now + "\"")); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "newOclProcess", "OclProcess", pars); 
          args1 = "(" + arg1.expression + ", \"Thread-" + now + "\")"; 
        }
 
        return "OclProcess.newOclProcess" + args1; 
      } // but mark it as a stream, not a file. 

      if ("Timer".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclProcess");
        
        // No argument. 

        Vector pars = new Vector(); 
        long now = (new java.util.Date()).getTime(); 
        pars.add(new BasicExpression("\"\"")); 
        pars.add(new BasicExpression("\"TimerThread-" + now + "\"")); 
        expression = 
          BasicExpression.newStaticCallBasicExpression(
                "newOclProcess", "OclProcess", pars); 
        String targs1 = "(\"\", \"TimerThread-" + now + "\")"; 
 
        return "OclProcess.newOclProcess" + targs1; 
      } 

      if ("URL".equals(cls.literalForm()))
      { ASTTerm.setType(this,"OclDatasource"); 

        Vector pars = new Vector();
        for (int p = 0; p < cargs.size(); p++) 
        { ASTTerm argp = (ASTTerm) cargs.get(p);
          if (argp.expression != null)
          { pars.add(argp.expression); }  
        }
        
        if (pars.size() == 3) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
                "newURL_PHF", "OclDatasource", pars); 
         
          return "OclDatasource.newURL_PHF" + args1;
        } 

        if (pars.size() == 4) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
                "newURL_PHNF", "OclDatasource", pars); 
         
          return "OclDatasource.newURL_PHNF" + args1;
        }
  
        expression = 
            BasicExpression.newStaticCallBasicExpression(
                "newURL", "OclDatasource", pars); 
         
        return "OclDatasource.newURL" + args1;  
      } 
 
      if ("Boolean".equals(clsliteral))
      { ASTTerm.setType(this,"boolean"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toBoolean", arg1.expression); 
        } 
 
        return "(" + args1 + " + \"\")->toBoolean()"; 
      } 

      if ("Integer".equals(clsliteral))
      { ASTTerm.setType(this,"int"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toInteger", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toInteger()"; 
      } 
      
      if ("Long".equals(clsliteral))
      { ASTTerm.setType(this,"long"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toLong", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toLong()"; 
      }
 
      if ("Byte".equals(clsliteral))
      { ASTTerm.setType(this,"int"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toInteger", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toInteger()"; 
      } 
      
      if ("Short".equals(clsliteral))
      { ASTTerm.setType(this,"int"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toInteger", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toInteger()"; 
      } 
      
      if ("Double".equals(clsliteral))
      { ASTTerm.setType(this,"double"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toReal", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toReal()"; 
      } 
      
      if ("Float".equals(clsliteral))
      { ASTTerm.setType(this,"double"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toReal", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toReal()"; 
      } 
      
      if ("BigDecimal".equals(clsliteral))
      { ASTTerm.setType(this,"double"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { expression = 
            new UnaryExpression("->toReal", arg1.expression); 
        } 

        return "(" + args1 + " + \"\")->toReal()"; 
      } 

      if ("Number".equals(clsliteral))
      { ASTTerm.setType(this,"double"); 
        expression = new BasicExpression(0.0); 
        return "0.0"; 
      } 

      if ("Character".equals(cls.literalForm()))
      { ASTTerm.setType(this,"String"); 

        ASTTerm arg1 = (ASTTerm) cargs.get(0);
        if (arg1.expression != null)
        { Expression emptyStr = 
            BasicExpression.newValueBasicExpression("\"\""); 
          expression = 
            new BinaryExpression("+", emptyStr, arg1.expression); 
          expression.setBrackets(true); 
        } 

        return "(" + args1 + " + \"\")"; 
      } 

      if ("CharSequence".equals(cls.literalForm()))
      { ASTTerm.setType(this,"String");
        if (cargs.size() > 0)
        { ASTTerm strarg = (ASTTerm) cargs.get(0);
          String val = strarg.toKM3();
          expression = strarg.expression;  
          return val; 
        } 
      } 

      if (("String".equals(clsliteral) ||
           "StringBuilder".equals(clsliteral) ||
           "StringBuffer".equals(clsliteral) || 
           "Segment".equals(clsliteral)) && 
          "()".equals(args.literalForm()))
      { ASTTerm.setType(this,"String");

        expression = new BasicExpression("\"\""); 
        expression.setType(new Type("String", null)); 

        return "\"\""; 
      }
      else if (("String".equals(clsliteral) ||
                "StringBuilder".equals(clsliteral) || 
                "StringBuffer".equals(clsliteral) ||
                "Segment".equals(clsliteral)) &&
               cargs.size() > 0 && cargs.size() < 3) 
      { ASTTerm strarg = (ASTTerm) cargs.get(0);
        String val = strarg.toKM3(); 

        ASTTerm.setType(this,"String");

        if (strarg.isString())
        { if (strarg.expression != null)
          { Expression emptyStr = 
              BasicExpression.newValueBasicExpression("\"\""); 
            expression = 
              new BinaryExpression("+", emptyStr, strarg.expression); 
            expression.setBrackets(true); 
          } 
          return "(\"\" + " + val + ")"; 
        } 
        else if (strarg.isIntegerSequence())
        { if (strarg.expression != null) 
          { Expression xvar = 
              BasicExpression.newVariableBasicExpression(
                                                     "_x");
            Expression colarg = 
              new UnaryExpression("->byte2char", xvar); 
            Expression collhs = 
              new BinaryExpression(":", xvar, 
                                   strarg.expression);  
            Expression col = 
              new BinaryExpression("|C", collhs, colarg); 
            expression = 
              new UnaryExpression("->sum", col); 
          } 
  
          return val + "->collect( _x | _x->byte2char() )->sum()"; 
        } 
        else if (strarg.isStringSequence())
        { if (strarg.expression != null) 
          { expression = new UnaryExpression("->sum", 
                                    strarg.expression); 
          }
 
          return val + "->sum()"; 
        }
        else 
        { expression = 
            BasicExpression.newValueBasicExpression("\"\""); 
          return "\"\""; 
        } // capacity
      }  
      else if (("String".equals(clsliteral) || 
                "Segment".equals(clsliteral))
               && cargs.size() >= 3)
      { ASTTerm strarg = (ASTTerm) cargs.get(0);
        ASTTerm strind = (ASTTerm) cargs.get(1);
        ASTTerm strleng = (ASTTerm) cargs.get(2);
        String s1 = strarg.toKM3();
        String s2 = strind.toKM3();
        String s3 = strleng.toKM3();
        ASTTerm.setType(this,"String");

        if (strarg.isString())
        { if (strarg.expression != null && 
              strind.expression != null && 
              strleng.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BinaryExpression("+", strind.expression, unitExpression)); 
            pars.add(new BinaryExpression("+", 
                      strind.expression, strleng.expression)); 
            expression = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", strarg.expression, pars); 
          }
 
          return s1 + ".subrange(" + s2 + "+1, " + s2 + "+" + s3 + ")"; 
        } 
        else if (strarg.isIntegerSequence())
        { if (strarg.expression != null && 
              strind.expression != null && 
              strleng.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BinaryExpression("+", strind.expression, unitExpression)); 
            pars.add(new BinaryExpression("+", 
                      strind.expression, strleng.expression)); 
            Expression subexpression = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", strarg.expression, pars);
            Expression _x = 
              BasicExpression.newVariableBasicExpression("_x");
            _x.setType(new Type("int", null));  
            Expression coldom = 
              new BinaryExpression(":", _x, subexpression); 
            Expression colrng = 
              new UnaryExpression("->byte2char", _x);  
            Expression colexpr = 
              new BinaryExpression("|C", coldom, colrng);
            expression = 
              new UnaryExpression("->sum", colexpr);   
          }

          return s1 + ".subrange(" + s2 + "+1, " + s2 + "+" + s3 + ")->collect( _x | _x->byte2char() )->sum()"; 
        } 
        else if (strarg.isStringSequence())
        { if (strarg.expression != null && 
              strind.expression != null && 
              strleng.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BinaryExpression("+", strind.expression, unitExpression)); 
            pars.add(new BinaryExpression("+", 
                      strind.expression, strleng.expression)); 
            Expression subexpression = 
              BasicExpression.newFunctionBasicExpression(
                "subrange", strarg.expression, pars);
            expression = 
              new UnaryExpression("->sum", subexpression);   
          }
          return s1 + ".subrange(" + s2 + "+1, " + s2 + "+" + s3 + ")->sum()"; 
        }
      }  
      else if ("String".equals(cls.literalForm()))
      { return "StringLib.newString" + args1; }

      if ("StringTokenizer".equals(cls.literalForm()) && cargs.size() == 1)
      { ASTTerm.setType(this,"OclIterator");
        ASTTerm arg1 = (ASTTerm) cargs.get(0); 

        if (arg1.expression != null) 
        { expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclIterator_String", "OclIterator", 
              arg1.expression); 
        } 

        return "OclIterator.newOclIterator_String" + args1; 
      }
      else if ("StringTokenizer".equals(cls.literalForm()) && cargs.size() == 2) 
      { ASTTerm.setType(this,"OclIterator");

        ASTTerm arg1 = (ASTTerm) cargs.get(0); 
        ASTTerm arg2 = (ASTTerm) cargs.get(1); 

        if (arg1.expression != null && 
            arg2.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(arg1.expression); 
          pars.add(arg2.expression); 
          expression = 
            BasicExpression.newStaticCallBasicExpression(
              "newOclIterator_String_String", 
              "OclIterator", pars); 
        } 

        return "OclIterator.newOclIterator_String_String" + args1; 
      }

      // JOptionPane.showInputDialog("**** clsname = " + clsname); 

      // JOptionPane.showInputDialog(">>> creation of " + clsliteral + " with " + cargs); 

      if (clsliteral.startsWith("IntStream"))
      { ASTTerm.setType(this,"Sequence(int)");

        Expression subr = new SetExpression(true); 
        
        expression = 
          new BinaryExpression("->collect", subr,
                new BasicExpression(0)); 

        return "Sequence{}->collect(0)"; 
      } 

      if (clsliteral.startsWith("LongStream"))
      { ASTTerm.setType(this,"Sequence(long)");

        Expression subr = new SetExpression(true); 
        
        expression = 
          new BinaryExpression("->collect", subr,
                new BasicExpression(0)); 

        return "Sequence{}->collect(0)"; 
      } 

      if (clsliteral.startsWith("DoubleStream"))
      { ASTTerm.setType(this,"Sequence(double)");

        Expression subr = new SetExpression(true); 
        
        expression = 
          new BinaryExpression("->collect", subr,
                new BasicExpression(0.0)); 

        return "Sequence{}->collect(0.0)"; 
      } 


      if (clsliteral.startsWith("BitSet") && cargs.size() == 0)
      { ASTTerm.setType(this,"Sequence(boolean)");

        Vector pars = new Vector(); 
        pars.add(unitExpression); 
        pars.add(new BasicExpression(64)); 

        Expression subr = 
          BasicExpression.newStaticCallBasicExpression(
            "subrange", "Integer", pars); 
        expression = 
          new BinaryExpression("->collect", subr,
                new BasicExpression(false)); 

        return "Integer.subrange(1,64)->collect(false)"; 
      } 

      if (clsliteral.startsWith("BitSet") && cargs.size() > 0)
      { ASTTerm.setType(this,"Sequence(boolean)");
        ASTTerm strarg = (ASTTerm) cargs.get(0);
        String argocl = strarg.toKM3(); 

        if (strarg.expression != null) 
        { Vector pars = new Vector(); 
          pars.add(unitExpression); 
          pars.add(strarg.expression); 

          Expression subr = 
            BasicExpression.newStaticCallBasicExpression(
              "subrange", "Integer", pars); 
          expression = 
            new BinaryExpression("->collect", subr,
                new BasicExpression(false)); 
        } 

        return "Integer.subrange(1," + argocl + ")->collect(false)"; 
      } 

      if (("Set".equals(clsname) || 
           clsname.startsWith("Set(")) && cargs.size() == 0)
      { ASTTerm.setType(this,"Set");
        expression = new SetExpression(); 
        return "Set{}"; 
      }

      if (("Set".equals(clsname) || 
           clsname.startsWith("Set(")) && cargs.size() > 0)
      { ASTTerm.setType(this,"Set");
        ASTTerm strarg = (ASTTerm) cargs.get(0);
        if (strarg.isInteger())
        { expression = new SetExpression(); 
          return "Set{}"; 
        } 
        return "Set{}->union" + args1; 
      } 

      if (("Sequence".equals(clsname) ||
           clsname.startsWith("Sequence(")) && 
          cargs.size() == 0)
      { ASTTerm.setType(this,"Sequence");
        expression = new SetExpression(true); 
        return "Sequence{}"; 
      } 

      if (("SortedSequence".equals(clsname) ||
           clsname.startsWith("SortedSequence(")) && 
          cargs.size() == 0)
      { ASTTerm.setType(this,"Sequence");
        expression = new SetExpression(true);
        expression.setSorted(true);  
        return "SortedSequence{}"; 
      } 

      if (("Sequence".equals(clsname) ||
          	clsname.startsWith("Sequence(")) && 
          cargs.size() > 0)
      { ASTTerm.setType(this,"Sequence");
        ASTTerm strarg = (ASTTerm) cargs.get(0);
        if (strarg.isInteger())
        { expression = new SetExpression(true); 
          return "Sequence{}"; 
        } 
        else if (strarg.expression != null)
        { SetExpression emptySeq = 
                    new SetExpression(true); 
          expression = 
             new BinaryExpression("->union", 
                     emptySeq, strarg.expression); 
        } 

        return "Sequence{}->union" + args1; 
      } 

      if (("SortedSequence".equals(clsname) ||
          	clsname.startsWith("SortedSequence(")) && 
          cargs.size() > 0)
      { ASTTerm.setType(this,"Sequence");
        ASTTerm strarg = (ASTTerm) cargs.get(0);
        if (strarg.isInteger())
        { expression = new SetExpression(true); 
          expression.setSorted(true); 
          return "SortedSequence{}"; 
        } 
        else if (strarg.expression != null)
        { SetExpression emptySortedSeq = 
                    new SetExpression(true); 
          emptySortedSeq.setSorted(true); 
          expression = 
             new BinaryExpression("->union", 
                     emptySortedSeq, strarg.expression); 
        } 
         
        return "SortedSequence{}->union" + args1; 
      } 

      if ("Vector".equals(cls.literalForm()) && 
          cargs.size() == 0)
      { ASTTerm.setType(this,"Sequence");
        expression = new SetExpression(true); 
        return "Sequence{}"; 
      } 

      if ("Vector".equals(cls.literalForm()) && cargs.size() > 0)
      { ASTTerm.setType(this,"Sequence");
        ASTTerm strarg = (ASTTerm) cargs.get(0);

        if (strarg.isInteger())
        { expression = new SetExpression(true); 
          return "Sequence{}"; 
        } 
        else if (strarg.expression != null)
        { SetExpression emptySeq = 
                    new SetExpression(true); 
          expression = 
             new BinaryExpression("->union", 
                     emptySeq, strarg.expression); 
        } 

        return "Sequence{}->union" + args1; 
      } 


      if (clsliteral.startsWith("Pair") &&
          ("Map".equals(clsname) || 
           clsname.startsWith("Map(")) && cargs.size() == 2)
      { ASTTerm.setType(this,"Map");
        SetExpression emptyMapx = new SetExpression(); 
        emptyMapx.setType(new Type("Map", null));

        ASTTerm strarg1 = (ASTTerm) cargs.get(0);
        ASTTerm strarg2 = (ASTTerm) cargs.get(1);

        Expression expr1 = strarg1.expression; 
        Expression expr2 = strarg2.expression; 

        Expression pair1 = 
          new BinaryExpression("|->", 
                new BasicExpression("\"first\""), 
                expr1); 

        Expression pair2 = 
          new BinaryExpression("|->", 
                new BasicExpression("\"second\""), 
                expr2); 
        emptyMapx.addElement(pair1); 
        emptyMapx.addElement(pair2); 
        expression = emptyMapx;  
 
        return "Map{ \"first\" |-> " + expr1 + 
                     ", \"second\" |-> " + expr2 + "}"; 
      } 

      if (clsliteral.startsWith("Triple") &&
          ("Map".equals(clsname) || 
           clsname.startsWith("Map(")) && cargs.size() == 3)
      { ASTTerm.setType(this,"Map");
        SetExpression emptyMapx = new SetExpression(); 
        emptyMapx.setType(new Type("Map", null));

        ASTTerm strarg1 = (ASTTerm) cargs.get(0);
        ASTTerm strarg2 = (ASTTerm) cargs.get(1);
        ASTTerm strarg3 = (ASTTerm) cargs.get(2);

        Expression expr1 = strarg1.expression; 
        Expression expr2 = strarg2.expression; 
        Expression expr3 = strarg3.expression; 

        Expression pair1 = 
          new BinaryExpression("|->", 
                new BasicExpression("\"first\""), 
                expr1); 

        Expression pair2 = 
          new BinaryExpression("|->", 
                new BasicExpression("\"second\""), 
                expr2); 

        Expression pair3 = 
          new BinaryExpression("|->", 
                new BasicExpression("\"third\""), 
                expr3); 

        emptyMapx.addElement(pair1); 
        emptyMapx.addElement(pair2); 
        emptyMapx.addElement(pair3); 

        expression = emptyMapx;  
 
        return "Map{ \"first\" |-> " + expr1 + "," +  
                     "\"second\" |-> " + expr2 + "," + 
                     "\"third\" |-> " + expr3 + "}"; 
      } 


      if (("Map".equals(clsname) || 
           clsname.startsWith("Map(")) && "()".equals(args1))
      { ASTTerm.setType(this,"Map");
        expression = new SetExpression(); 
        expression.setType(new Type("Map", null)); 

        return "Map{}"; 
      } 

      if (("Map".equals(clsname) || 
           clsname.startsWith("Map(")) && cargs.size() > 0)
      { ASTTerm.setType(this,"Map");
        ASTTerm strarg = (ASTTerm) cargs.get(0);

        if (strarg.isInteger())
        { expression = new SetExpression(); 
          expression.setType(new Type("Map", null)); 
          return "Map{}"; 
        }

        if (strarg.expression != null) 
        { SetExpression emptyMap = new SetExpression(); 
          emptyMap.setType(new Type("Map", null));
          expression = new BinaryExpression("->union", emptyMap, strarg.expression); 
        } 
 
        return "Map{}->union" + args1; 
      } 

      if ("Object".equals(cls.literalForm()) && "()".equals(args.literalForm()))
      { ASTTerm.setType(this,"OclAny");
        expression = new BasicExpression("\"\""); 
        expression.setType(new Type("OclAny", null)); 

        return "\"\""; 
      } // or an empty map, for consistency with JavaScript

      if (clsname.endsWith("Exception") && cargs.size() > 0)
      { ASTTerm strarg = (ASTTerm) cargs.get(0);
        ASTTerm.setType(this,"OclException");
        if (strarg.isString()) { }
        else 
        { 
          if (strarg.expression != null) 
          { Expression emptyString = 
              BasicExpression.newValueBasicExpression("\"\""); 
            Expression toStr = 
              new BinaryExpression("+", emptyString, 
                                   strarg.expression); 
            expression = BasicExpression.newStaticCallBasicExpression(
              "new" + clsname, clsname, toStr);
          }  

          return clsname + ".new" + clsname + "(\"\" + " + strarg.toKM3() + ")"; 
        } 

        if (strarg.expression != null) 
        { expression = BasicExpression.newStaticCallBasicExpression(
             "new" + clsname, clsname, strarg.expression);
          statement = 
            InvocationStatement.newInvocationStatement(
                         expression, strarg.expression); 
        }  

        return clsname + ".new" + clsname + args1; 
      } 

      Vector creatorArguments = new Vector(); 
      if (args instanceof ASTCompositeTerm)
      { creatorArguments = 
         ((ASTCompositeTerm) args).getCreatorArgumentExpressions(); 
        System.out.println("::>> Creator arguments: " + creatorArguments); 
      } 

      if (args.expressions != null) 
      { expression = BasicExpression.newStaticCallBasicExpression("new" + cident, clsname, args.expressions); 
        statement = 
          InvocationStatement.newInvocationStatement(
                         expression, args.expressions); 
      } 
      else
      { expression = BasicExpression.newStaticCallBasicExpression(
             "new" + cident, clsname, creatorArguments);
        statement = 
          InvocationStatement.newInvocationStatement(
             expression, args.expressions);
      } 

      return clsname + ".new" + cident + args1; 
    } 

    if ("createdName".equals(tag))
    { ASTTerm mainclass = (ASTTerm) terms.get(0);
      if (terms.size() == 3 && 
          ".".equals(terms.get(1) + ""))
      { mainclass = (ASTTerm) terms.get(2); }
      else if (terms.size() > 3 && 
          ".".equals(terms.get(1) + ""))
      { mainclass = (ASTTerm) terms.get(terms.size()-1);
        if (mainclass.hasTag("typeArgumentsOrDiamond"))
        { mainclass = (ASTTerm) terms.get(terms.size()-2); }
      } 

      String res = mainclass.toKM3type();
      ASTTerm.setType(this,res);

      System.out.println(">>> Type of " + mainclass + " is " + res); 

      // if ("SortedSequence".equals(res))
      // { res = "Sequence"; } 

      Type typ; 
      Entity ent = 
        (Entity) ModelElement.lookupByName(
                          res, ASTTerm.entities); 
      if (ent != null) 
      { typ = new Type(ent); } 
      else if (ModelElement.lookupByName(res,ASTTerm.enumtypes) != null) 
      { typ = 
          (Type) ModelElement.lookupByName(res,ASTTerm.enumtypes); 
      } 
      else if ("SortedSequence".equals(res))
      { typ = new Type("Sequence", null); 
        typ.setSorted(true); 
      } 
      else 
      { ent = new Entity(res); 
        typ = new Type(ent); 
      } 

      modelElement = typ; 
      expression = new BasicExpression(res);
  
      if (terms.size() > 1 && 
          ((ASTTerm) terms.get(terms.size()-1)).hasTag(
                                 "typeArgumentsOrDiamond")) 
      { // type arguments -- 
        // it must be a collection, function, 
        // map or  entity type

        if (typ.isSequenceType() || typ.isSetType())
        { ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 
          String elemT = t2.typeArgumentsToKM3ElementType(); 
        
        
          Type et = 
            Type.getTypeFor(elemT,
               ASTTerm.enumtypes, ASTTerm.entities); 


          if (et != null) 
          { typ.setElementType(et); 
            res = res + "(" + elemT + ")"; 
          } 

          // JOptionPane.showInputDialog(">>> Object creation collection element type = " + elemT + " " + et + " " + res); 
        } 
        else if (typ.isMapType() || typ.isFunctionType())
        { ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 

          String allpars = t2.toKM3(); 

          System.out.println(">>> Object creation map/function type parameters = " + allpars); 

          if (t2.modelElements != null) 
          { typ.setTypeParameters(t2.modelElements); } 

          res = res + "(" + allpars + ")"; 
        }
        else 
        { 
          if (ent == null && Entity.validEntityName(res)) 
          { ent = new Entity(res); } 

          modelElement = ent; 

          ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 
        
          String allpars = t2.toKM3(); 

          System.out.println(">>> Object creation generic class parameter types = " + allpars); 

          if (t2.modelElements != null) 
          { ent.setTypeParameters(t2.modelElements); } 

          res = res + "<" + allpars + ">"; 
        } 
      } 

      return res; 
    } // Ignores type parameters in creation. 

    if ("classCreatorRest".equals(tag))
    { // (arguments ( )) or 
      // (arguments ( (expressionList ...) )) or 
      // (arguments ...) (classBody ...)

      if (terms.size() > 0) 
      { ASTTerm t = (ASTTerm) terms.get(0); 
        String ss = t.toKM3(); 
        expression = t.expression;
        expressions = t.expressions;  
        return ss; 
      } 
    } 

    return ""; 
  }

  public Type toKM3CollectionType(Type innerType)
  { if ("variableDeclaratorId".equals(tag))
    { int n = terms.size(); 

      if (n == 1)
      { return null; } 

      Type res = innerType; 
      
      for (int i = n-1; i > 0; i--) 
      { String tm = ((ASTTerm) terms.get(i)).literalForm(); 
        if ("]".equals(tm))
        { Type seqtype = new Type("Sequence", null);
          seqtype.setElementType(res); 
          res = seqtype; 
        } 
      } 

      return res;  
    }

    if ("variableDeclarator".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.toKM3CollectionType(innerType); 
    } 
 
    return null; 
  } 

 public Vector lambdaExpressionPars()
 { if ("expression".equals(tag) && terms.size() == 1)
   { ASTCompositeTerm epars = (ASTCompositeTerm) terms.get(0); 
     return epars.lambdaExpressionPars();
   } 

   if ("expressionList".equals(tag) && terms.size() == 1)
   { ASTCompositeTerm epars = (ASTCompositeTerm) terms.get(0); 
     return epars.lambdaExpressionPars();
   }

   if ("lambdaExpression".equals(tag) && terms.size() > 1)
   { // (lambdaExpression (lambdaParameters ( pars )) -> 
      //    (lambdaBody (block { stats }))
      // Assume 1 variable. 

     ASTTerm pars = (ASTTerm) terms.get(0); 
     String parString = pars.lambdaParametersToKM3();

     // JOptionPane.showInputDialog(pars + " " + pars.modelElements); 

     return pars.modelElements; 
   } 
   return new Vector(); 
 }  

  public String lambdaParametersToKM3()
  { modelElements = new Vector(); 

    System.out.println(">>> lambdaParametersToKM3 with tag " + tag + " and terms "); 
    for (int x = 0; x < terms.size(); x++) 
    { System.out.println(">>-- " + terms.get(x)); }


    if ("lambdaParameters".equals(tag))
    { if (terms.size() > 0 && "(".equals(terms.get(0) + ""))
      { String res = "("; 
        for (int i = 1; i < terms.size()-1; i++) 
        { ASTTerm trm = (ASTTerm) terms.get(i); 
          res = res + trm.lambdaParametersToKM3();
           
          if (trm.modelElement != null) 
          { modelElement = trm.modelElement; 
            modelElements.addAll(trm.modelElements);
          } 
        } 
        return res + ")"; 
      }
      else 
      { String res = ""; 
        for (int i = 0; i < terms.size(); i++) 
        { ASTTerm trm = (ASTTerm) terms.get(i); 
          res = res + trm.lambdaParametersToKM3(); 
          if (trm.modelElement != null) 
          { modelElement = trm.modelElement; 
            modelElements.addAll(trm.modelElements);
          }
        } 
        return res;  
      }
    }
    else if ("formalParameterList".equals(tag))
    { String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        res = res + trm.lambdaParametersToKM3(); 
        if (trm.modelElement != null) 
        { modelElement = trm.modelElement; 
          modelElements.add(trm.modelElement);
        } 
      }
      return res; 
    } 
    else if ("formalParameter".equals(tag))
    { ASTTerm var = (ASTTerm) terms.get(terms.size()-1); 
      ASTTerm typ = (ASTTerm) terms.get(terms.size()-2);

      String vname = var.toKM3(); 
      String tname = typ.toKM3type(); 

      Type tf = (Type) typ.modelElement; 
      Type vtyp = var.toKM3CollectionType(tf); 

      if (vtyp != null)
      { // vtyp.setElementType(tf); 
        tf = vtyp; 
      } 
 
      modelElement =
        new Attribute(vname,tf,ModelElement.INTERNAL);
      modelElements.add(modelElement);  
      return vname + " : " + tf;       
    }
    else // the tag is a spurious term
    { modelElement =
        new Attribute(tag,
                      new Type("OclAny", null),
                      ModelElement.INTERNAL);
      modelElements.add(modelElement); 
      String res = tag; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        res = res + trm.lambdaParametersToKM3(); 
        if (trm.modelElement != null) 
        { modelElement = trm.modelElement; 
          modelElements.add(trm.modelElement);
        } 
      }
      return res; 
    } 
  }  
     
  public String typeArgumentsToKM3ElementType()
  { if (tag.equals("typeArgumentsOrDiamond") && terms.size() == 1)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      String res = tt.typeArgumentsToKM3ElementType();
      modelElement = tt.modelElement;
      modelElements = new Vector(); 
      if (tt.modelElements != null) { modelElements.addAll(tt.modelElements); }  
      return res;   
    } 
    else if (tag.equals("typeArgumentsOrDiamond") && 
             terms.size() == 2 && 
             "<".equals(terms.get(0) + "") && 
             ">".equals(terms.get(1) + ""))
    { String res = "OclAny";
      modelElement = new Type("OclAny", null);
      modelElements = new Vector(); 
      modelElements.add(modelElement); 
      return res;   
    } 
 
    if ("typeArguments".equals(tag) && terms.size() > 1)
    { // < arg >   or   < arg1 , arg2 >
      ASTTerm typepar0 = (ASTTerm) terms.get(1); 
      String res = typepar0.toKM3();
      modelElement = typepar0.modelElement; 
 
      if (terms.size() > 3)
      { ASTTerm typepar1 = (ASTTerm) terms.get(3); 
        modelElement = typepar1.modelElement; 
        res = typepar1.toKM3(); 
      } 
      return res; 
    } 

    if ("nonWildcardTypeArguments".equals(tag) && 
        terms.size() > 2)
    { // < typelist >
      ASTTerm typepar0 = (ASTTerm) terms.get(1); 
      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
      modelElements = typepar0.modelElements; 
 
      return res; 
    } 

    if ("typeArgument".equals(tag) && terms.size() > 0)
    { // type, or 
      // annotation* ? ((super|extends) type)? 

      ASTTerm typepar0 = (ASTTerm) terms.get(0);

      if (typepar0.hasTag("annotation"))
      { Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        ASTCompositeTerm tailast = 
          new ASTCompositeTerm("typeArgument", tailterms); 
        String resx = tailast.toKM3type(); 
        modelElement = tailast.modelElement; 
        return resx; 
      } 

      if (terms.size() == 3 && 
          "?".equals(typepar0.literalForm()) && 
          ("extends".equals(terms.get(1) + "") || 
           "super".equals(terms.get(1) + "")))
      { typepar0 = (ASTTerm) terms.get(2); } 
 
      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
 
      return res; 
    } 
	
	return ""; 
  }


  public String assertFeatureAccessToKM3(ASTTerm arg, 
                    String args, ASTTerm call, 
                    String called, Vector callterms, 
                    Vector cargs)
  {  String thisliteral = this.literalForm(); 
     String argliteral = arg.literalForm(); 

     if (("assertEquals".equals(called) || 
          "assertArrayEquals".equals(called)) && 
          "Assert".equals(argliteral) && 
          cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          expression = 
              new BinaryExpression("=", expr1, expr2); 

          res = "  assert (" + par1string + " = " + par2string + ")";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if (("assertEquals".equals(called) || 
                  "assertArrayEquals".equals(called)) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 3)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          ASTTerm pars3 = (ASTTerm) cargs.get(2); 
          String par3string = pars3.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          Expression expr3 = pars3.expression; 
          expression = 
              new BinaryExpression("=", expr2, expr3); 

          res = "  assert (" + par2string + " = " + par3string + ") do " + par1string;
          statement = new AssertStatement(expression, expr1); 
          return res; 
        } 
        else if ("assertSame".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          expression = 
              new BinaryExpression("<>=", expr1, expr2); 

          res = "  assert (" + par1string + " <>= " + par2string + ")";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertSame".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 3)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          ASTTerm pars3 = (ASTTerm) cargs.get(2); 
          String par3string = pars3.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          Expression expr3 = pars3.expression; 
          expression = 
              new BinaryExpression("<>=", expr2, expr3); 

          res = "  assert (" + par2string + " <>= " + par3string + ") do " + par1string;
          statement = new AssertStatement(expression, expr1); 
          return res; 
        } 
        else if ("assertNotEquals".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          expression = 
              new BinaryExpression("/=", expr1, expr2); 

          res = "  assert (" + par1string + " /= " + par2string + ")";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertNotEquals".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 3)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          ASTTerm pars3 = (ASTTerm) cargs.get(2); 
          String par3string = pars3.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          Expression expr3 = pars3.expression; 
          expression = 
              new BinaryExpression("/=", expr2, expr3); 

          res = "  assert (" + par2string + " /= " + par3string + ") do " + par1string;
          statement = new AssertStatement(expression, expr1); 
          return res; 
        } 
        else if ("assertNotSame".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          expression = 
              new UnaryExpression("not", 
                new BinaryExpression("<>=", expr1, expr2)); 

          res = "  assert not(" + par1string + " <>= " + par2string + ")";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertNotSame".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 3)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          ASTTerm pars3 = (ASTTerm) cargs.get(2); 
          String par3string = pars3.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 
          Expression expr3 = pars3.expression; 
          expression = new UnaryExpression("not", 
              new BinaryExpression("<>=", expr2, expr3)); 

          res = "  assert not(" + par2string + " <>= " + par3string + ") do " + par1string;
          statement = new AssertStatement(expression, expr1); 
          return res; 
        } 
        else if ("assertNotNull".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 1)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = nullExpression; 
          expression = 
              new BinaryExpression("/=", expr1, expr2); 

          res = "  assert (" + par1string + " /= null)";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertNotNull".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression;
          Expression expr3 = nullExpression; 
          expression = 
              new BinaryExpression("/=", expr2, expr3); 

          res = "  assert (" + par2string + " /= null) do " + par1string;
          statement = new AssertStatement(expression, expr1); 
          return res; 
        } 
        else if ("assertTrue".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 1)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          String res = ""; 

          expression = pars1.expression;
          
          res = "  assert (" + par1string + ")";
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertTrue".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          expression = pars2.expression;
          Expression message = pars1.expression; 

          res = "  assert (" + par2string + ") do " + par1string;
          statement = new AssertStatement(expression,message); 
          return res; 
        } 
        else if ("assertFalse".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 1)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          String res = ""; 

          expression = new UnaryExpression("not", pars1.expression);
          
          res = "  assert " + par1string;
          statement = new AssertStatement(expression); 
          return res; 
        } 
        else if ("assertFalse".equals(called) && 
                 "Assert".equals(argliteral) && 
                 cargs.size() == 2)
        { ASTTerm pars1 = (ASTTerm) cargs.get(0); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 

          expression = new UnaryExpression("not", 
                              pars2.expression);
          Expression message = pars1.expression; 

          res = "  assert (" + par2string + ") do " + par1string;
          statement = new AssertStatement(expression,message); 
          return res; 
        } 
      else if ("assertThat".equals(called))
      { int sze = cargs.size(); 

          ASTTerm pars1 = (ASTTerm) cargs.get(sze-2); 
          String par1string = pars1.toKM3(); 
          ASTTerm pars2 = (ASTTerm) cargs.get(sze-1); 
          String par2string = pars2.toKM3(); 
          String res = ""; 
            
          Expression expr1 = pars1.expression;
          Expression expr2 = pars2.expression; 

        if (expr1 != null && expr2 != null) 
        { String matcherOperator = 
              Expression.getMatcherOperator(expr2); 
          Expression expr2arg = 
              Expression.getMatcherArgument(expr2); 
          expression = new BinaryExpression(
                           matcherOperator, expr1, expr2arg); 
            
          res = "  assert (" + expression + ")";
          statement = new AssertStatement(expression); 
        }  
        return res; 
      } 

    args = arg.queryForm(); 
    String calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls;  
  } 


  public String toKM3arraylist(Vector cargs)
  { if (cargs.size() == 1) 
    { ASTTerm pars1 = (ASTTerm) cargs.get(0);
      String res = pars1.toKM3(); 
      expression = pars1.expression; 
      return res; 
    } 
    else if (cargs.size() == 0) // not possible
    { expression = new SetExpression(true); 
      return "Sequence{}"; 
    } 

    String res = "Sequence{"; 
    Vector elems = new Vector(); 
    for (int i = 0; i < cargs.size(); i++) 
    { ASTTerm pars1 = (ASTTerm) cargs.get(i);
      res = res + pars1.toKM3(); 
      if (i < cargs.size()-1)
      { res = res + ","; } 
      if (pars1.expression != null) 
      { elems.add(pars1.expression); } 
    } 

    expression = new SetExpression(elems,true); 
    return res + "}"; 
  } 


  public String fileFeatureAccessToKM3(ASTTerm arg, 
                    String args, ASTTerm call, 
                    String called, Vector callterms, 
                    Vector cargs)
  {  String thisliteral = this.literalForm(); 

     // JOptionPane.showInputDialog("fileFeatureAccessToKM3 " + args + called + cargs); 

     if ("next".equals(called) && arg.isFile())
     { ASTTerm.setType(thisliteral,"String");
            
       if (arg.expression != null) 
       { expression = 
              BasicExpression.newCallBasicExpression(
                         "getCurrent", arg.expression);  
        } 
        return args + ".getCurrent()"; 
     } 
     else if ("position".equals(called) && cargs.size() == 0)
     { ASTTerm.setType(thisliteral,"long");
            
       if (arg.expression != null) 
       { expression = 
              BasicExpression.newCallBasicExpression(
                         "getPosition", arg.expression);  
        } 
        return args + ".getPosition()"; 
     } 
     else if ("position".equals(called) && cargs.size() == 1)
     { ASTTerm.setType(thisliteral,"OclFile");
       
       ASTTerm callarg1 = (ASTTerm) cargs.get(0);
       String callp1 = callarg1.toKM3(); 
            
       if (arg.expression != null && 
           callarg1.expression != null) 
       { Expression expr = 
              BasicExpression.newCallBasicExpression(
                         "setPosition", 
                         arg.expression, 
                         callarg1.expression);  
          statement = 
            InvocationStatement.newInvocationStatement(
                    expr, callarg1.expression);
          expression = arg.expression;  
        } 
        return args + ".setPosition(" + callp1 + ")"; 
     } 
     else if ("getBytes".equals(called) && arg.isFile())
     { ASTTerm.setType(thisliteral,"Sequence(int)");

       if (arg.expression != null) 
       { Expression chvar = 
              BasicExpression.newVariableBasicExpression(
                     "_ch", 
                     new Type("String",null)); 
         Expression ue = 
              new UnaryExpression("->characters", 
                                  arg.expression); 
         UnaryExpression s2b = 
              new UnaryExpression("->char2byte", chvar); 
         BinaryExpression inarg = 
              new BinaryExpression(":", chvar, ue); 
         expression = 
            new BinaryExpression("|C", inarg, s2b); 
       } 
 
       return args + "->characters()->collect( _ch | _ch->char2byte() )"; 
     }
        else if ("getChars".equals(called) && arg.isFile())
        { ASTTerm callarg1 = (ASTTerm) cargs.get(0);
          String callp1 = callarg1.toKM3(); 
            
          ASTTerm.setType(thisliteral,"Sequence(String)"); 

          if (cargs.size() > 3) 
          { ASTTerm callarg2 = (ASTTerm) cargs.get(1);
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2);
            String callp3 = callarg3.toKM3(); 
            ASTTerm callarg4 = (ASTTerm) cargs.get(3);
            String callp4 = callarg4.toKM3(); 

            return callp3 + " := (" + callp3 + ".subrange(1," + callp4 + "))^(" + args + ".subrange(" + callp1 + "+1, " + callp2 + ")->characters())";
          } 
        }
        else if ("ready".equals(called) && arg.isFile())
        { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                  "canRead", arg.expression);
          }  

          return args + ".canRead()"; 
        }
        else if ("renameTo".equals(called) && arg.isFile())
        { String oldfilename = arg.toKM3() + ".getName()"; 
          ASTTerm newfile = (ASTTerm) cargs.get(1);
          String newfilename = newfile.toKM3() + ".getName()"; 
          ASTTerm.setType(thisliteral,"boolean"); 

          if (arg.expression != null && 
              newfile.expression != null) 
          { Vector pars = new Vector(); 
            BasicExpression call1 = 
              BasicExpression.newCallBasicExpression(
                                  "getName", arg.expression);
            BasicExpression call2 = 
              BasicExpression.newCallBasicExpression(
                                  "getName", 
                                  newfile.expression);

            pars.add(call1); 
            pars.add(call2); 
            expression =
              BasicExpression.newStaticCallBasicExpression(
                  "renameFile", "OclFile", pars);
          }  

          return "OclFile.renameFile(" + oldfilename + "," +
                                         newfilename + ")"; 
     }
     else if ("close".equals(called) && arg.isFile())
     { ASTTerm callarg = (ASTTerm) callterms.get(2); 
          String callp = callarg.toKM3(); 

          if (arg.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                                "closeFile", arg.expression);
            statement = 
              InvocationStatement.newInvocationStatement(
                                      expression, new Vector()); 
          }  

          return args + ".closeFile()"; 
        }
        else if ("getFilePointer".equals(called) && 
                 arg.isFile())
        { if (arg.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                        "getPosition", arg.expression);
          }  

          return args + ".getPosition()"; 
        } 
        else if ("seek".equals(called) && 
                 arg.isFile())
        { ASTTerm pos = (ASTTerm) cargs.get(0);
          String posn = pos.toKM3(); 

          if (arg.expression != null && 
              pos.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                        "setPosition", arg.expression, 
                        pos.expression);
          }  

          return args + ".setPosition(" + posn + ")"; 
        } 
        else if ("read".equals(called) && arg.isFile())
        { if (cargs.size() == 0)
          { if (arg.expression != null) 
            { expression =
                BasicExpression.newCallBasicExpression(
                                  "read", arg.expression);
            }  

            return args + ".read()"; 
          } 
          else if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();

            // if (callarg1.isStringSequence())
            // read available characters into callarg1

            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression =
                BasicExpression.newCallBasicExpression(
                              "readAll", arg.expression);
              statement = 
                new AssignStatement(callarg1.expression, 
                                    expression); 
            }  // returns number of characters read. 
 
            return callp1 + " := " + args + ".readAll()";
          }  
          else if (cargs.size() == 3)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String offset = callarg2.toKM3();
            ASTTerm callarg3 = (ASTTerm) cargs.get(2); 
            String n = callarg3.toKM3();

            // if (callarg1.isStringSequence())
            // read n characters into callarg1
            // starting at offset. 

            if (arg.expression != null && 
                callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null) 
            { Expression readN = 
                BasicExpression.newCallBasicExpression(
                              "readN", arg.expression, 
                              callarg3.expression);                   
              Vector pars = new Vector(); 
              
              Expression startFrom = 
                new BinaryExpression("+", callarg2.expression,
                                     unitExpression);
              pars.add(startFrom); 
              pars.add(readN);  
              expression =
                BasicExpression.newFunctionBasicExpression(
                        "insertInto", 
                        callarg1.expression, pars); 
                
              statement = 
                new AssignStatement(callarg1.expression, 
                                    expression); 
            }  
 
            return callp1 + " := " + callp1 + ".insertInto(" + offset + "+1, " + args + ".readN(" + n + "))";
          }  
        } // TODO: othercases
        else if ("readBoolean".equals(called) && arg.isFile())
        { if (arg.expression != null) 
          { Expression expr =
              BasicExpression.newCallBasicExpression(
                                 "readByte", arg.expression);
            Expression eqzero = 
              new BinaryExpression("=", expr, zeroExpression); 
            expression = 
              new ConditionalExpression(eqzero, 
                     falseExpression, trueExpression); 
          }  
          ASTTerm.setType(this,"boolean"); 

          return "if " + args + ".readByte() = 0 then false else true endif"; 
        } 
        else if ("readChar".equals(called) && 
                 arg.isFile())
        { if (arg.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                        "read", arg.expression);
          }  
          ASTTerm.setType(this,"String"); 
          
          return args + ".read()"; 
        } 
        else if (("readByte".equals(called) || 
                  "readUnsignedByte".equals(called)) && 
                 arg.isFile())
        { if (arg.expression != null) 
          { expression =
              BasicExpression.newCallBasicExpression(
                                 "readByte", arg.expression);
          }  
          ASTTerm.setType(this,"int"); 
          
          return args + ".readByte()"; 
        } 
        else if (("readShort".equals(called) || 
                  "readUnsignedShort".equals(called)) && 
                 arg.isFile())
        { Expression two = new BasicExpression(2); 
          if (arg.expression != null) 
          { Expression callexpression =
              BasicExpression.newCallBasicExpression(
                "readNbytes", arg.expression, two);
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "bytes2integer", "MathLib", callexpression); 
          }  
          ASTTerm.setType(this,"int"); 
          
          return "MathLib.bytes2integer(" + 
                              args + ".readNbytes(2))"; 
        } 
        else if ("readInt".equals(called) && 
                 arg.isFile())
        { Expression four = new BasicExpression(4); 
          if (arg.expression != null) 
          { Expression callexpression =
              BasicExpression.newCallBasicExpression(
                "readNbytes", arg.expression, four);
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "bytes2integer", "MathLib", callexpression); 
          }  
          ASTTerm.setType(this,"int"); 
          
          return "MathLib.bytes2integer(" + 
                              args + ".readNbytes(4))"; 
        }         
        else if ("readLong".equals(called) && 
                 arg.isFile())
        { Expression eight = new BasicExpression(8); 
          if (arg.expression != null) 
          { Expression callexpression =
              BasicExpression.newCallBasicExpression(
                "readNbytes", arg.expression, eight);
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                "bytes2integer", "MathLib", callexpression); 
          }  
          ASTTerm.setType(this,"int"); 
          
          return "MathLib.bytes2integer(" + args + 
                                        ".readNbytes(8))"; 
        } // TODO: othercases. Float is 4 bytes, Double 8
        else if ("getInputStream".equals(called) && 
                 arg.isFile())
        { ASTTerm.setType(this,"OclFile"); 
          if (arg.expression != null) 
          { expression =  
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Read", "OclFile", arg.expression);  
          } 
          return "OclFile.newOclFile_Read(" + args + ")"; 
        } 
        else if ("getOutputStream".equals(called) && 
                 arg.isFile())
        { ASTTerm.setType(this,"OclFile"); 
          if (arg.expression != null) 
          { expression =  
              BasicExpression.newStaticCallBasicExpression(
                "newOclFile_Write", "OclFile", arg.expression);  
          } 
          return "OclFile.newOclFile_Write(" + args + ")"; 
        } 
        else if ("next".equals(called) && arg.isFile())
        { if (cargs.size() == 0)
          { if (arg.expression != null) 
            { expression =
                BasicExpression.newCallBasicExpression(
                            "getCurrent", arg.expression);
            }  

            return args + ".getCurrent()"; 
          } 
        } 
        else if ("nextInt".equals(called) && arg.isFile())
        { // JOptionPane.showInputDialog("NextInt"); 
          ASTTerm.setType(this, "int");
 
          if (cargs.size() == 0)
          { if (arg.expression != null) 
            { BasicExpression rexp =
                BasicExpression.newCallBasicExpression(
                  "getCurrent", arg.expression);
              expression = new UnaryExpression(
                                 "->toInteger", rexp); 
            }  

            return args + ".getCurrent()->toInteger()"; 
          } 
        } 
        else if ("nextLong".equals(called) && arg.isFile())
        { // JOptionPane.showInputDialog("NextInt"); 
          ASTTerm.setType(this, "long");

          if (cargs.size() == 0)
          { if (arg.expression != null) 
            { BasicExpression rexp =
                BasicExpression.newCallBasicExpression(
                  "getCurrent", arg.expression);
              expression = new UnaryExpression(
                                 "->toLong", rexp); 
            }  

            return args + ".getCurrent()->toLong()"; 
          } 
        } 
        else if ("nextDouble".equals(called) && arg.isFile())
        { ASTTerm.setType(this, "double");

          if (cargs.size() == 0)
          { if (arg.expression != null) 
            { BasicExpression rexp =
                BasicExpression.newCallBasicExpression(
                            "getCurrent", arg.expression);
              expression = 
                new UnaryExpression("->toReal", rexp); 
            }  

            return args + ".getCurrent()->toReal()"; 
          } 
        } 
        else if ("nextBoolean".equals(called) && arg.isFile())
        { ASTTerm.setType(this, "boolean");

          if (cargs.size() == 0)
          { if (arg.expression != null) 
            { BasicExpression rexp =
                BasicExpression.newCallBasicExpression(
                              "getCurrent", arg.expression);
              expression = 
                new UnaryExpression("->toBoolean", rexp); 
            }  

            return args + ".getCurrent()->toBoolean()"; 
          } 
        }
        else if ("getBuffer".equals(called) || 
                 "toString".equals(called))
        { expression = BasicExpression.newCallBasicExpression(
                              "readAll", arg.expression);
          ASTTerm.setType(this, "String"); 
          return args + ".readAll()"; 
        } // for StringWriter        
        else if ("size".equals(called))
        { expression = BasicExpression.newCallBasicExpression(
                              "length", arg.expression);
          ASTTerm.setType(this, "long"); 
          return args + ".length()"; 
        } // for StringWriter        
        else if ("write".equals(called) && arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();

            if (callarg1.isStringSequence())
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { Expression par = 
                  new UnaryExpression("->sum", 
                                      callarg1.expression); 
                expression = 
                  BasicExpression.newCallBasicExpression(
                    "write", arg.expression, par);
                statement = 
                  InvocationStatement.newInvocationStatement(
                    expression, par);  
              } 

              return args + ".write(" + callp1 + "->sum())"; 
            }
        
            if (callarg1.isIntegerSequence())
            { if (arg.expression != null && 
                  callarg1.expression != null) 
              { Expression zExpr =
                  BasicExpression.newVariableBasicExpression(
                    "_z");
                Expression inarg = 
                  new BinaryExpression(":", zExpr,
                                       callarg1.expression); 
                Expression b2char = 
                  new UnaryExpression("->byte2char", zExpr);  
                Expression col = 
                  new BinaryExpression("|C", inarg, b2char); 
                Expression par = 
                  new UnaryExpression("->sum", 
                                      col); 
                expression = 
                  BasicExpression.newCallBasicExpression(
                    "write", arg.expression, par);
                statement = 
                  InvocationStatement.newInvocationStatement(
                    expression, par);  
              } 

              return args + ".write(" + callp1 + "->collect( _z | _z->byte2char() )->sum())"; 
            }        


            if (arg.expression != null && 
                callarg1.expression != null) 
            { Expression par = 
                  new BinaryExpression("+", 
                        callarg1.expression, 
                        emptyStringExpression); 
              expression = 
                BasicExpression.newCallBasicExpression(
                    "write", arg.expression, par);
              statement = 
                InvocationStatement.newInvocationStatement(
                    expression, par);  
            } 

            return args + ".write(\"\"+" + callp1 + ")"; 
          } 
          else if (cargs.size() == 3) 
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3(); 
            ASTTerm callarg2 = (ASTTerm) cargs.get(1); 
            String callp2 = callarg2.toKM3(); 
            ASTTerm callarg3 = (ASTTerm) cargs.get(2); 
            String callp3 = callarg3.toKM3();

            Expression subrng = null; 
            if (callarg1.expression != null && 
                callarg2.expression != null && 
                callarg3.expression != null) 
            { Expression par1 = 
                new BinaryExpression("+", callarg2.expression,
                                     unitExpression); 
              Expression par2 = 
                new BinaryExpression("+", callarg2.expression,
                                     callarg3.expression);
              Vector pars = new Vector(); 
              pars.add(par1); 
              pars.add(par2);  
              subrng = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", callarg1.expression, pars); 
            } 
 
            if (callarg1.isStringSequence())
            { if (arg.expression != null && subrng != null)
              { Expression par = 
                  new UnaryExpression("->sum", subrng); 
                expression = 
                  BasicExpression.newCallBasicExpression(
                    "write", arg.expression, par);
                statement = 
                  InvocationStatement.newInvocationStatement(
                    expression, par);  
              } 

              return args + ".write(" + callp1 + ".subrange(" + callp2 + "+1," + callp2 + "+" + callp3 + ")->sum())"; 
            }        

            if (callarg1.isIntegerSequence())
            { if (arg.expression != null && subrng != null)
              { BasicExpression _z = 
                  BasicExpression.newVariableBasicExpression(
                                                       "_z");
                _z.setType(new Type("int", null)); 
 
                Expression colldom = 
                  new BinaryExpression(":", _z, subrng);
                Expression collarg = 
                  new UnaryExpression("->byte2char", _z);  
                Expression collsubrng = 
                  new BinaryExpression("|C", colldom, collarg); 
                Expression par = 
                  new UnaryExpression("->sum", collsubrng); 
                expression = 
                  BasicExpression.newCallBasicExpression(
                    "write", arg.expression, par);
                statement = 
                  InvocationStatement.newInvocationStatement(
                    expression, par);  
              } 
           
              return args + ".write(" + callp1 + ".subrange(" + callp2 + "+1," + callp2 + "+" + callp3 + ")->collect( _z | _z->byte2char() )->sum())"; 
            }

            if (arg.expression != null && subrng != null)
            { expression = 
                  BasicExpression.newCallBasicExpression(
                    "write", arg.expression, subrng);
              statement = 
                  InvocationStatement.newInvocationStatement(
                    expression, subrng);  
            } 
        
            return args + ".write(" + callp1 + ".subrange(" + callp2 + "+1," + callp2 + "+" + callp3 + "))";
          }  
        }
        else if ("writeBytes".equals(called) && arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (arg.expression != null && 
                callarg1.expression != null) 
            { expression = 
                BasicExpression.newCallBasicExpression(
                  "write", arg.expression, 
                           callarg1.expression);
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, callarg1.expression);  
            } 

            return args + ".write(" + callp1 + ")"; 
          } 
        } 
        else if (("writeChar".equals(called) || 
                  "writeShort".equals(called)) && 
                 arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (arg.expression != null && 
                callarg1.expression != null) 
            { Vector pars1 = new Vector();
              pars1.add(callarg1.expression); 
              pars1.add(new BasicExpression(2));  
              Expression int2byts = 
                BasicExpression.newStaticCallBasicExpression(
                  "integer2Nbytes", "MathLib", pars1);
              Vector pars2 = new Vector();
              pars2.add(int2byts); 
              pars2.add(new BasicExpression(2));  
              expression = 
                BasicExpression.newCallBasicExpression(
                  "writeNbytes", arg.expression, pars2);
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars2);  
            } 

            return args + ".writeNbytes(MathLib.integer2Nbytes(" + callp1 + ",2),2)"; 
          } 
        } 
        else if ("writeInt".equals(called) && arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (arg.expression != null && 
                callarg1.expression != null) 
            { Vector pars1 = new Vector();
              pars1.add(callarg1.expression); 
              pars1.add(new BasicExpression(4));  
              Expression int2byts = 
                BasicExpression.newStaticCallBasicExpression(
                  "integer2Nbytes", "MathLib", pars1);
              Vector pars2 = new Vector();
              pars2.add(int2byts); 
              pars2.add(new BasicExpression(4));  
              expression = 
                BasicExpression.newCallBasicExpression(
                  "writeNbytes", arg.expression, pars2);
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars2);  
            } 

            return args + ".writeNbytes(MathLib.integer2Nbytes(" + callp1 + ",4),4)"; 
          } 
        } 
        else if ("writeLong".equals(called) && arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (arg.expression != null && 
                callarg1.expression != null) 
            { Vector pars1 = new Vector();
              pars1.add(callarg1.expression); 
              pars1.add(new BasicExpression(8));  
              Expression int2byts = 
                BasicExpression.newStaticCallBasicExpression(
                  "integer2Nbytes", "MathLib", pars1);
              Vector pars2 = new Vector();
              pars2.add(int2byts); 
              pars2.add(new BasicExpression(8));  
              expression = 
                BasicExpression.newCallBasicExpression(
                  "writeNbytes", arg.expression, pars2);
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, pars2);  
            } 

            return args + ".writeNbytes(MathLib.integer2Nbytes(" + callp1 + ",8),8)"; 
          } 
        } 
        else if ("writeBoolean".equals(called) && arg.isFile())
        { if (cargs.size() == 1)
          { ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
            String callp1 = callarg1.toKM3();
            if (arg.expression != null && 
                callarg1.expression != null) 
            { Expression int2byts = 
                new ConditionalExpression(callarg1.expression,
                                          unitExpression,
                                          zeroExpression);
              expression = 
                BasicExpression.newCallBasicExpression(
                  "writeByte", arg.expression, int2byts);
              statement = 
                InvocationStatement.newInvocationStatement(
                  expression, int2byts);  
            } 

            return args + ".writeByte(if " + callp1 + " then 1 else 0 endif)"; 
          } 
        } // writeFloat, writeDouble
        else if ("newLine".equals(called) && arg.isFile())
        { if (arg.expression != null) 
          { Vector pars = new Vector(); 
            pars.add(new BasicExpression("\"\"")); 
            expression =
              BasicExpression.newCallBasicExpression("writeln", arg.expression, pars);
          }  

          return args + ".writeln(\"\")"; 
        }

    args = arg.queryForm(); 
    String calls = call.queryForm(); 

    if (arg.expression != null) 
    { expression = BasicExpression.newBasicExpression(arg.expression, calls); 
    } // no statement? 

    return args + "." + calls;  
  } 


  /* The main Java abstraction routine -- update form of expressions */ 

  public String toKM3()
  { if ("creator".equals(tag) || "innerCreator".equals(tag))
    { // 2 arguments, the type, and any constructor pars
      return creatorQueryForm(); 
    } 

    if ("createdName".equals(tag))
    { return creatorQueryForm(); } 
    // Ignores type parameters in creation. 

    if ("classCreatorRest".equals(tag))
    { return creatorQueryForm(); } 

    if ("arguments".equals(tag))
    { // (arguments ( )) or 
      // (arguments ( (expressionList ...) ))

      if (terms.size() > 2) 
      { ASTTerm t = (ASTTerm) terms.get(1); 
        String ss = t.toKM3(); 
        expression = t.expression; 
        if (t instanceof ASTCompositeTerm) 
        { expressions = 
            ((ASTCompositeTerm) t).getParameterExpressions();
        }  
        
        return ss; 
      } 

      expressions = new Vector(); 
      return "()"; 
    } 

    if ("variableDeclaratorId".equals(tag))
    { ASTTerm yt = (ASTTerm) terms.get(0);
      return yt.literalForm(); 
    } // ignore [] terms 
        

    if ("literal".equals(tag))
    { System.out.println(">> Literal with " + terms.size() + " terms " + terms);
      String res = ""; 
      for (int y = 0; y < terms.size(); y++)
      { ASTTerm yt = (ASTTerm) terms.get(y); 
        System.out.println(">>> Term " + y + ": " + yt);
        if (y < terms.size() - 1) 
        { res = res + yt.toKM3() + " "; } 
        else 
        { res = res + yt.toKM3(); }  
      }  
      System.out.println();

      if (terms.size() == 1) 
      { ASTTerm tt = (ASTTerm) terms.get(0);
        expression = tt.expression; 
        ASTTerm.setType(this, ASTTerm.getType(tt)); 
      } 
 
      return res; 
    } 

    if ("variableInitializer".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); // An expression

      System.out.println(">> Variable initializer with " + terms.size() + " terms"); 

      for (int y = 0; y < terms.size(); y++)
      { ASTTerm yt = (ASTTerm) terms.get(y); 
        System.out.println(">>> Term " + y + ": " + yt); 
      }  
      System.out.println(); 

      String initexpr = t.toKM3(); // updateForm
      ASTTerm.setType(this,ASTTerm.getType(t)); 
      expression = t.expression;  // queryForm
        
      if (t.updatesObject(null))
      { // System.out.println(">> Expression returning value, and with side-effect: " + t); 
        statement = t.statement;    // updateForm
        /* JOptionPane.showInputDialog(">> Update form of " + 
                                    this + " : >> " + statement); */  
        // System.out.println(); 
        String qf = t.queryForm(); 
        expression = t.expression; 
        // System.out.println(">> Query form: >> " + expression); 
        
        return qf + " ; " + initexpr; 
      }
      else if (t.hasSideEffect())
      { System.out.println(">> Expression returning value, and with side-effect: " + t); 
        t.postSideEffect(); 
        statement = t.statement;    // updateForm
        // System.out.println(statement); 
        // System.out.println(); 
        String qf = t.queryForm(); 
        expression = t.expression; 
        // System.out.println(">> Query form: >> " + expression); 
        
        return qf + " ; " + initexpr; 
      } 

      return initexpr; 
    }    

    if ("methodCall".equals(tag))
    { // methodname ( args ) 

      if (terms.size() == 4) 
      { // methodName ( pars ) 
        ASTTerm methodt = (ASTTerm) terms.get(0);
        String methodname = methodt.toKM3();
        ASTTerm callargs = (ASTTerm) terms.get(2);
        Vector cargs = getCallArguments(callargs); 

        String mqf = methodt.queryForm(); 
  
        if ("parseInt".equals(methodname) && cargs.size() > 0)
        { ASTTerm arg1 = (ASTTerm) cargs.get(0); 
          String res = arg1.queryForm(); 

          // JOptionPane.showInputDialog(">> Method call " + methodname + " " + arg1.expression);
      
          if (arg1.expression != null) 
          { arg1.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->toInteger", 
                                arg1.expression); 
            statement = null;   
            return "(" + res + ")->toInteger()"; 
          } 
        } 
        else if ("super".equals(methodname))
        { // call of superclass constructor 
          methodname = "super.initialise"; 
          BasicExpression supbe = new BasicExpression("super"); 
          supbe.setUmlKind(Expression.VARIABLE);
          BasicExpression initbe = new BasicExpression("initialise"); 
          initbe.setUmlKind(Expression.UPDATEOP);
          initbe.setIsEvent();  
          initbe.setObjectRef(supbe);
          initbe.setParameters(new Vector());  
          expression = initbe;  
          statement = new InvocationStatement(initbe); 
        }
        else if ("this".equals(methodt + ""))
        { // call of this constructor 
          methodname = "self.initialise"; 
          BasicExpression supbe = new BasicExpression("self"); 
          supbe.setUmlKind(Expression.VARIABLE);
          BasicExpression initbe =
            new BasicExpression("initialise"); 
          initbe.setUmlKind(Expression.UPDATEOP);
          initbe.setIsEvent();  
          initbe.setObjectRef(supbe);
          initbe.setParameters(new Vector());  
          expression = initbe;  
          statement = new InvocationStatement(initbe); 
        }
        else if ("println".equals(methodt + ""))
        { ASTTerm arg1 = (ASTTerm) terms.get(2); 
          String parxstring = arg1.toKM3(); 
          
          Statement sideEffect = arg1.statement; 

          String res = arg1.queryForm(); 

          if (arg1.expression != null) 
          { arg1.expression.setBrackets(true); 
            expression = 
                new UnaryExpression("->display", 
                                    arg1.expression); 
            Statement stat = 
                new ImplicitInvocationStatement(expression); 
            if (sideEffect == null) 
            { statement = stat; } 
            else 
            { statement = 
                  new SequenceStatement(sideEffect,stat); 
            }
          } 
            
          return "execute (" + res + ")->display()"; 
        } 
        else if ("assertEquals".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();

            int sze = parxexprs.size(); 

            Expression expr1 = (Expression) parxexprs.get(sze-2);
            Expression expr2 = (Expression) parxexprs.get(sze-1);
            expression = 
              new BinaryExpression("=", expr1, expr2); 

            if (parxexprs.size() == 3) 
            { Expression msg = (Expression) parxexprs.get(0); 
              res = "  assert (" + expr1 + " = " + expr2 + ") do " + msg;
              statement = new AssertStatement(expression,msg);
            } 
            else 
            { res = "  assert (" + expr1 + " = " + expr2 + ")";
              statement = new AssertStatement(expression);
            }  
          }  
          return res; 
        } 
        else if ("assertNull".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();

            int sze = parxexprs.size(); 

            Expression expr1 = (Expression) parxexprs.get(sze-1);
            expression = 
              new BinaryExpression("=", expr1, nullExpression); 

            if (parxexprs.size() == 2) 
            { Expression msg = (Expression) parxexprs.get(0); 
              res = "  assert (" + expr1 + " = null) do " + msg;
              statement = new AssertStatement(expression,msg);
            } 
            else 
            { res = "  assert (" + expr1 + " = null)";
              statement = new AssertStatement(expression);
            }  
          }  
          return res; 
        } 
        else if ("assertNotEquals".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();

            int sze = parxexprs.size(); 
            
            Expression expr1 = (Expression) parxexprs.get(sze-2);
            Expression expr2 = (Expression) parxexprs.get(sze-1);
            expression = 
              new BinaryExpression("/=", expr1, expr2); 

            if (parxexprs.size() == 3) 
            { Expression msg = (Expression) parxexprs.get(0); 
              res = "  assert (" + expr1 + " /= " + expr2 + ") do " + msg;
              statement = new AssertStatement(expression,msg);
            } 
            else 
            { res = "  assert (" + expr1 + " /= " + expr2 + ")";
              statement = new AssertStatement(expression);
            }  
          }  
          return res; 
        } 
        else if ("assertTrue".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();
            
            expression = (Expression) parxexprs.get(0);
            
            if (parxexprs.size() == 2) 
            { expression = (Expression) parxexprs.get(1);
              Expression msg = (Expression) parxexprs.get(0); 
              res = "  assert (" + expression + ") do " + msg;
              statement = new AssertStatement(expression,msg);
            } 
            else 
            { res = "  assert (" + expression + ")";
              statement = new AssertStatement(expression);
            }  
          }  
          return res; 
        } 
        else if ("assertFalse".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();
            
            expression = 
              new UnaryExpression("not", 
                      (Expression) parxexprs.get(0));

            if (parxexprs.size() == 2) 
            { expression = new UnaryExpression("not", 
                             (Expression) parxexprs.get(1));

              Expression msg = (Expression) parxexprs.get(0); 
              res = "  assert (" + expression + ") do " + msg;
              statement = new AssertStatement(expression,msg);
            } 
            else 
            { 
              res = "  assert (" + expression + ")";
              statement = new AssertStatement(expression);
            }  
          }  
          return res; 
        } 
        else if ("assertThat".equals(methodname))
        { ASTTerm parsx = (ASTTerm) terms.get(2); 
          String parxstring = parsx.toKM3(); 
          String res = ""; 

          Vector parxexprs = new Vector(); 
          if (parsx instanceof ASTCompositeTerm) 
          { parxexprs = 
              ((ASTCompositeTerm) parsx).getParameterExpressions();

            int sze = parxexprs.size(); 
            
            Expression expr1 = (Expression) parxexprs.get(sze-2);
            Expression expr2 = (Expression) parxexprs.get(sze-1);

            String matcherOperator = 
              Expression.getMatcherOperator(expr2); 
            Expression expr2arg = 
              Expression.getMatcherArgument(expr2); 
            expression = new BinaryExpression(
                           matcherOperator, expr1, expr2arg); 
            
            res = "  assert (" + expression + ")";
            statement = new AssertStatement(expression); 
          }  
          return res; 
        } 
        else 
        { expression = new BasicExpression(methodname); 
          ((BasicExpression) expression).setParameters(new Vector());  
          ((BasicExpression) expression).setIsEvent();  
          expression.setUmlKind(Expression.UPDATEOP);
          statement = new InvocationStatement((BasicExpression) expression); 
        } 

        ASTTerm pars = (ASTTerm) terms.get(2); 
        String parstring = pars.toKM3(); 
        Vector parexprs = new Vector(); 
        if (pars instanceof ASTCompositeTerm) 
        { parexprs = 
            ((ASTCompositeTerm) pars).getParameterExpressions();
        }  

        ((BasicExpression) expression).setParameters(parexprs);
        ((InvocationStatement) statement).setParameters(parexprs); 
        return mqf + parstring;  
      } 

      if (terms.size() == 3) 
      { // methodName ( ) 
        ASTTerm methodt = (ASTTerm) terms.get(0);
        String methodname = methodt.toKM3();  
        if ("super".equals(methodname))
        { // call of superclass constructor 
          methodname = "super.initialise"; 
          BasicExpression supbe = new BasicExpression("super"); 
          supbe.setUmlKind(Expression.VARIABLE);
          BasicExpression initbe = new BasicExpression("initialise"); 
          initbe.setUmlKind(Expression.UPDATEOP); 
          initbe.setObjectRef(supbe); 
          initbe.setIsEvent();  
          initbe.setParameters(new Vector());  
          expression = initbe;  
          statement = new InvocationStatement(initbe); 
        }
        else 
        { expression = new BasicExpression(methodname); 
          expression.setUmlKind(Expression.UPDATEOP);
          ((BasicExpression) expression).setParameters(new Vector());  
          ((BasicExpression) expression).setIsEvent();  
          statement = new InvocationStatement((BasicExpression) expression); 
        } 
        Vector parexprs = new Vector(); 
        ((BasicExpression) expression).setParameters(parexprs);
        ((InvocationStatement) statement).setParameters(parexprs); 
        String mqf = methodt.queryForm(); 
        return mqf + "()";  
      } 
        
      if (terms.size() > 2) 
      { ASTTerm methodt = (ASTTerm) terms.get(0);
        String methodname = methodt.toKM3();  
        if ("super".equals(methodname))
        { // call of superclass constructor 
          methodname = "super.initialise"; 
        }
 
        for (int i = 1; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          methodname = methodname + tt.toKM3(); 
        }
 
        return methodname; 
      }  
    } 
 
     
    if ("parExpression".equals(tag) || "primary".equals(tag))
    { System.out.println(">> parExpression with " + terms.size() + " terms " + terms);
      String res = ""; 

      if (terms.size() == 3 && "class".equals(((ASTTerm) terms.get(2)).literalForm()))
      { String args = ((ASTTerm) terms.get(0)).literalForm(); 
        String classcallres = "OclType[\"" + args + "\"]"; 
        Expression texpr = 
          BasicExpression.newTypeBasicExpression("OclType"); 
        expression = BasicExpression.newIndexedBasicExpression(
                     texpr,
                     new BasicExpression("\"" + args + "\"")); 
        ASTTerm.setType(this, "OclType"); 
        return classcallres; 
      }  

      if (terms.size() == 3)  // ( t ) 
      { ASTTerm tt = (ASTTerm) terms.get(1); 
        res = tt.toKM3();
        String typ = ASTTerm.getType(tt); 
        ASTTerm.setType(this,typ);

        expression = tt.expression;
        if (expression != null) 
        { expression.setBrackets(true); }   
        return "(" + res + ")";   
      } 

      if (terms.size() == 1) 
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        res = tt.toKM3();
        String typ = ASTTerm.getType(tt); 
        ASTTerm.setType(this,typ);
        expression = tt.expression; 
        return res;   
      } 

      for (int i = 0; i < terms.size(); i++) 
      { res = res + ((ASTTerm) terms.get(i)).toKM3(); }
 
      return res; 
    } 

    if ("expressionList".equals(tag))
    { Vector strs = new Vector(); 
      Vector exprs = new Vector(); 

      SequenceStatement sstats = new SequenceStatement(); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm telem = (ASTTerm) terms.get(i); 
        if (telem instanceof ASTSymbolTerm) { } 
        else 
        { strs.add(telem.toKM3()); 
          if (telem.expression != null) 
          { exprs.add(telem.expression); }
          if (telem.statement != null) 
          { sstats.addStatement(telem.statement); } 
        }  
      } 
     
      String res = "( "; 
      for (int i = 0; i < strs.size(); i++) 
      { res = res + strs.get(i); 
        if (i < strs.size()-1) 
        { res = res + ","; } 
      }
 
      if (exprs.size() == 1) 
      { expression = (Expression) exprs.get(0); 
        expression.setBrackets(true); 
      } // actually a tuple of the expressions

      statement = sstats; 

      return res + " )"; 
    } 

    if ("lambdaParameters".equals(tag))
    { if (terms.size() > 1)
      { ASTTerm par = (ASTTerm) terms.get(1); 
        String res = par.queryForm(); 
        expression = par.expression; 
        return res; 
      } 
    } 

    if ("lambdaExpression".equals(tag) && terms.size() > 2)
    { // (lambdaExpression (lambdaParameters ( pars )) -> 
      //    (lambdaBody (block { stats }))
      // Assume 1 variable. 

      ASTTerm pars = (ASTTerm) terms.get(0); 
      String parString = pars.lambdaParametersToKM3(); 
      ASTTerm body = (ASTTerm) terms.get(2); 
      String bodyString = body.toKM3(); 
      
      System.out.println("*****************************");  

      /* JOptionPane.showInputDialog("*** Lambda expression with body " + 
                         body.expression + "/" + 
                         body.statement + " variables " + 
                         pars.modelElements); 
 
      System.out.println("*****************************");  */ 

      if (body.expression != null) 
      { // Type ltype = new Type("OclAny", null);  
        Expression letexp = 
          UnaryExpression.newLambdaUnaryExpression(
                      pars.modelElements, body.expression); 
        expression = letexp; 
        statement = body.statement; 
        return letexp + ""; 
      } 

      if (body.statement != null) 
      { // Type ltype = new Type("OclAny", null);  
        Expression letexp = 
          UnaryExpression.newLambdaUnaryExpression(
            pars.modelElements, body.statement, 
            ASTTerm.currentClass, ASTTerm.enumtypes, 
            ASTTerm.entities); 
        expression = letexp; 
        statement = body.statement; 
        return letexp + ""; 
      } 

      return "lambda " + parString + " in " + bodyString; 
    }     

    if ("lambdaBody".equals(tag))
    { ASTTerm stat = (ASTTerm) terms.get(0); 
      String res = stat.toKM3();
      expression = stat.expression;  
      statement = stat.statement; 
      return res; 
    } 

    if ("expression".equals(tag))
    { System.out.println(">> Expression with " + terms.size() + " terms " + terms);
      for (int y = 0; y < terms.size(); y++)
      { ASTTerm yt = (ASTTerm) terms.get(y); 
        System.out.println(">>> Term " + y + ": " + yt); 
      }  
      System.out.println(); 

      if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        String res = t.toKM3();
        // System.out.println(">>> Single-argument expression: " + this + " with term: " + t + " |--> " + res + " expression: " + t.expression); 
        System.out.println(); 
        ASTTerm.setType(this,ASTTerm.getType(t));
        expression = t.expression;  
        statement = t.statement; 
        return res;          
      } 

      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        if ("new".equals(op + ""))
        { String res = arg.toKM3(); 
          ASTTerm.setType(this,ASTTerm.getType(arg));
          expression = arg.expression;
          modelElements = arg.modelElements;

          // JOptionPane.showInputDialog("+++ " + expression + " for " + arg); 
  
          return res;  
        } 

        String op1 = op.toKM3(); 
        String arg1 = arg.toKM3();
        String op1trim = op1.trim();  

        if ("-".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          if (arg.expression != null) 
          { expression = 
              new UnaryExpression("-", arg.expression); 
          } 
          return "-" + arg1; 
        } 

        if ("+".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg));
          expression = arg.expression;  
          return arg1; 
        } 

        if ("!".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          if (arg.expression != null) 
          { arg.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("not", arg.expression); 
          } 
          return "not(" + arg1 + ")"; 
        } 

        if ("~".equals(op.literalForm()))
        { BinaryExpression addexpr = 
            new BinaryExpression("+", arg.expression, 
                                 unitExpression);
          addexpr.setBrackets(true); 
          expression = 
            new UnaryExpression("-", addexpr); 
          return "-(" + arg1 + " + 1)"; 
        } 

        if ("++".equals(arg.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg));

          if (op.expression != null) 
          { BasicExpression unit = new BasicExpression(1); 
            expression = new BinaryExpression("+", op.expression, unit); 
            
            statement = new AssignStatement(op.expression, expression); 
          } 

          System.out.println(">> Query form of " + this + " is: " + expression); 
          System.out.println(">> Update form of " + this + " is: " + statement); 
          System.out.println(); 

          return op1 + " := " + op1 + " + 1"; 
        } 
 
        if ("--".equals(arg.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          
          if (op.expression != null) 
          { Expression unit = new BasicExpression(1); 
            expression = new BinaryExpression("-", op.expression, unit); 
            statement = new AssignStatement(op.expression, expression); 
          } 

          return op1 + " := " + op1 + " - 1"; 
        }
 
        if ("++".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg));
          if (arg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            expression = new BinaryExpression("+", arg.expression, unit); 
            statement = new AssignStatement(arg.expression, expression); 
          } 
         
          return arg1 + " := " + arg1 + " + 1"; 
        }
 
        if ("--".equals(op.literalForm()))
        { ASTTerm.setType(this,ASTTerm.getType(arg)); 
          if (arg.expression != null) 
          { Expression unit = new BasicExpression(1); 
            expression = new BinaryExpression("-", arg.expression, unit); 
            statement = new AssignStatement(arg.expression, expression); 
          } 
          return arg1 + " := " + arg1 + " - 1"; 
        }
 
        if (arg.expression != null) 
        { expression = UnaryExpression.newUnaryExpression(op1trim, arg.expression); }   

        System.out.println(">> Query form of " + this + " is: " + expression); 
        System.out.println(">> Update form of " + this + " is: " + statement); 
        System.out.println(); 
        
        return op1 + arg1; 
      }  

      if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm e1 = (ASTTerm) terms.get(0);
        ASTTerm e2 = (ASTTerm) terms.get(2);
        String opx = op.toKM3(); 
        String opxtrim = opx.trim(); 
        String e1x = e1.toKM3(); 
        String e2x = e2.toKM3();
        String e1literal = e1.literalForm(); 
        String e2literal = e2.literalForm(); 

        // System.out.println(">>> Binary expression: " + e1x + " " + op + " " + e2x); 
 
        if (".".equals(op + "") &&
            "this".equals(e2 + ""))
        { // C.this |--> self->oclAsType(C)
          ASTTerm cterm = (ASTTerm) terms.get(0); 
          String cc = cterm.queryForm();
          ASTTerm.setType(this,cc); 
 
          if (cterm.expression != null) 
          { BasicExpression selfbe = 
              BasicExpression.newVariableBasicExpression(
                                           "_container"); 
            expression = new BinaryExpression(
                           "->oclAsType", selfbe, 
                           cterm.expression); 
            return "_container->oclAsType(" + cc + ")"; 
          }
          expression = 
             BasicExpression.newVariableBasicExpression(
                                                  "self"); 
          return "self"; 
        }   

        if ("Types".equals(e1literal) && 
            ".".equals(terms.get(1) + ""))
        { ASTTerm.setType(this,"int");
          expression = 
            BasicExpression.newStaticValueBasicExpression(
                                      "sql" + e2, "SQLTypes"); 
        
          return "SQLTypes.sql" + e2; 
        } 

        if (e2 instanceof ASTSymbolTerm &&  
            ".".equals(terms.get(1) + "") && 
            ModelElement.lookupByName(e1literal,
                               ASTTerm.enumtypes) != null)
        { // element ET.lit of enumeration type
          ASTTerm.setType(this,e1literal); 
          expression = 
            BasicExpression.newStaticValueBasicExpression(
                                      e2literal, e1literal);
          System.out.println(">> Element " + e2literal + " of enumeration " + e1literal); 
 
          return e1literal + "." + e2literal; 
        } 

        if ("first".equals(e2literal) && 
            ".".equals(terms.get(1) + ""))
        { ASTTerm.setType(this,"String"); // usually  

          if (e1.expression != null) 
          { expression = 
              new BinaryExpression("->at", e1.expression,
                new BasicExpression("\"first\"")); 
          } 

          return e1x + "->at(\"first\")"; 
        }  
        
        if ("second".equals(e2literal) &&
                 ".".equals(terms.get(1) + ""))
        { ASTTerm.setType(this,"OclAny"); // usually  

          if (e1.expression != null) 
          { expression = 
              new BinaryExpression("->at", e1.expression,
                new BasicExpression("\"second\"")); 
          } 

          return e1x + "->at(\"second\")"; 
        } 

        if ("third".equals(e2literal) &&
                 ".".equals(terms.get(1) + ""))
        { ASTTerm.setType(this,"OclAny"); // usually  

          if (e1.expression != null) 
          { expression = 
              new BinaryExpression("->at", e1.expression,
                new BasicExpression("\"third\"")); 
          } 

          return e1x + "->at(\"third\")"; 
        } 
   
        if ("::".equals(terms.get(1) + ""))
        { // C::m lambda expression 
          ASTTerm cls = (ASTTerm) terms.get(0); 
          String cname = cls.literalForm(); 
          Entity cent = 
            (Entity) ModelElement.lookupByName(
                              cname,ASTTerm.entities); 

          ASTTerm met = (ASTTerm) terms.get(2); 
          String mname = met.literalForm(); 

          String rtype = "OclAny"; 

          Attribute bfpar = 
                new Attribute("_par", 
                  new Type("OclAny", null), 
                  ModelElement.INTERNAL); 

          BasicExpression parvar = 
            new BasicExpression(bfpar); 

          BasicExpression parmname = 
              BasicExpression.newCallBasicExpression(mname,
                                            parvar,
                                            new Vector()); 
          if (cent == null) 
          { // cent = new Entity(cname); 
            // ASTTerm.entities.add(cent); 
            // It is a static operation of a standard object

            if ("parseLong".equals(mname))
            { Attribute lampar = 
                new Attribute("_par", 
                  new Type("String", null), 
                  ModelElement.INTERNAL); 

              BasicExpression lamparvar = 
                new BasicExpression(lampar); 
              Expression applyExpression = 
                new UnaryExpression("->toLong", lamparvar); 
              expression = 
                new UnaryExpression("lambda", applyExpression); 
              ((UnaryExpression) expression).setAccumulator(lampar);  
              return expression + ""; 
            } 
            else if ("parseInt".equals(mname))
            { Attribute lampar = 
                new Attribute("_par", 
                  new Type("String", null), 
                  ModelElement.INTERNAL); 

              BasicExpression lamparvar = 
                new BasicExpression(lampar); 
              Expression applyExpression = 
                new UnaryExpression("->toInteger", lamparvar); 
              expression = 
                new UnaryExpression("lambda", applyExpression); 
              ((UnaryExpression) expression).setAccumulator(lampar);  
              return expression + ""; 
            } 
            else if ("parseDouble".equals(mname))
            { Attribute lampar = 
                new Attribute("_par", 
                  new Type("String", null), 
                  ModelElement.INTERNAL); 

              BasicExpression lamparvar = 
                new BasicExpression(lampar); 
              Expression applyExpression = 
                new UnaryExpression("->toReal", lamparvar); 
              expression = 
                new UnaryExpression("lambda", applyExpression); 
              ((UnaryExpression) expression).setAccumulator(lampar);  
              return expression + ""; 
            } 


            Expression inst = cls.expression; 
            BehaviouralFeature bf = 
                  new BehaviouralFeature(mname);
            bf.setResultType(new Type("OclAny", null));  
            bf.addParameter(bfpar);
                
            expression = bf.makeLambdaExpression(inst);
            //     new UnaryExpression("lambda", parmname); 
            // ((UnaryExpression) expression).setAccumulator(bfpar);  
          } 
          else 
          { Expression inst = 
              BasicExpression.newStaticCallBasicExpression(
                "new" + cname, cname); 


            BehaviouralFeature bf = 
              cent.getOperation(mname); 
            if (bf == null) 
            { bf = new BehaviouralFeature(mname);
              bf.setResultType(new Type("OclAny", null));  
              // bf.addParameter(bfpar);
            }  
            bfpar.setType(new Type(cent)); 

            rtype = bf.getResultType() + ""; 

            ASTTerm.setType(this, "Function(" + cname + ", " + rtype + ")"); 

            expression = // bf.makeLambdaExpression(inst);
                new UnaryExpression("lambda", parmname); 
            ((UnaryExpression) expression).setAccumulator(bfpar);  
          }

          // JOptionPane.showInputDialog(":: expression: " + expression); 

          return "lambda _par : " + cname + " in _par." + mname + "()";  
        } 

        if ("PI".equals(e2 + "") && "Math".equals(e1literal))
        { ASTTerm.setType(this,"double"); 
          expression = new BasicExpression(3.141592653589793); 
          return "MathLib.piValue()"; 
        }
 
        if ("E".equals(e2 + "") && "Math".equals(e1literal))
        { ASTTerm.setType(this,"double"); 
          expression = new BasicExpression(2.718281828459045); 
          return "MathLib.eValue()"; 
        } 

        if ("TRUE".equals(e2 + "") && "Boolean".equals(e1literal))
        { ASTTerm.setType(this, "boolean"); 
          expression = new BasicExpression(true); 
          return "true"; 
        }
 
        if ("FALSE".equals(e2 + "") && "Boolean".equals(e1literal))
        { ASTTerm.setType(this, "boolean"); 
          expression = new BasicExpression(false); 
          return "false"; 
        }
 
        if ("TYPE".equals(e2 + "") && "Boolean".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(true);
          expression = new UnaryExpression("->oclType", be);  
          return "true->oclType()"; 
        }

        if ("boolean".equals(e1literal) && 
            "class".equals(e2 + ""))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(true);
          expression = new UnaryExpression("->oclType", be);  
          return "true->oclType()"; 
        }

        if ("NaN".equals(e2 + ""))
        { ASTTerm.setType(this, "double"); 
          expression = 
            BasicExpression.newValueBasicExpression(
                                           "Math_NaN");
          expression.setType(new Type("double", null));  
          return "Math_NaN"; 
        }
 
        if ("POSITIVE_INFINITY".equals(e2 + ""))
        { ASTTerm.setType(this, "double"); 
          expression = 
            BasicExpression.newValueBasicExpression(
                                     "Math_PINFINITY");
          expression.setType(new Type("double", null));  
          return "Math_PINFINITY"; 
        }
 
        if ("NEGATIVE_INFINITY".equals(e2 + ""))
        { ASTTerm.setType(this, "double"); 
          expression = 
            BasicExpression.newValueBasicExpression(
                                     "Math_NINFINITY");
          expression.setType(new Type("double", null));  
          return "Math_NINFINITY"; 
        } 

        if ("TYPE".equals(e2 + "") && "Void".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          expression = new BasicExpression(new Type("void",null));
          return "OclType[\"void\"]"; 
        }

        if ("void".equals(e1literal) && 
            "class".equals(e2 + ""))
        { ASTTerm.setType(this, "OclType"); 
          expression = new BasicExpression(new Type("void",null));
          return "OclType[\"void\"]"; 
        }

        if ("MIN_VALUE".equals(e2 + "") && "Byte".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(-128); 
          return "-128"; 
        }
 
        if ("MAX_VALUE".equals(e2 + "") && "Byte".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(127); 
          return "127"; 
        }
 
        if ("SIZE".equals(e2 + "") && "Byte".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(8); 
          return "8"; 
        }
 
        if ("TYPE".equals(e2 + "") && "Byte".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0);
          expression = new UnaryExpression("->oclType", be);  
          return "0->oclType()"; 
        }

        if ("class".equals(e2 + "") && "byte".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0);
          expression = new UnaryExpression("->oclType", be);  
          return "0->oclType()"; 
        }

        if ("MIN_VALUE".equals(e2 + "") && "Character".equals(e1literal))
        { ASTTerm.setType(this, "String"); 
          expression = new BasicExpression("\"\\u0000\""); 
          expression.setType(new Type("String", null)); 

          return "\"\\u0000\""; 
        }
 
        if ("MAX_VALUE".equals(e2 + "") && "Character".equals(e1literal))
        { ASTTerm.setType(this, "String"); 
          expression = new BasicExpression("\"\\uFFFF\""); 
          expression.setType(new Type("String", null)); 
          return "\"\\uFFFF\""; 
        }
 
        if ("TYPE".equals(e2 + "") && "Character".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression("\"\"");
          be.setType(new Type("String", null)); 
          expression = new UnaryExpression("->oclType", be);  
          return "\"\"->oclType()"; 
        }

        if ("class".equals(e2 + "") && "char".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression("\"\"");
          be.setType(new Type("String", null)); 
          expression = new UnaryExpression("->oclType", be);  
          return "\"\"->oclType()"; 
        }

        if ("MIN_VALUE".equals(e2 + "") && "Short".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(-32768); 
          return "-32768"; 
        }
 
        if ("MAX_VALUE".equals(e2 + "") && "Short".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(32767); 
          return "32767"; 
        }
 
        if ("SIZE".equals(e2 + "") && "Short".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(16); 
          return "16"; 
        }
  
        if ("TYPE".equals(e2 + "") && "Short".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0);
          expression = new UnaryExpression("->oclType", be);  
          return "0->oclType()"; 
        }

        if ("class".equals(e2 + "") && "short".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0);
          expression = new UnaryExpression("->oclType", be);  
          return "0->oclType()"; 
        }

        if ("MIN_VALUE".equals(e2 + "") && "Float".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(1.401298464324817E-45); 
          return "(2->pow(-149))"; 
        }
 
        if ("MAX_VALUE".equals(e2 + "") && "Float".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(3.4028234663852886E38); 
          return "3.4028234663852886*(10->pow(38))"; 
        }
 
        if ("SIZE".equals(e2 + "") && "Float".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(32); 
          return "32"; 
        }
 
        if ("TYPE".equals(e2 + "") && "Float".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0.0);
          expression = new UnaryExpression("->oclType", be);  
          return "(0.0)->oclType()"; 
        }

        if ("class".equals(e2 + "") && "float".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0.0);
          expression = new UnaryExpression("->oclType", be);  
          return "(0.0)->oclType()"; 
        }

        if ("MIN_VALUE".equals(e2 + "") && "Double".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(4.9E-324); 
          return "2->pow(-1074)"; 
        }
 
        if ("MAX_VALUE".equals(e2 + "") && "Double".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(1.7976931348623157E308); 

          return "(2 - 2->pow(-52))*(2->pow(1023))"; 
        }
 
        if ("SIZE".equals(e2 + "") && "Double".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          expression = new BasicExpression(64); 
          return "64"; 
        }
 
        if ("TYPE".equals(e2 + "") && "Double".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0.0);
          expression = new UnaryExpression("->oclType", be);  
          return "(0.0)->oclType()"; 
        }

        if ("class".equals(e2 + "") && "double".equals(e1literal))
        { ASTTerm.setType(this, "OclType"); 
          BasicExpression be = new BasicExpression(0.0);
          expression = new UnaryExpression("->oclType", be);  
          return "(0.0)->oclType()"; 
        }

        if ("EMPTY_LIST".equals(e2 + "") && "Collections".equals(e1x))
        { ASTTerm.setType(this, "Sequence"); 
          expression = new SetExpression(true);  
          return "Sequence{}"; 
        }
  
        if ("EMPTY_SET".equals(e2 + "") && "Collections".equals(e1x))
        { ASTTerm.setType(this, "Set"); 
          expression = new SetExpression();  
          return "Set{}"; 
        }
  
        if ("EMPTY_MAP".equals(e2 + "") && "Collections".equals(e1x))
        { ASTTerm.setType(this, "Map"); 
          expression = SetExpression.newMapSetExpression();  
          return "Map{}"; 
        }  

        if ("Integer".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          if ("MAX_VALUE".equals(e2 + ""))
          { expression = new BasicExpression(2147483647); 
            return "2147483647"; 
          } 
          else if ("MIN_VALUE".equals(e2 + ""))
          { expression = new BasicExpression(-2147483648); 
            return "-2147483648"; 
          } 
          else if ("SIZE".equals(e2 + ""))
          { expression = new BasicExpression(32); 
            return "32"; 
          } 
          else if ("TYPE".equals(e2 + ""))
          { BasicExpression be = new BasicExpression(0);
            expression = new UnaryExpression("->oclType", be);  
            ASTTerm.setType(this, "OclType"); 
            return "0->oclType()"; 
          }
        } 

        if ("int".equals(e1literal) && 
            "class".equals(e2 + ""))
        { BasicExpression be = new BasicExpression(0);
          expression = new UnaryExpression("->oclType", be);  
          ASTTerm.setType(this, "OclType"); 
          return "0->oclType()"; 
        }

        if ("Long".equals(e1literal))
        { ASTTerm.setType(this, "long"); 
          if ("MAX_VALUE".equals(e2 + ""))
          { expression = 
              new BasicExpression(9223372036854775807L); 
            return "9223372036854775807"; 
          } 
          else if ("MIN_VALUE".equals(e2 + ""))
          { expression = 
              new BasicExpression(-9223372036854775808L); 
            return "-9223372036854775808"; 
          } 
          else if ("SIZE".equals(e2 + ""))
          { expression = new BasicExpression(64); 
            ASTTerm.setType(this, "int"); 
            return "64"; 
          } 
          else if ("TYPE".equals(e2 + ""))
          // { return "9223372036854775807->oclType()"; }
          { expression = new BasicExpression(new Type("long", null)); 
            ASTTerm.setType(this, "OclType"); 
            return "OclType[\"long\"]"; 
          }
        } 

        if ("long".equals(e1literal) && 
            "class".equals(e2 + ""))
        { expression = 
            new BasicExpression(new Type("long", null)); 
          ASTTerm.setType(this, "OclType"); 
          return "OclType[\"long\"]"; 
        }

        if ("class".equals(e2 + ""))
        { String tres = "OclType[\"" + e1literal + "\"]"; 
          Expression texpr = 
            BasicExpression.newTypeBasicExpression("OclType"); 
          expression = 
            BasicExpression.newIndexedBasicExpression(
                     texpr,
                     new BasicExpression("\"" + e1literal + "\"")); 
          ASTTerm.setType(this, "OclType"); 
          return tres; 
        }  


        if ("Thread".equals(e1literal))
        { ASTTerm.setType(this, "int"); 
          if ("MAX_PRIORITY".equals(e2 + ""))
          { expression = new BasicExpression(10); 
            return "10"; 
          } 
          else if ("MIN_PRIORITY".equals(e2 + ""))
          { expression = new BasicExpression(1); 
            return "1"; 
          } 
          else if ("NORM_PRIORITY".equals(e2 + ""))
          { expression = new BasicExpression(5); 
            return "5"; 
          } 
        } 


        if ("ONE".equals(e2 + "") && "BigInteger".equals(e1literal))
        { expression = new BasicExpression(1); 
          ASTTerm.setType(this, "int"); 
          return "1"; 
        } 
        
        if ("ZERO".equals(e2 + "") && "BigInteger".equals(e1literal))
        { expression = new BasicExpression(0); 
          ASTTerm.setType(this, "int"); 
          return "0"; 
        }
 
        if ("TEN".equals(e2 + "") && "BigInteger".equals(e1literal))
        { expression = new BasicExpression(10); 
          ASTTerm.setType(this, "int"); 
          return "10"; 
        } 

        if ("ONE".equals(e2 + "") && "BigDecimal".equals(e1literal))
        { expression = new BasicExpression(1.0); 
          ASTTerm.setType(this, "double"); 
          return "1.0"; 
        }
 
        if ("ZERO".equals(e2 + "") && "BigDecimal".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(0.0);   
          return "0.0"; 
        }
 
        if ("TEN".equals(e2 + "") && "BigDecimal".equals(e1literal))
        { ASTTerm.setType(this, "double"); 
          expression = new BasicExpression(10.0);   
          return "10.0"; 
        } 

        if ("length".equals(e2 + "") || 
            "elementCount".equals(e2 + ""))
        { ASTTerm.setType(this, "int"); 
          if (e1.expression != null) 
          { expression = new UnaryExpression("->size", e1.expression);            
            expression.setType(new Type("int", null)); 
          }   

          return e1x + "->size()"; 
        } 

        if (".".equals(op + ""))
        { e1x = e1.queryForm(); 
          System.out.println(">>> Feature access: " + e1 + "." + e2); 

          String res = featureAccess(e1,e2,e1x,e2x);

          // if (e2.updatesObject(null))
          // { // get e1.updatedObject 
          // } 

          if (e1.hasSideEffect()) // preSide
          { String pse = e1.preSideEffect(); 
            if (pse != null && e1.statement != null) 
            { SequenceStatement ss = new SequenceStatement(); 
              ss.addStatement(e1.statement); 
              ss.addStatement(statement); 
              statement = ss; 
              res = pse + " ;\n    " + res;
            }
          } 

          return res;
        } 

        /* Assignment expressions. Have an interpretation 
           both as statements and as expressions */ 

        if ("=".equals(op + "") && e2.updatesObject(null))
        { // e1x := result of e2x ; postsideeffect of e2x
          String postEffect = e2.postSideEffect(); 

          // JOptionPane.showInputDialog(">> Update form of " + 
          //                this + " : >> " + e2.statement); 
        
          Statement updateF = e2.statement; 
          String qf = e2.queryForm(); 

          if (e1.expression != null && e2.expression != null) 
          { AssignStatement stat = 
              new AssignStatement(e1.expression, e2.expression);

            if (updateF == null) 
            { updateF = e2.statement; } 

            if (updateF != null) 
            { statement = new SequenceStatement(); 
              ((SequenceStatement) statement).addStatement(stat); 
              ((SequenceStatement) statement).addStatement(updateF); 
            } 
            else 
            { statement = stat; } 
            expression = e1.expression; 
          }
 
          return "(" + e1x + " := " + qf + " ; " + postEffect + ")"; 
        } 

        if ("=".equals(op + "") && e1.hasSideEffect() &&
            e2.hasSideEffect())
        { // pre sideeffect of e1 ; 
          // pre sideeffect of e2 ; 
          // e1x := result of e2 ; 
          // post sideeffect of e1 -- the e1.toKM3()          
          // post sideeffect of e2 -- the e2.toKM3()

          // System.out.println(">>> Expression with side effects on LHS and RHS: " + this); 

          String prese1 = e1.preSideEffect();
          Statement preStat1 = e1.statement; 
          String postse1 = e1.postSideEffect(); 
          Statement postStat1 = e1.statement;

          String prese = e2.preSideEffect();
          Statement preStat = e2.statement; 
          String postse = e2.postSideEffect(); 
          Statement postStat = e2.statement;
            
          if (prese == null && prese1 == null && 
              postse1 != null && postse != null) 
          { String qf = e2.queryForm();  
            
            String res = "    " + e1x + " := " + 
                         qf + " ;\n    " + postse1 + 
                         " ;\n    " + postse;
            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && postStat1 != null &&
                queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              stat.addStatement(postStat1); 
              stat.addStatement(postStat); 
              statement = stat; 
              expression = e1.expression; 
            }  
            return res; 
          } 
          else if (postse == null && postse1 == null) 
          { String qf1 = e1.queryForm();  
            String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && preStat1 != null && 
                queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              stat.addStatement(preStat1); 
              stat.addStatement(preStat); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese1 + " ; " + prese + " ;" +  
                   "\n    " + qf1 + " := " + qf; 
          } 
          else 
          { String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement();

              if (preStat1 != null) 
              { stat.addStatement(preStat1); } 

              if (preStat != null) 
              { stat.addStatement(preStat); } 
  
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 

              if (postStat1 != null)
              { stat.addStatement(postStat1); } 

              if (postStat != null)
              { stat.addStatement(postStat); } 
 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese1 + " ; " + prese + " ;" +  
                   "\n    " + e1x + " := " + qf + " ;\n    " + postse1 + " ; " + postse; 
          }  
        } 

        if ("=".equals(op + "") && e2.hasSideEffect())
        { // pre sideeffect of e2 ; 
          // e1x := result of e2 ; 
          // post sideeffect of e2 -- the e2.toKM3()

          // System.out.println(">>> Expression with side effect: " + this); 

          String prese = e2.preSideEffect();
          Statement preStat = e2.statement; 
          String postse = e2.postSideEffect(); 
          Statement postStat = e2.statement;
            
          if (prese == null && postse != null) 
          { String qf = e2.queryForm();  
            
            String res = "    " + e1x + " := " + 
                         qf + " ;\n    " + postse;
            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              stat.addStatement(postStat); 
              statement = stat; 
              expression = e1.expression; 
            }  
            return res; 
          } 
          else if (postse == null) 
          { String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              stat.addStatement(preStat); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese + " ;" +  
                   "\n    " + e1x + " := " + qf; 
          } 
          else 
          { String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && 
                postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement();
              stat.addStatement(preStat);  
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              stat.addStatement(postStat); 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese + " ;" +  
                   "\n    " + e1x + " := " + qf + " ;\n    " + postse; 
          }  
        } 

        if ("=".equals(op + "") && e1.hasSideEffect())
        { // pre sideeffect of e1 ; 
          // e1x := result of e1 ; 
          // post sideeffect of e1 -- the e1.toKM3()

          System.out.println(">>> Expression with side effect: " + this); 

          String prese = e1.preSideEffect();
          Statement preStat = e1.statement; 
          String postse = e1.postSideEffect(); 
          Statement postStat = e1.statement;
            
          if (prese == null && postse != null) 
          { String qf1 = e1.queryForm();  
            String qf = e2.queryForm();  
            
            String res = "    " + qf1 + " := " + 
                         qf + " ;\n    " + postse;
            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              stat.addStatement(postStat); 
              expression = e1.expression; 
              statement = stat; 
            }  
            return res; 
          } 
          else if (postse == null) 
          { String qf1 = e1.queryForm();  
            String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              stat.addStatement(preStat); 
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese + " ;" +  
                   "\n    " + qf1 + " := " + qf; 
          } 
          else 
          { String qf1 = e1.queryForm();  
            String qf = e2.queryForm();  

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && 
                postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement();
              stat.addStatement(preStat);  
              if ((lhs + "").equals(queryExp + "")) { } 
              else 
              { stat.addStatement(
                  new AssignStatement(lhs,queryExp)); 
              } 
              stat.addStatement(postStat); 
              statement = stat; 
              expression = e1.expression; 
            }  

            return prese + " ;" +  
                   "\n    " + qf1 + " := " + qf + " ;\n    " + postse; 
          }  
        } 

        if ("=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { statement = 
              new AssignStatement(e1.expression, e2.expression);
            System.out.println(">> Valid assignment: " + statement);
            expression = e1.expression; 
            System.out.println();  
          }
          else if (e1.expression != null) 
          { statement = 
              new AssignStatement(e1.expression, new BasicExpression(e2x)); 
            System.out.println(">> Invalid assignment: " + statement);
            expression = e1.expression; 
            System.out.println();  
          } 

          return e1x + " := " + e2x; 
        } 

        
   
        if ("+=".equals(op + "") && e2.hasSideEffect())
        { // pre sideeffect of e2 ; 
          // e1x := e1x + (query form of e2) ; 
          // post sideeffect of e2 -- the e2.toKM3()

          System.out.println(">>> Expression with side effect: " + this); 

          String prese = e2.preSideEffect();
          Statement preStat = e2.statement; 
          String postse = e2.postSideEffect(); 
          Statement postStat = e2.statement;
            
          if (prese == null && postse != null) 
          { String qf = e2.queryForm(); 
 
            String res = 
              "    " + e1x + " := " + 
              e1x + " + " + qf + " ;\n    " + postse;
            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("+", e1.expression, 
                                     queryExp); 
              stat.addStatement(new AssignStatement(lhs,expression)); 
              stat.addStatement(postStat); 
              // expression = e1.expression; 
              statement = stat; 
            }  
            return res; 
          } 
          else if (postse == null) 
          { String qf = e2.queryForm(); 
 
            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("+", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression)); 
              // expression = e1.expression; 
              statement = stat; 
            }  
            
            return prese + " ;" +  
                   "\n    " + e1x + " := " + e1x + " + " + qf; 
          } 
          else // both non-null
          { String qf = e2.queryForm();

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null && postStat != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("+", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression));
              stat.addStatement(postStat);  
              statement = stat; 
            }  
 
            return prese + " ;" +  
              "\n    " + e1x + " := " + 
              e1x + " + " + qf + " ;\n    " + postse; 
          }  
        } 
     
        if ("+=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { expression = 
              new BinaryExpression("+", e1.expression, e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " + " + e2x;
        }

        if ("-=".equals(op + "") && e2.hasSideEffect())
        { // pre sideeffect of e2 ; 
          // e1x := e1x - (query form of e2) ; 
          // post sideeffect of e2 -- the e2.toKM3()

          System.out.println(">>> Expression with side effect: " + this); 

          String prese = e2.preSideEffect();
          Statement preStat = e2.statement; 
          String postse = e2.postSideEffect(); 
          Statement postStat = e2.statement;
            
          if (prese == null && postse != null) 
          { String qf = e2.queryForm(); 
 
            String res = 
              "    " + e1x + " := " + 
              e1x + " - (" + qf + ") ;\n    " + postse;

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement();
              queryExp.setBrackets(true);  
              expression = 
                new BinaryExpression("-", e1.expression, 
                                     queryExp); 
              stat.addStatement(new AssignStatement(lhs,expression)); 
              stat.addStatement(postStat); 
              statement = stat; 
            }  
            return res; 
          } 
          else if (postse == null) 
          { String qf = e2.queryForm(); 
 
            Expression queryExp = e2.expression; 
            queryExp.setBrackets(true);  
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("-", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression)); 
              statement = stat; 
            }  
            
            return prese + " ;" +  
                   "\n    " + e1x + " := " + e1x + " - (" + qf + ")"; 
          } 
          else // both non-null
          { String qf = e2.queryForm();

            Expression queryExp = e2.expression; 
            queryExp.setBrackets(true);  

            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null && postStat != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("-", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression));
              stat.addStatement(postStat);  
              statement = stat; 
            }  
 
            return prese + " ;" +  
              "\n    " + e1x + " := " + 
              e1x + " - (" + qf + ") ;\n    " + postse; 
          }  
        } 

        if ("-=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("-", e1.expression, e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " - " + e2x;
        } 

        if ("*=".equals(op + "") && e2.hasSideEffect())
        { // pre sideeffect of e2 ; 
          // e1x := e1x * (query form of e2) ; 
          // post sideeffect of e2 -- the e2.toKM3()

          System.out.println(">>> Expression with side effect: " + this); 

          String prese = e2.preSideEffect();
          Statement preStat = e2.statement; 
          String postse = e2.postSideEffect(); 
          Statement postStat = e2.statement;
            
          if (prese == null && postse != null) 
          { String qf = e2.queryForm(); 
 
            String res = 
              "    " + e1x + " := " + 
              e1x + " * (" + qf + ") ;\n    " + postse;

            Expression queryExp = e2.expression; 
            Expression lhs = e1.expression; 
            if (postStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement();
              queryExp.setBrackets(true);  
              expression = 
                new BinaryExpression("*", e1.expression, 
                                     queryExp); 
              stat.addStatement(
                     new AssignStatement(lhs,expression)); 
              stat.addStatement(postStat); 
              statement = stat; 
            }  
            return res; 
          } 
          else if (postse == null) 
          { String qf = e2.queryForm(); 
 
            Expression queryExp = e2.expression; 
            queryExp.setBrackets(true);  
            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("*", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression)); 
              statement = stat; 
            }  
            
            return prese + " ;" +  
                   "\n    " + e1x + " := " + e1x + " * (" + qf + ")"; 
          } 
          else // both non-null
          { String qf = e2.queryForm();

            Expression queryExp = e2.expression; 
            queryExp.setBrackets(true);  

            Expression lhs = e1.expression; 
            if (preStat != null && queryExp != null && 
                lhs != null && postStat != null) 
            { SequenceStatement stat = 
                new SequenceStatement(); 
              expression = 
                new BinaryExpression("*", e1.expression, 
                                     queryExp); 
              stat.addStatement(preStat); 
              stat.addStatement(
                new AssignStatement(lhs,expression));
              stat.addStatement(postStat);  
              statement = stat; 
            }  
 
            return prese + " ;" +  
              "\n    " + e1x + " := " + 
              e1x + " * (" + qf + ") ;\n    " + postse; 
          }  
        } 
 
        if ("*=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("*", e1.expression, 
                                   e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " * " + e2x; 
        } 

        if ("/=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("/", e1.expression, 
                                   e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " / " + e2x; 
        }
 
        if ("^=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { // e2.expression.setBrackets(true); 
            Vector parsx = new Vector(); 
            parsx.add(e1.expression); 
            parsx.add(e2.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                   "bitwiseXor", "MathLib", parsx); 
              // new BinaryExpression("xor", e1.expression, 
              //                      e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := MathLib.bitwiseXor(" + e1x + ", " + e2x + ")"; 
        }
 
        if ("&=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            Vector parsx = new Vector(); 
            parsx.add(e1.expression); 
            parsx.add(e2.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                   "bitwiseAnd", "MathLib", parsx); 
              // new BinaryExpression("&", e1.expression, 
              //                     e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := MathLib.bitwiseAnd(" + e1x + ", " + e2x + ")"; 
        } 

        if ("|=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            Vector parsx = new Vector(); 
            parsx.add(e1.expression); 
            parsx.add(e2.expression); 
            expression = 
              BasicExpression.newStaticCallBasicExpression(
                   "bitwiseOr", "MathLib", parsx); 
              // new BinaryExpression("or", e1.expression, 
              //                      e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := MathLib.bitwiseOr(" + e1x + ", " + e2x + ")"; 
        }
 
        if ("%=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { e2.expression.setBrackets(true); 
            expression = 
              new BinaryExpression("mod", e1.expression, 
                                   e2.expression); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " mod " + e2x; 
        } 

        if ("<<=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, e2.expression); 
            twopow.setBrackets(true); 
            expression = 
              new BinaryExpression("*", 
                           e1.expression, twopow);
            expression.setType(new Type("long", null)); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " * (2->pow(" + e2x + "))"; 
        } 

        if (">>=".equals(op + "") || ">>>=".equals(op + ""))
        { if (e1.expression != null && e2.expression != null) 
          { Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, e2.expression); 
            twopow.setBrackets(true); 
            expression = 
              new BinaryExpression("/", 
                           e1.expression, twopow);
            expression.setType(new Type("long", null)); 
            statement = 
              new AssignStatement(e1.expression, expression);
            System.out.println(">> Assignment: " + statement);
            System.out.println();  
          } 
          return e1x + " := " + e1x + " / (2->pow(" + e2x + "))"; 
        } 
        
        if ("<<".equals(op + ""))
        { ASTTerm.setType(this, "long"); 
          if (e1.expression != null && e2.expression != null) 
          { Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, e2.expression); 
            twopow.setBrackets(true); 
            expression = 
              new BinaryExpression("*", 
                           e1.expression, twopow);
            expression.setType(new Type("long", null)); 
          }
          return e1x + "*(2->pow(" + e2x + "))->oclAsType(long)"; 
        }
 
        if (">>".equals(op + "") || ">>>".equals(op + ""))
        { ASTTerm.setType(this, "long"); 
          if (e1.expression != null && e2.expression != null) 
          { Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, e2.expression); 
            twopow.setBrackets(true); 
            expression = 
              new BinaryExpression("/", 
                           e1.expression, twopow);
            expression.setBrackets(true); 
            expression.setType(new Type("long", null)); 
          }
          return "(" + e1x + "/(2->pow(" + e2x + ")))->oclAsType(long)"; 
        } // But >>> is different to >>

        if ("instanceof".equals(op + ""))
        { ASTTerm.setType(this, "boolean"); 
        
          if (e1.expression != null && e2.expression != null) 
          { expression = new BinaryExpression(
               "->oclIsKindOf", e1.expression, e2.expression);
          } 
          else 
          { expression = 
              BinaryExpression.newBinaryExpression(
                  "->oclIsKindOf", e1x, e2x);
          } 

          expression.setType(new Type("boolean", null)); 
          
          System.out.println(">> instanceof expression: " + expression); 

          return e1x + "->oclIsKindOf(" + e2x + ")"; 
        } 

        // Any custom translation for binary infix operators 
        // goes here. 

        if ("%".equals(op.literalForm()) || 
            "mod".equals(opx))
        { ASTTerm.setType(this, "int");
          // System.out.println(">>> Type of " + this + " is int"); 
          // System.out.println();
          if (e1.expression != null && e2.expression != null) 
          { expression = 
              new BinaryExpression("mod", e1.expression, 
                                          e2.expression); 
            expression.setType(new Type("int", null)); 
          }  
          return e1x + " mod " + e2x;  
        }

        if ("/".equals(op.literalForm()) || 
            "*".equals(op.literalForm()) ||
            "-".equals(op.literalForm()))
        { if (e1.isString() && e2.isString())
          { // 'z' - 'a' etc
            ASTTerm.setType(this, "int"); 

            if (e1.expression != null) 
            { e1.expression = 
               new UnaryExpression("->char2byte", e1.expression); 
            } 
            e1x = "(" + e1x + ")->char2byte()"; 

            if (e2.expression != null) 
            { e2.expression = 
               new UnaryExpression("->char2byte", e2.expression); 
            } 
            e2x = "(" + e2x + ")->char2byte()"; 
          } 
          else if (e1.isString() && e2.isInteger())
          { // 'a' - 97 etc
            ASTTerm.setType(this, "int"); 
            if (e1.expression != null) 
            { e1.expression = 
               new UnaryExpression("->char2byte", e1.expression); 
            } 
            e1x = "(" + e1x + ")->char2byte()"; 
          } 
          else if (e1.isInteger() && e2.isString())
          { // 'a' - 97 etc
            ASTTerm.setType(this, "int"); 
            if (e2.expression != null) 
            { e2.expression = 
               new UnaryExpression("->char2byte", e2.expression); 
            } 
            e2x = "(" + e2x + ")->char2byte()"; 
          } 
          else if (e1.isInteger() && e2.isInteger())
          { ASTTerm.setType(this, ASTTerm.getType(e1)); } 
          else 
          { ASTTerm.setType(this, "double"); }  

          if (e1.expression != null && e2.expression != null) 
          { expression = 
              new BinaryExpression(opxtrim, e1.expression, 
                                          e2.expression); 
          }  

          return e1x + " " + op.literalForm() + " " + e2x;  
        }

        if ("+".equals(op.literalForm()))
        { if (e1.isInteger() && e2.isInteger())
          { ASTTerm.setType(this, ASTTerm.getType(e1)); } 
          else if (e1.isString() || e2.isString())
          { ASTTerm.setType(this, "String"); }
          else 
          { ASTTerm.setType(this, "double"); }

          if (e1.expression != null && e2.expression != null) 
          { expression = 
              new BinaryExpression("+", e1.expression, 
                                        e2.expression); 
          }  

          return e1x + " + " + e2x;  
        }

        if ("==".equals(op.literalForm()))
        { ASTTerm.setType(this, "boolean");
          String e1xx = e1.toKM3(); 
          String e2xx = e2.toKM3(); 
          if (e1.isIdentifier() && e2.isIdentifier()  && 
              (e1.isCollection() || e2.isCollection()))
          { if (e1.expression != null && e2.expression != null) 
            { expression = new BinaryExpression("<>=", 
                                  e1.expression, e2.expression); 
              expression.setType(new Type("boolean", null)); 
            } 
            return e1xx + " <>= " + e2xx; 
          } // Also for strings and for !=

          if (e1.expression != null && e2.expression != null) 
          { expression = new BinaryExpression("=", e1.expression, e2.expression); 
            expression.setType(new Type("boolean", null)); 
          } 

          return e1xx + " = " + e2xx; 
        }

        if ("!=".equals(op.literalForm()))
        { ASTTerm.setType(this, "boolean");
          String e1xx = e1.toKM3(); 
          String e2xx = e2.toKM3(); 
          if (e1.isIdentifier() && e2.isIdentifier()  && 
              (e1.isCollection() || e2.isCollection()))
          { if (e1.expression != null && e2.expression != null) 
            { BinaryExpression expr = 
                new BinaryExpression("<>=", e1.expression, 
                                     e2.expression);
              expr.setBrackets(true); 
              expression = new UnaryExpression("not", expr);  
              expression.setType(new Type("boolean", null)); 
            } 
            return "not(" + e1xx + " <>= " + e2xx + ")"; 
          } 

          if (e1.expression != null && e2.expression != null) 
          { expression = new BinaryExpression("/=", e1.expression, e2.expression); 
            expression.setType(new Type("boolean", null)); 
          } 

          return e1xx + " /= " + e2xx; 
        }

        if ("&".equals(op + "") && e1.isInteger() && 
            e2.isInteger())
        { ASTTerm.setType(this, "int");

          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseAnd", "MathLib", parms);
            expression.setType(new Type("int", null)); 
          } 

          return "MathLib.bitwiseAnd(" + e1x + ", " + e2x + ")"; 
        }
 
        if ("|".equals(op + "") && e1.isInteger() && 
            e2.isInteger())
        { ASTTerm.setType(this, "int");

          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseOr", "MathLib", parms); 
            expression.setType(new Type("int", null)); 
          } 

          return "MathLib.bitwiseOr(" + e1x + ", " + e2x + ")"; 
        } 


        if ("^".equals(op + "") && 
            (e1.isInteger() || 
             e2.isInteger()))
        { ASTTerm.setType(this, "int");

          String e1xx = e1.toKM3(); 
          String e2xx = e2.toKM3(); 
       
          // JOptionPane.showInputDialog("bitwiseOr for " + e1 + " " + e2 + " " + e1.expression + " " + e2.expression); 

          if (e1.expression != null && 
              e2.expression != null) 
          { Vector parms = new Vector(); 
            parms.add(e1.expression); 
            parms.add(e2.expression); 
            expression = BasicExpression.newStaticCallBasicExpression("bitwiseXor", "MathLib", parms); 
            expression.setType(new Type("int", null)); 
          } 

          return "MathLib.bitwiseXor(" + e1xx + ", " + e2xx + ")"; 
        } 


        if ("<".equals(op.literalForm()) ||
            ">".equals(op.literalForm()) || 
            ">=".equals(op.literalForm()) || 
            "==".equals(op.literalForm()) ||
            "<=".equals(op.literalForm()) ||
            "!=".equals(op.literalForm()) ||
            "&&".equals(op.literalForm()) ||
            "||".equals(op.literalForm()))
        { ASTTerm.setType(this, "boolean");
          System.out.println(">>> Type of " + this + " is boolean"); 
          System.out.println(); 
        }
          
        if (e1.expression != null && e2.expression != null) 
        { expression = 
            new BinaryExpression(opx.trim(), 
                  e1.expression, e2.expression); 

          if (Expression.isComparator(opx))
          { expression.setType(new Type("boolean", null)); }

          // System.out.println(">>> Binary expression is: " + expression); 
          System.out.println(); 
        } 

        return e1x + opx + e2x; 
      }  

      if (terms.size() == 5 && 
          ">".equals(terms.get(1) + "") && 
          ">".equals(terms.get(2) + "") && 
          ">".equals(terms.get(3) + ""))
      { ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(4);

        String arg1x = arg1.toKM3(); 
        String arg2x = arg2.toKM3(); 

        if (arg1.expression != null && arg2.expression != null) 
        { Expression twopow = 
              new BinaryExpression("->pow", 
                     twoExpression, arg2.expression); 
          twopow.setBrackets(true); 
          expression = 
              new BinaryExpression("/", 
                           arg1.expression, twopow);
          expression.setType(new Type("long", null)); 
          statement = 
              new AssignStatement(arg1.expression, expression);
          // System.out.println(">> Assignment: " + statement);
          System.out.println();  
        } 
        return arg1x + " := " + arg1x + 
                              " / (2->pow(" + arg2x + "))"; 
      } 

      if (terms.size() == 4 && 
          ".".equals(terms.get(1) + "") && 
          "new".equals(terms.get(2) + ""))
      { ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(3);

        String arg1x = arg1.queryForm(); 
        String arg2x = arg2.toKM3(); 
        String res = arg1x + "." + arg2x;          
        if (arg2.expression != null && 
            arg2.expression instanceof BasicExpression)
        { BasicExpression be2 = 
             (BasicExpression) arg2.expression;
          Vector be2pars = be2.getParameters(); 

          res = arg1x + "." + be2.data + "("; 
          for (int ik = 0; ik < be2pars.size(); ik++) 
          { res = res + be2pars.get(ik); 
            if (ik < be2pars.size()-1)
            { res = res + ","; } 
          } 
          res = res + ")"; 

          expression = 
            BasicExpression.newCallBasicExpression(
              be2.data,
              arg1.expression,
              be2.getParameters()); 
        } 

        return res;
      } 


      if (terms.size() >= 4 && 
          "(".equals(terms.get(0) + "") && 
          ")".equals(terms.get(terms.size()-2) + "")) // cast
      { ASTTerm typ = (ASTTerm) terms.get(terms.size()-3); 
        ASTTerm arg = (ASTTerm) terms.get(terms.size()-1);

        String typx = typ.toKM3(); 
        String argx = arg.toKM3();
        ASTTerm.setType(this, typx);

        if (arg.updatesObject(null))
        { return argx; }
  
        String qf = arg.queryForm(); 
        String ct = typx; 

        ASTTerm.setType(this, ct); 

        if ("String".equals(ASTTerm.getType(arg)) && 
            ("int".equals(ct) || "long".equals(ct) ||
             "short".equals(ct) || "byte".equals(ct))
           )
        { if (arg.expression != null)
          { arg.expression.setBrackets(true); 
            expression = 
              new UnaryExpression("->char2byte", 
                                  arg.expression); 
          }
          return "(" + qf + ")->char2byte()"; 
        }  

        if (arg.expression != null) 
        { Expression typexpr = new BasicExpression(new Type(typx, null)); 
          arg.expression.setBrackets(true); 
          expression = new BinaryExpression("->oclAsType", arg.expression, typexpr); 
        }

        return "(" + argx + ")->oclAsType(" + typx + ")";
      }  


      if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        String arrx = arr.queryForm(); 
        String indx = ind.toKM3();

        String typ = ASTTerm.getType(arr); 
        String elemType = ASTTerm.getElementType(arr); 
        ASTTerm.setType(this, elemType); 

        // System.out.println(">>>--->>> element type of " + this + " type " + typ + " is " + elemType); 
        System.out.println(); 

        if (arr.expression != null && 
            ind.expression != null)
        { BasicExpression unit = new BasicExpression(1); 
          Expression inde = new BinaryExpression("+", ind.expression, unit);  

          expression = 
             BasicExpression.newIndexedBasicExpression(arr.expression, inde); 
        } 
        
        return arrx + "[" + indx + " + 1]";
      } // It must be indexed by integers. Not a map. 

      if (terms.size() == 4 && 
          "<".equals(terms.get(1) + "") &&
          "<".equals(terms.get(2) + ""))
      { ASTTerm.setType(this, "long"); 
        ASTTerm arg1 = (ASTTerm) terms.get(0); 
        ASTTerm arg2 = (ASTTerm) terms.get(3);

        String arg1x = arg1.toKM3(); 
        String arg2x = arg2.toKM3();

        if (arg1.expression != null && 
            arg2.expression != null)
        { BinaryExpression rhs = 
            new BinaryExpression("->pow", 
                        new BasicExpression(2),
                        arg2.expression); 
          Expression pexpression = 
            new BinaryExpression("*", arg1.expression, rhs);
          pexpression.setBrackets(true); 
          expression = 
            new BinaryExpression("->oclAsType", pexpression,
              BasicExpression.newTypeBasicExpression("long"));  
        } 
 
        return "(" + arg1x + "*(2->pow(" + arg2x + ")))->oclAsType(long)"; 
      } 

      if (terms.size() == 4 && 
          ">".equals(terms.get(1) + "") &&
          ">".equals(terms.get(2) + ""))
      { ASTTerm.setType(this, "long"); 
        ASTTerm arg1 = (ASTTerm) terms.get(0); 
        ASTTerm arg2 = (ASTTerm) terms.get(3);

        String arg1x = arg1.toKM3(); 
        String arg2x = arg2.toKM3();

        if (arg1.expression != null && 
            arg2.expression != null)
        { BinaryExpression rhs = 
            new BinaryExpression("->pow", 
                        new BasicExpression(2),
                        arg2.expression); 
          Expression pexpression = 
            new BinaryExpression("/", arg1.expression, rhs); 
          pexpression.setBrackets(true); 
          expression = 
            new BinaryExpression("->oclAsType", pexpression,
              BasicExpression.newTypeBasicExpression("long"));  
        } 

        return "(" + arg1x + "/(2->pow(" + arg2x + ")))->oclAsType(long)"; 
      }

      if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        String condx = cond.toKM3(); 
        String ifx = ifoption.toKM3(); 
        String elsex = elseoption.toKM3();
        ASTTerm.setType(this, ASTTerm.getType(ifoption)); 
          
        Expression ce = cond.expression; 
        Expression ife = ifoption.expression; 
        Expression elsee = elseoption.expression; 
        if (ce != null && ife != null && elsee != null) 
        { expression = 
            new ConditionalExpression(ce,ife,elsee); 
        }

        return "if " + condx + " then " + ifx + " else " + elsex + " endif"; 
      } 
    } 

    if ("statement".equals(tag))
    { System.out.println(">> toKM3 Statement with " + terms.size() + " terms "); 

      modelElements = new Vector(); // for inner classes. 

      for (int h = 0; h < terms.size(); h++) 
      { System.out.println("--- Term " + h + ": " + terms.get(h)); } 
      System.out.println(); 

      if (terms.size() >= 2 && "throw".equals(terms.get(0) + "")) 
      { ASTTerm t = (ASTTerm) terms.get(1);
        String trexp = t.toKM3(); 

        if (t.expression != null) 
        { statement = new ErrorStatement(t.expression);
          if (t.modelElements != null) 
          { modelElements.addAll(t.modelElements); }
        } 

        return "  error " + t.toKM3(); 
      }
      else if (terms.size() > 2 && "if".equals(terms.get(0) + ""))
      { // (statement if expr stat1 else stat2) 
        // (statement if expr stat1)

        ASTTerm texpr = (ASTTerm) terms.get(1);
        String res = "    if " + texpr.toKM3() + " then ";
        if (terms.size() > 4 && 
            "else".equals(((ASTTerm) terms.get(3)).literalForm()))
        { ASTTerm ifPart = (ASTTerm) terms.get(2); 
          ASTTerm elsePart = (ASTTerm) terms.get(4);
          res = res + ifPart.toKM3() + "\n"; 
          res = res + "    else (\n"; 
          res = res + "      " + elsePart.toKM3() + "\n" + 
                      "    ) ";

          if (texpr.expression != null && 
              ifPart.statement != null && 
              elsePart.statement != null)
          { texpr.expression.setType(
              new Type("boolean", null)); 
            statement = 
              new ConditionalStatement(texpr.expression,
                       ifPart.statement, elsePart.statement); 
            elsePart.statement.setBrackets(true); 
            if (ifPart.modelElements != null) 
            { modelElements.addAll(ifPart.modelElements); }
            if (elsePart.modelElements != null) 
            { modelElements.addAll(elsePart.modelElements); }
          } 
 
          return res; 
        } 
  
        for (int i = 2; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          res = res + "  " + tt.toKM3();
        } 

        if (terms.size() == 3) // no else
        { res = res + "  else skip"; 

          ASTTerm ifPart = (ASTTerm) terms.get(2); 
          if (texpr.expression != null && 
              ifPart.statement != null)
          { InvocationStatement skip = new InvocationStatement("skip"); 
            texpr.expression.setType(
              new Type("boolean", null)); 
            statement = 
              new ConditionalStatement(texpr.expression,
                       ifPart.statement, skip); 
            if (ifPart.modelElements != null) 
            { modelElements.addAll(ifPart.modelElements); }
          } 
        } 

        return res; 
      } 
      else if (terms.size() > 2 && "try".equals(terms.get(0) + ""))
      { ASTTerm tbody = (ASTTerm) terms.get(1);
        String res = "  try " + tbody.toKM3() + "\n";

        if (tbody.statement != null) 
        { statement = new TryStatement(tbody.statement); } 
        else 
        { statement = new TryStatement(new SequenceStatement()); } 

        int clausesStart = 2; 

        if (tbody.hasTag("resourceSpecification"))
        { ASTTerm ttbody = (ASTTerm) terms.get(2); 
          res = res + "    " + ttbody.toKM3();
          ((TryStatement) statement).addBody(ttbody.statement); 
          clausesStart = 3; 
        } 

        for (int i = clausesStart; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          res = res + "    " + tt.toKM3();
          System.out.println(">>> Statement of " + tt + " is: " + tt.statement); 
          System.out.println(); 

          if (statement != null && tt.statement != null)
          { ((TryStatement) statement).addClause(tt.statement); } 
        } 
        return res; 
      } 
      else if (terms.size() > 2 && "switch".equals(terms.get(0) + ""))
      { // (statement switch expr 
        //  { (switchBlockStatementGroup switchLabel* blockStatement*)* }
 
        Vector stats = new Vector(); 

        ASTTerm ttest = (ASTTerm) terms.get(1);
        String etest = ttest.toKM3();
          
        String res = "  for _i : Integer.subrange(1,1) do (\n";
        res = res + caseStatementstoKM3(etest,ttest.expression,terms,stats); 
        res = res + "  )\n";

        BasicExpression ivar = new BasicExpression("_i"); 
        ivar.setType(new Type("int", null)); 
        BasicExpression unit = new BasicExpression(1); 
        Vector pars = new Vector(); 
        pars.add(unit); 
        pars.add(unit); 
        BasicExpression rng = 
          BasicExpression.newFunctionBasicExpression(
            "subrange", "Integer", pars);
        Type intseqType = new Type("Sequence", null);
        intseqType.setElementType(new Type("int", null)); 
        rng.setType(intseqType);  

        Expression tst = new BinaryExpression(":", ivar, rng); 
        tst.setType(new Type("boolean", null)); 

        Statement body = new SequenceStatement(stats); 
        body.setBrackets(true); 
        statement = new WhileStatement(tst,body);  
        ((WhileStatement) statement).setLoopKind(Statement.FOR); 
        ((WhileStatement) statement).setLoopRange(ivar,rng);
        
        return res; 
      } 
      else if (terms.size() > 2 && 
               "while".equals(terms.get(0) + ""))
      { ASTTerm texpr = (ASTTerm) terms.get(1);
        String tst = texpr.queryForm();

        WhileStatement ws = new WhileStatement();

        Expression test = texpr.expression; 

        if (texpr.isBoolean()) { } 
        else if (test != null) 
        { Expression teststring = 
            new BinaryExpression("+", test, emptyString); 
          teststring.setBrackets(true); 
          test = new UnaryExpression(
                         "->toBoolean", test); 
        } 
      
        if (texpr.expression != null) 
        { texpr.expression.setType(
              new Type("boolean", null)); 
          ws.setTest(test); 
        } 

        SequenceStatement body = new SequenceStatement(); 

        String bdy = ""; 

        for (int i = 2; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          String bstat = tt.toKM3(); 
          if (tt.statement != null) 
          { body.addStatement(tt.statement); 
            if (tt.modelElements != null) 
            { modelElements.addAll(tt.modelElements); }
          } 

          bdy = bdy + "    " + bstat;
        } 

        // System.out.println("+++ While test: " + test); 
        // JOptionPane.showInputDialog("+++ While test " + test + " side effect: " + texpr.hasSideEffect() + " | " + texpr.preSideEffect() + " | " + texpr.postSideEffect()); 

        String pse = ""; 
        if (texpr.hasSideEffect())
        { pse = texpr.preSideEffect(); 
          if (texpr.statement != null) 
          { body.addStatement(texpr.statement); 
            bdy = bdy + " ; " + pse;
            pse = pse + " ; "; 
            statement = new SequenceStatement(); 
            ((SequenceStatement) statement).addStatement(
                                       texpr.statement);
            ((SequenceStatement) statement).addStatement(ws);
          }    
          else 
          { pse = texpr.postSideEffect(); 
            if (texpr.statement != null) 
            { body.addStatement(0,texpr.statement);
              body.setBrackets(true);  
              bdy = pse + " ; " + bdy;
              statement = ws;
            }
          } 
        } 
        else 
        { statement = ws; } 

        body.setBrackets(true); 
        ws.setBody(body); 

        String res = pse + "  while " + test + 
                     "\n    do\n  " + bdy + "\n";


        // JOptionPane.showInputDialog(">>*** While body: " + statement); 

        return res; 
      } 
      else if (terms.size() > 3 && "do".equals(terms.get(0) + ""))
      { // do code while (expr);
        // Same as: repeat code until not(expr)

        ASTTerm stat = (ASTTerm) terms.get(1);
        String statcode = stat.toKM3();  
        ASTTerm texpr = (ASTTerm) terms.get(3);

        if (texpr.hasSideEffect())
        { SequenceStatement loopBody = new SequenceStatement(); 
          String pse = texpr.preSideEffect(); 
          loopBody.addStatement(stat.statement); 
          loopBody.addStatement(texpr.statement); 
          String dotest = texpr.queryForm(); 
          texpr.expression.setType(
                   new Type("boolean", null)); 
          loopBody.setBrackets(true); 
          Expression invtest = 
            new UnaryExpression("not", texpr.expression); 
          invtest.setType(
                   new Type("boolean", null)); 

          statement = 
             new WhileStatement(invtest,loopBody);
          ((WhileStatement) statement).setLoopKind(Statement.REPEAT); 
 
          // statement = new SequenceStatement(); 
          // ((SequenceStatement) statement).addStatement(loopBody); 
          // ((SequenceStatement) statement).addStatement(loop); 
          String resx =  
            "  repeat\n"  + 
            "    ( " + statcode + "; \n  " + pse + "  )\n" + 
            "  until not(" + dotest + ")\n"; 
          return resx; 
        } 

        String dotest = texpr.queryForm(); 
          
        if (texpr.expression != null && stat.statement != null) 
        { texpr.expression.setType(
                   new Type("boolean", null)); 
          Expression invtest = 
            new UnaryExpression("not", texpr.expression); 
          invtest.setType(
                   new Type("boolean", null)); 

          stat.statement.setBrackets(true); 
          statement = new WhileStatement(invtest,stat.statement);  
          ((WhileStatement) statement).setLoopKind(Statement.REPEAT); 
          // System.out.println(">>> Repeat statement: " + statement); 

          return "  repeat\n"  + 
            "    " + statcode + "\n" + 
            "  until " + invtest + "\n";
        } 

        String res =  
          "  while true do (" + statcode + " ;\n" + 
          "    if " + dotest + " then skip else break)\n"; 
        return res; 
      } 
      else if (terms.size() > 2 && "for".equals(terms.get(0) + ""))
      { ASTCompositeTerm forControl = (ASTCompositeTerm) terms.get(2);
        ASTTerm forTst = forControl.forTest(); 
        ASTTerm forIni = forControl.forInit(); 
        ASTTerm forInc = forControl.forIncr(); 

        String tst = forControl.toKM3Test(); 
        String init = forControl.toKM3Init(); 
        String incr = forControl.toKM3Incr();

        // JOptionPane.showInputDialog("for test: " + forTst + " " + forTst.expression + " / " + forIni + " " + init + " / " + forInc + " " + incr); 

        if (forTst != null && forTst.expression == null) 
        { forTst.expression = new BasicExpression(true); } 

        /* if (forIni != null) 
        { System.out.println("+++ For init: " + forIni.statement); } 

        if (forInc != null)
        { System.out.println("+++ For incr: " + forInc.statement); } */  
 
		
        String loopKind = "while"; 
        if (forControl.isEnhancedForControl())
        { loopKind = "for"; // type of variable from test
          if (forTst.expression instanceof BinaryExpression &&
              ":".equals(((BinaryExpression) forTst.expression).getOperator()))
          { BinaryExpression betest = 
              (BinaryExpression) forTst.expression;
            ASTTerm.setType(betest.getLeft()+"", 
              betest.getRight().getElementType() + ""); 
          }  
        } 
        // System.out.println("+++ Loop statement of kind " + loopKind); 

        statement = new SequenceStatement(); 
        SequenceStatement lBody = new SequenceStatement(); 
          
        if (forIni != null && forIni.statement != null) 
        { ((SequenceStatement) statement).addStatement(forIni.statement); 
        } 

        Statement testStatement = null;
        boolean preside = false; 

        if (forTst != null && forTst.hasSideEffect())
        { forTst.preSideEffect(); 
          testStatement = forTst.statement;
          if (testStatement != null) 
          { ((SequenceStatement) statement).addStatement(
                                              testStatement); 
            preside = true; 
          } // and at end of loopBody
          else 
          { forTst.postSideEffect(); 
            testStatement = forTst.statement;
            if (testStatement != null) 
            { lBody.addStatement(testStatement); } 
          } 
        }
        // else if (forTst != null) 
        // { tst = forTst.queryForm(); } 
		
		 
        for (int i = 4; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          // res = res + "  " + tt.toKM3();
          tt.toKM3(); 
          if (tt.statement != null) 
          { lBody.addStatement(tt.statement); }
          if (tt.modelElements != null) 
          { modelElements.addAll(tt.modelElements); }
        } // but could be empty. Also, any continue
          // must be preceded by incr, if you change
          // for to while.  
		
        if (incr != null && forInc != null) 
        { forControl.toKM3Incr(); }   

        if (incr != null && forInc != null && 
            forInc.statement != null) 
        { lBody.addStatement(forInc.statement); }

        if (preside && testStatement != null) 
        { lBody.addStatement(testStatement); } 

        lBody.setBrackets(true); 

        if (loopKind.equals("while") &&
            ((SequenceStatement) statement).notEmpty() &&
            forTst != null &&  
            forTst.expression != null) 
        { forTst.expression.setType(
                  new Type("boolean", null)); 
          WhileStatement ws = 
                  new WhileStatement(forTst.expression, lBody); 
          ((SequenceStatement) statement).addStatement(ws); 
        } 
        else if (loopKind.equals("for") && 
              forTst != null && 
              ((SequenceStatement) statement).notEmpty() &&
              forTst.expression != null) 
        { forTst.expression.setType(
                                new Type("boolean", null)); 
          WhileStatement ws = 
              new WhileStatement(forTst.expression, lBody);
          ws.setLoopKind(Statement.FOR);  
          ws.setLoopRange(forTst.expression);
          ((SequenceStatement) statement).addStatement(ws); 
        } 
        else // no initialisation or test statement
        if (loopKind.equals("while") && 
            forTst != null &&  
            forTst.expression != null) 
        { forTst.expression.setType(
              new Type("boolean", null)); 
          statement = 
              new WhileStatement(forTst.expression, lBody); 
        } 
        else if (loopKind.equals("for") && 
              forTst != null &&  
              forTst.expression != null) 
        { forTst.expression.setType(
                                   new Type("boolean", null)); 
          statement = 
              new WhileStatement(forTst.expression, lBody); 
          ((WhileStatement) statement).setLoopKind(Statement.FOR);  
          ((WhileStatement) statement).setLoopRange(forTst.expression);
        } 

        // JOptionPane.showInputDialog(">>*** for body: " + statement); 
    
        return "" + statement; 
      } 
      else if (terms.size() >= 3 && ":".equals(terms.get(1) + ""))
      { // label : stat ...
        // If label is not operation of currentClass, add it as 
        // operation with parameters those vars with owner = null
        // and code all remaining code to end of currentOp

        ASTTerm stat = (ASTTerm) terms.get(2); 
        String resx = stat.toKM3();
        statement = stat.statement; 
        if (stat.modelElements != null) 
        { modelElements.addAll(stat.modelElements); }
          
        return resx;  
      } 
      else if (terms.size() == 3 && 
               "assert".equals(terms.get(0) + ""))
      { ASTTerm expr = (ASTTerm) terms.get(1);
        String res = "  assert " + expr.toKM3(); 
        if (expr.expression != null) 
        { statement = new AssertStatement(expr.expression); } 
        return res; 
      } 
      else if (terms.size() > 3 && 
               "assert".equals(terms.get(0) + ""))
      { ASTTerm expr = (ASTTerm) terms.get(1);
        ASTTerm mess = (ASTTerm) terms.get(3);
        String res = "  assert " + expr.toKM3() + " do " + mess.toKM3(); 
        if (expr.expression != null && mess.expression != null) 
        { statement = 
            new AssertStatement(expr.expression, mess.expression); 
        } 
        return res; 
      } 
      else if (terms.size() > 2 && 
               "return".equals(terms.get(0) + ""))
      { ASTTerm texpr = (ASTTerm) terms.get(1);
        String res = "  return " + texpr.toKM3() + " "; 

        if (texpr.hasSideEffect()) // preSide
        { String qf = texpr.queryForm(); 
          Statement stat2 = new ReturnStatement(texpr.expression); 
          String pse = texpr.preSideEffect(); 
          if (pse == null || texpr.statement == null) 
          { statement = stat2; 
            res = "    return " + qf + " "; 
          } 
          else // assume texpr.expression != null
          { statement = new SequenceStatement(); 
            ((SequenceStatement) statement).addStatement(texpr.statement); 
            ((SequenceStatement) statement).addStatement(stat2); 
            res = pse + " ;\n" + 
                  "    return " + qf + " ";
          } 
        } 
        else if (texpr.expression != null) 
        { statement = new ReturnStatement(texpr.expression); } 

        if (modelElements == null) 
        { modelElements = new Vector(); } 

        if (texpr.modelElements != null)
        { modelElements.addAll(texpr.modelElements); } 

        System.out.println(); 
        System.out.println(">>> model elements of " + res + ": " + modelElements); 

        return res; 
      } 
      else if (terms.size() > 0 && "return".equals(terms.get(0) + ""))
      { statement = new ReturnStatement(); 

        return "  return "; 
      } 
      else if (terms.size() == 2 && 
               "continue".equals(terms.get(0) + "") && 
               ";".equals(terms.get(1) + ""))
      { statement = new ContinueStatement(); 

        return "  continue "; 
      } 
      else if (terms.size() >= 3 && 
               "continue".equals(terms.get(0) + "") && 
               ";".equals(terms.get(2) + ""))
      { String lbl = terms.get(1) + "";
        ModelElement mm = ModelElement.lookupByName(lbl,
                               ASTTerm.functionsInScope); 

        String parstring = ""; 

        if (mm instanceof BehaviouralFeature) 
        { BehaviouralFeature bf = (BehaviouralFeature) mm; 
          BasicExpression becall = 
            new BasicExpression(bf);
          if (bf.hasReturnValue())
          { statement = new ReturnStatement(becall); } 
          else  
          { statement = new InvocationStatement(becall); }
          parstring = bf.parametersString();  
        } 
        else 
        { BasicExpression becall = 
            BasicExpression.newCallBasicExpression(lbl); 
          statement = new InvocationStatement(becall); 
        } 

        return "  " + lbl + "(" + parstring + ")"; 
      } 
      else if (terms.size() == 2 && 
               "break".equals(terms.get(0) + ""))
      { statement = new BreakStatement(); 

        return "  break "; 
      }
      else if (terms.size() >= 3 && 
               "break".equals(terms.get(0) + "") && 
               ";".equals(terms.get(2) + ""))
      { String lbl = terms.get(1) + "";
        ModelElement mm = ModelElement.lookupByName(lbl,
                               ASTTerm.functionsInScope); 

        if (mm instanceof BehaviouralFeature) 
        { BehaviouralFeature bf = (BehaviouralFeature) mm; 
          BasicExpression becall = 
            new BasicExpression(bf);
          if (bf.hasReturnValue())
          { statement = new ReturnStatement(becall); } 
          else  
          { statement = new InvocationStatement(becall); } 
        } 
        else 
        { BasicExpression becall = 
            new BasicExpression(lbl); 
          statement = new InvocationStatement(becall); 
        } 

        return "  " + lbl + "()"; 
      } 
      else if (terms.size() == 2) // expression statement
      { ASTTerm t = (ASTTerm) terms.get(0);

        System.out.println(">>> Expression statement: execute " + t); 

        if (t.isAssignment()) 
        { String res = "  " + t.toKM3Assignment();
          statement = t.statement;
          if (t.modelElements != null) 
          { modelElements.addAll(t.modelElements); }

          return res; 
        } 
        
        if (t.isCreation())
        { t.toKM3creation(); 
          statement = t.statement; 
          if (t.modelElements != null) 
          { modelElements.addAll(t.modelElements); }
          return "    " + statement; 
        } 

        String rs = t.toKM3(); // update form of expression
        statement = t.statement;
        if (t.modelElements != null) 
        { modelElements.addAll(t.modelElements); }

        System.out.println(">>> Statement of expression statement " + t.literalForm() + " is " + statement); 
        System.out.println(">>> Modelelements of expression statement are " + modelElements); 
        
        System.out.println();  
        return "  " + rs; 
      }

      if (terms.size() == 3 && 
          "synchronized".equals(terms.get(0) + ""))
      { ASTTerm t = (ASTTerm) terms.get(2); 
        String res = t.toKM3();
        statement = t.statement; 
        return res;  
      } 

      if (terms.size() == 1) // Single statement
      { ASTTerm t = (ASTTerm) terms.get(0); 
        String res = t.toKM3();
        statement = t.statement; 
        return res;  
      }  
    }  

    if ("catchClause".equals(tag))
    { int cn = terms.size(); 
      if (cn < 4) 
      { return ""; } 

      ASTTerm ctest = (ASTTerm) terms.get(cn-4); 
      ASTTerm cvar = (ASTTerm) terms.get(cn-3); 
      ASTTerm cbody = (ASTTerm) terms.get(cn-1);

      String catchType = ctest.toKM3();
      String catchVar = cvar.toKM3(); 
      String catchBody = cbody.toKM3(); 
  
      if (ctest.expression != null && catchVar != null) 
      { BinaryExpression test = 
          new BinaryExpression(":",  
            BasicExpression.newVariableBasicExpression(
                                           catchVar),
            ctest.expression);
        if (cbody.statement != null) { } 
        else 
        { cbody.statement = new InvocationStatement("skip"); } 
        statement = new CatchStatement(test, cbody.statement);  
      } 

      return "  catch (" + catchVar + " : " + catchType + ") do " + catchBody + "\n"; 
    } 

    if ("catchType".equals(tag))
    { ASTTerm typ = (ASTTerm) terms.get(0); 
      String res = typ.toKM3(); 
      modelElement = typ.modelElement; 
      expression = typ.expression; 
      if (terms.size() > 1 && 
          "|".equals(terms.get(1) + ""))
      { modelElement = new Entity("OclException"); 
        expression = 
          BasicExpression.newTypeBasicExpression(
                                         "OclException");
        res = "OclException";  
      } 

      System.out.println(">>> Expression of " + this + " is " + expression); 

      return res; 
    } 

    if ("finallyBlock".equals(tag))
    { ASTTerm fbody = (ASTTerm) terms.get(1); 
      String fstat = fbody.toKM3(); 

      if (fbody.statement != null) { }
      else 
      { fbody.statement = new InvocationStatement("skip"); } 
      statement = new FinalStatement(fbody.statement);  

      return "    finally " + fstat + "\n"; 
    } 

    if ("switchBlockStatementGroup".equals(tag))
    { // (switchBlockStatementGroup (switchLabel ...)* (blockStatement ...)*

      ASTTerm ctest = (ASTTerm) terms.get(0); 
      if (terms.size() > 1)
      { ASTTerm code = (ASTTerm) terms.get(1); 
        return ctest.toKM3() + " do " + code.toKM3() + "\n";
      }  
      return ctest.toKM3() + " do skip\n";
    } 

    if ("switchLabel".equals(tag))
    { // (switchLabel case expr :)
      // (switchLabel default :)

      if ("case".equals(terms.get(0) + ""))
      { ASTTerm test = (ASTTerm) terms.get(1); 
        // if (terms.size() > 2)
        // { ASTTerm code = (ASTTerm) terms.get(2); 
        //   return "  case " + test.toKM3() + " do " + code.toKM3() + "\n"; 
        // } 
        return "      case " + test.toKM3(); 
        // + " do skip\n"; 
      }
      else if ("default".equals(terms.get(0) + ""))
      { // if (terms.size() > 1)
        // { ASTTerm code = (ASTTerm) terms.get(1); 
        //   return "  endswitch " + code.toKM3() + "\n"; 
        // } 
        return "    endswitch"; // do skip\n"; 
      } 
    }
   
    if ("arrayInitializer".equals(tag))
    { String res = "Sequence{";
      Vector elems = new Vector(); 
 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        res = res + tt.toKM3();
        if (tt.expression != null) 
        { elems.add(tt.expression); } 
      } 
      res = res + "}";
      ASTTerm.setType(this,"Sequence");

      expression = new SetExpression(elems, true); 
  
      return res; 
    } 
      

    if ("resource".equals(tag) && terms.size() > 1)
    { // (resource modifiers type var = expr)

      String res = ""; 
      ASTTerm typeTerm; 
      ASTTerm varTerm;
      ASTTerm initTerm; 

      SequenceStatement sstatements = new SequenceStatement(); 
            
      if (terms.size() >= 4) 
      { typeTerm = (ASTTerm) terms.get(terms.size()-4); 
        varTerm = (ASTTerm) terms.get(terms.size()-3); 
        initTerm = (ASTTerm) terms.get(terms.size()-1); 
      } // ignore modifiers 
      else 
      { typeTerm = (ASTTerm) terms.get(0); 
        varTerm = (ASTTerm) terms.get(1); 
        initTerm = (ASTTerm) terms.get(3); 
      } 


      // String km3type = typeTerm.toKM3();

      String km3type = typeTerm.toKM3type();

      Type actualType = null; 
      if (typeTerm.modelElement instanceof Type)
      { actualType = (Type) typeTerm.modelElement; } 
      else if (typeTerm.modelElement instanceof Entity)
      { actualType = new Type((Entity) typeTerm.modelElement); }
      // Type actualType = (Type) typeTerm.modelElement;
      String km3var = varTerm.toKM3(); 
      String km3init = initTerm.toKM3(); 
      CreationStatement cs = 
        new CreationStatement(km3var,actualType); 
      AssignStatement assgn = 
         new AssignStatement(
               varTerm.expression,initTerm.expression);
      sstatements.addStatement(cs);  
      sstatements.addStatement(assgn); 
      statement = sstatements; 

      // JOptionPane.showInputDialog("Type of " + km3var + " is " + km3type); 

      ASTTerm.setType(km3var, km3type); 

      return "  var " + km3var + " : " + actualType + 
             " := " + km3init + ";\n"; 
    } 

    if ("resources".equals(tag))
    { SequenceStatement sstatements = new SequenceStatement(); 
      String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTSymbolTerm) { } 
        else 
        { res = res + tt.toKM3(); 
          if (tt.statement != null)        
          { sstatements.addStatement(tt.statement); } 
        } 
      } 
      statement = sstatements; 
      return res; 
    } 

    if ("resourceSpecification".equals(tag))
    { SequenceStatement sstatements = new SequenceStatement(); 
      String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTSymbolTerm) { } 
        else 
        { res = res + tt.toKM3(); 
          if (tt.statement != null)        
          { sstatements.addStatement(tt.statement); } 
        } 
      } 
      statement = sstatements; 
      return res; 
    } 


    if ("localVariableDeclaration".equals(tag) && terms.size() > 1)
    { // (localVariableDeclaration type (variableDeclarators ...))
      // (localVariableDeclaration modifiers type (variableDeclarators ...))

      String res = ""; 
      ASTTerm typeTerm; 
      ASTCompositeTerm varTerm;

      modelElements = new Vector(); // The Attributes of the vars
      SequenceStatement sstatements = new SequenceStatement(); 
            
      if (terms.size() >= 3) 
      { typeTerm = (ASTTerm) terms.get(terms.size()-2); 
        varTerm = (ASTCompositeTerm) terms.get(terms.size()-1); 
      } // ignore modifiers 
      else 
      { typeTerm = (ASTTerm) terms.get(0); 
        varTerm = (ASTCompositeTerm) terms.get(1); 
      } 

      String km3type = typeTerm.toKM3type();
      Type actualType = null; 
      if (typeTerm.modelElement instanceof Type)
      { actualType = (Type) typeTerm.modelElement; } 
      else if (typeTerm.modelElement instanceof Entity)
      { actualType = new Type((Entity) typeTerm.modelElement); }

      Vector vardeclarators = varTerm.terms; 
      for (int i = 0; i < vardeclarators.size(); i++) 
      { ASTTerm vTerm = (ASTTerm) vardeclarators.get(i);
        if (vTerm instanceof ASTCompositeTerm)  
        { ASTCompositeTerm tv = (ASTCompositeTerm) vTerm; 
          String km3var = tv.toKM3Var(); 
          String km3init = tv.toKM3VarInit(); 

          Type ctyp = tv.toKM3CollectionType(actualType); 
 
          // if (res.equals("")) { } 
          // else 
          // { res = res + " ; \n  "; } 
 
          // res = res + "var " + km3var + " : " + km3type; 
 
          // if (km3init != null) 
          // { res = res + " := " + km3init; }  

          String fullType = km3type; 
          if (ctyp != null) 
          { fullType = "" + ctyp; } 
            // "Sequence(" + km3type + ")";  
 
          ASTTerm.setType(km3var,fullType);
 
          BasicExpression varbe =
            BasicExpression.newVariableBasicExpression(km3var, 
                         fullType, 
                         ASTTerm.enumtypes, ASTTerm.entities);  
          CreationStatement cs = 
            CreationStatement.newCreationStatement(
                                   km3var, fullType, 
                       ASTTerm.enumtypes, ASTTerm.entities);

          Attribute att = null; 
          Type completeType = actualType; 

          if (actualType != null) 
          { if (ctyp != null) 
            { // completeType = new Type("Sequence", null); 
              // completeType.setElementType(actualType);
              completeType = ctyp;  
            } 

            varbe.setType(completeType); 
            cs.setType(completeType); 
            att = new Attribute(km3var, completeType, 
                                          ModelElement.INTERNAL);
            modelElements.add(att);  
          } 
          sstatements.addStatement(cs); 
           
          System.out.println(">> Type of " + varbe + " is " + varbe.getType());
          System.out.println(); 

          ASTTerm vInit = tv.varInit(); 
          if (vInit != null && vInit.expression != null)
          { AssignStatement initStat = 
              new AssignStatement(varbe,vInit.expression); 
            sstatements.addStatement(initStat);

            if (att != null) 
            { att.setInitialExpression(vInit.expression); }
          
            if (vInit.hasPreSideEffect())
            { String prese = vInit.preSideEffect(); 
              if (vInit.statement != null) 
              { sstatements.addStatement(0, vInit.statement); } 

              /* JOptionPane.showInputDialog(">+++> Pre side-effect of " + vInit + " : " + vInit.statement); */ 
            }

            vInit.statement = null; 

            if (vInit.hasSideEffect())
            { String postse = vInit.postSideEffect(); 

              if (vInit.statement != null) // post side-effect 
              { sstatements.addStatement(tv.statement); } 

             /* JOptionPane.showInputDialog(">+++> Post side-effect: " + tv.statement); */ 
            }
          }

          System.out.println(">+++> Declaration statements: " + statement);
          System.out.println(); 
           
        } 
      }  

      statement = sstatements;
      return statement + ""; 
    }   

    if ("fieldDeclaration".equals(tag) && terms.size() > 1)
    { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
      ASTCompositeTerm varTerm = 
         (ASTCompositeTerm) terms.get(1); 
      if (terms.size() > 3) 
      { typeTerm = (ASTTerm) terms.get(terms.size()-3); 
        varTerm = (ASTCompositeTerm) terms.get(terms.size()-2); 
      } // ignore modifiers 
      
      String km3type = typeTerm.toKM3type();
      // Type vtyp = varTerm.toKM3CollectionType(); 

      Type actualType = null;
      if (typeTerm.modelElement instanceof Type)
      { actualType = (Type) typeTerm.modelElement; } 
      else if (typeTerm.modelElement instanceof Entity)
      { actualType = new Type((Entity) typeTerm.modelElement); } 
 
      String res = ""; 

      Vector vardeclarators = varTerm.terms; 
      for (int i = 0; i < vardeclarators.size(); i++) 
      { ASTTerm vTerm = (ASTTerm) vardeclarators.get(i);
        if (vTerm instanceof ASTCompositeTerm)  
        { ASTCompositeTerm tv = (ASTCompositeTerm) vTerm; 
          String km3var = tv.toKM3Var(); 
          String km3init = tv.toKM3VarInit(); 
          Type vtyp = tv.toKM3CollectionType(actualType); 
 
          if (res.equals("")) { } 
          else 
          { res = res + " ;\n"; } 

          String fullType = km3type; 
          if (vtyp != null)
          { fullType = "" + vtyp; } 
            // "Sequence(" + km3type + ")";  
 
          res = res + "  attribute " + km3var + " : " + fullType; 
 
          if (km3init != null) 
          { res = res + " := " + km3init; }  

          ASTTerm.setType(km3var,fullType);

      // String km3var = varTerm.toKM3Var(); 
      // String km3init = varTerm.toKM3VarInit(); 
      // String res = "  attribute " + km3var + " : " + km3type; 
      // if (km3init != null) 
      // { res = res + " := " + km3init; }  
      // ASTTerm.setType(km3var,km3type);
          Attribute att = Attribute.newAttribute(
            km3var, fullType, ASTTerm.enumtypes, ASTTerm.entities); 

          if (actualType != null) 
          { 
            if (vtyp != null) 
            { Type seqType = vtyp; // new Type("Sequence", null); 
              // seqType.setElementType(actualType); 
              att.setType(seqType); 
              att.setElementType(seqType.getElementType()); 
            }
            else 
            { att.setType(actualType); 
              att.setElementType(actualType.getElementType());  
            } 
          }
    
          if (tv.expression != null) 
          { att.setInitialExpression(tv.expression); }
 
        // if (varTerm.expression != null) 
        // { att.setInitialExpression(varTerm.expression); }

          modelElement = att;  
          if (modelElements == null) 
          { modelElements = new Vector(); } 
          modelElements.add(att); 

      // but can be several attributes: 
      // (variableDeclarators (variableDeclarator ...) , ...) 

          System.out.println(">> Type of " + km3var + " is " + fullType + " = " + km3init); 
          System.out.println(">> Attribute = " + att + " " + att.getType() + " (" + att.getElementType() + ")"); 
          System.out.println(">> Initialisation = " + att.getInitialExpression());
        }  
      } 

      System.out.println(); 
      return res + " ; \n"; 
    }   

    if ("constDeclaration".equals(tag) && terms.size() > 1)
    { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
      String km3type = typeTerm.toKM3type();
      Type actualType = null; 
      if (typeTerm.modelElement instanceof Type)
      { actualType = (Type) typeTerm.modelElement; } 
      else if (typeTerm.modelElement instanceof Entity)
      { actualType = new Type((Entity) typeTerm.modelElement); } 
 
      String res = ""; 

      Vector vardeclarators = new Vector(); 
      vardeclarators.addAll(terms);
      vardeclarators.remove(0); 
 
      for (int i = 0; i < vardeclarators.size(); i++) 
      { ASTTerm vTerm = (ASTTerm) vardeclarators.get(i);
        if (vTerm instanceof ASTCompositeTerm)  
        { ASTCompositeTerm tv = (ASTCompositeTerm) vTerm; 
          String km3var = tv.toKM3Var(); 
          String km3init = tv.toKM3VarInit(); 
 
          if (res.equals("")) { } 
          else 
          { res = res + " ;\n"; } 
 
          res = res + "  attribute " + km3var + " : " + km3type; 
 
          if (km3init != null) 
          { res = res + " := " + km3init; }  

          
          ASTTerm.setType(km3var,km3type);

          Attribute att = Attribute.newAttribute(
            km3var, km3type, 
            ASTTerm.enumtypes, ASTTerm.entities); 

          if (actualType != null) 
          { att.setType(actualType); 
            att.setElementType(actualType.getElementType()); 
          }
    
          if (tv.expression != null) 
          { att.setInitialExpression(tv.expression); }
 
        // if (varTerm.expression != null) 
        // { att.setInitialExpression(varTerm.expression); }

          att.setFrozen(true); 

          modelElement = att;  
          if (modelElements == null) 
          { modelElements = new Vector(); } 
          modelElements.add(att); 

      // but can be several attributes: 
      // (variableDeclarators (variableDeclarator ...) , ...) 

          System.out.println(">> Type of " + km3var + " is " + km3type + " = " + km3init); 
          System.out.println(">> Attribute = " + att + " " + att.getType() + " (" + att.getElementType() + ")"); 
          System.out.println(">> Initialisation = " + att.getInitialExpression());
        }  
      } 
      System.out.println(); 
      return res + " ; \n"; 
    }   

    if ("typeType".equals(tag))
    { if (terms.size() == 2 && 
          ((ASTTerm) terms.get(0)).hasTag("annotation"))
      { ASTTerm rest = (ASTTerm) terms.get(1); 
        String resx = rest.toKM3type();
        modelElement = rest.modelElement; 
        expression = rest.expression; 
        return resx;  
      } 

      if (terms.size() >= 3 && 
          "[".equals(terms.get(1) + "") &&
          "]".equals(terms.get(2) + ""))
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        Type elementType = null; 
        if (typeTerm.modelElement instanceof Type)
        { elementType = (Type) typeTerm.modelElement; } 
        else if (typeTerm.modelElement instanceof Entity)
        { elementType = new Type((Entity) typeTerm.modelElement); } 
      

        for (int i = 1; i+1 < terms.size(); i = i + 2) 
        { if ((terms.get(i) + "").equals("[") &&
              (terms.get(i+1) + "").equals("]"))
          { tt = "Sequence(" + tt + ")"; 

            modelElement = new Type("Sequence", null);
            if (elementType != null) 
            { ((Type) modelElement).setElementType(elementType); }
            elementType = (Type) modelElement;   
          } 
        } 
        return tt;  
      } 
      else if (terms.size() == 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement;
        expression = typeTerm.expression; 
        System.out.println(">>> Model element of " + this + " is: " + modelElement); 
        System.out.println(">>> Expression of " + this + " is: " + expression); 
        System.out.println(); 
        return tt; 
      } 
    } 

    if ("typeTypeOrVoid".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement; 
        expression = typeTerm.expression; 
        return tt; 
      } 
    } 

    if ("typeBound".equals(tag))
    { if (terms.size() >= 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement; 
        expression = typeTerm.expression; 
        return tt; 
      } 
    } 

    if ("typeParameters".equals(tag))
    { if (terms.size() == 3 && 
          "<".equals(terms.get(0) + "") && 
          ">".equals(terms.get(2) + "")) 
      { modelElements = new Vector();
        ASTTerm typeTerm = (ASTTerm) terms.get(1); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement;
        if (modelElement == null) // new class
        { modelElement = new Entity(tt); 
          ((Entity) modelElement).setIsParameter(true); 
        }  
        modelElements.add(modelElement); 
         
        return "<" + tt + ">"; 
      } 

      if (terms.size() >= 3 && 
          "<".equals(terms.get(0) + ""))
      { modelElements = new Vector();
        String resx = "<";   
        for (int i = 1; i < terms.size()-1; i++) 
        { ASTTerm trm = (ASTTerm) terms.get(i); 
          if (trm instanceof ASTSymbolTerm) 
          { resx = resx + trm; } 
          else 
          { String tt = trm.toKM3type();
            modelElement = trm.modelElement;
            if (modelElement == null) // new class
            { modelElement = new Entity(tt); 
              ((Entity) modelElement).setIsParameter(true); 
            }  
            modelElements.add(modelElement);
            resx = resx + tt; 
          } 
        }  
        return resx + ">"; 
      } 

      return ""; 
    } 

    if ("typeParameter".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm tt = (ASTTerm) terms.get(0);
        String val = tt.literalForm();  
        modelElement = 
           Type.getTypeFor(val, ASTTerm.enumtypes, 
                           ASTTerm.entities); 

        if (modelElement == null)
        { modelElement = new Type(val, null); }  

        expression = new BasicExpression((Type) modelElement);
  
        return val; 
      } 
      else if (terms.size() >= 3 && 
               "extends".equals(terms.get(1) + ""))
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        String val = tt.literalForm();  
        modelElement = 
           Type.getTypeFor(val, ASTTerm.enumtypes, 
                           ASTTerm.entities); 

        if (modelElement == null)
        { modelElement = new Type(val, null); }  

        expression = new BasicExpression((Type) modelElement);
  
        return val; 
      } // But these should be typeParameter entities
      else if (terms.size() >= 2 && 
               ((ASTTerm) terms.get(0)).hasTag("annotation"))
      { Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        ASTCompositeTerm tailast = 
              new ASTCompositeTerm("typeParameter", tailterms);
        String resx = tailast.toKM3type();
        expression = tailast.expression; 
        modelElement = tailast.modelElement; 
        return resx;  
      } 

      modelElement = new Type("OclAny", null);
      return "OclAny";  
    } 

    if ("classBodyDeclaration".equals(tag) ||
        "interfaceBodyDeclaration".equals(tag))
    { if (terms.size() == 1 && 
          "block".equals(((ASTTerm) terms.get(0)).getTag())) 
      { if (modelElement != null) 
        { return ""; } 
        ASTTerm memberTerm = (ASTTerm) terms.get(0); 
        String blockcode = memberTerm.toKM3();
        String initId = 
          Identifier.nextIdentifier("_initialiseInstance");  
        BehaviouralFeature bf = 
          new BehaviouralFeature(initId); 
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
        bf.setParameters(new Vector()); 
        if (memberTerm.statement != null) 
        { bf.setActivity(memberTerm.statement); } 
        modelElement = bf; 
        modelElements = memberTerm.modelElements; 
        return "  operation " + initId + "()\n" + 
               "  pre: true post: true\n" + 
               "  activity: " + blockcode + ";\n\n";  
      } 
      else if (terms.size() == 1) 
      { ASTTerm memberTerm = (ASTTerm) terms.get(0); 
        String tt = memberTerm.toKM3();
        modelElement = memberTerm.modelElement; 
        modelElements = memberTerm.modelElements; 
        return tt; 
      } 
      else if (terms.size() == 2 && 
               "static".equals(terms.get(0) + "") && 
               ((ASTTerm) terms.get(1)).hasTag("block"))
      { // static block
        if (modelElement != null) 
        { return ""; } 
        ASTTerm stat = (ASTTerm) terms.get(1); 
        String blockcode = stat.toKM3();
        String initId = 
          Identifier.nextIdentifier("_initialiseClass");  
        BehaviouralFeature bf = 
          new BehaviouralFeature(initId); 
        bf.setPre(new BasicExpression(true)); 
        bf.setPost(new BasicExpression(true)); 
        bf.setParameters(new Vector()); 
        bf.setStatic(true); 
        if (stat.statement != null) 
        { bf.setActivity(stat.statement); } 
        modelElement = bf; 
        modelElements = stat.modelElements; 
        return "  static operation " + initId + "()\n" + 
               "  pre: true post: true\n" + 
               "  activity: " + blockcode + ";\n\n"; 
      } 
      else 
      { String res = ""; 
        boolean isStatic = false; 

        for (int i = 0; i < terms.size(); i++) 
        { ASTTerm t = (ASTTerm) terms.get(i); 
          String tt = t.toKM3();
          if (t.modelElement != null) 
          { modelElement = t.modelElement; } 
          if (t.modelElements != null) 
          { modelElements = t.modelElements; }
          if ("static".equals(t.literalForm()))
          { isStatic = true; }  
          res = res + tt; 
        }  

        if (isStatic && modelElement != null)
        { if (modelElement instanceof BehaviouralFeature)
          { ((BehaviouralFeature) modelElement).setStatic(true); }
          else if (modelElement instanceof Attribute)
          { ((Attribute) modelElement).setStatic(true); }
        } 

        return res; 
      } // modifiers before the member
    } 

    if ("memberDeclaration".equals(tag) || "interfaceMemberDeclaration".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm memberTerm = (ASTTerm) terms.get(0); 
        String tt = memberTerm.toKM3();
        modelElement = memberTerm.modelElement;
        modelElements = memberTerm.modelElements;  
        return tt; 
      } 
      else 
      { String res = ""; 
        for (int i = 0; i < terms.size(); i++) 
        { ASTTerm t = (ASTTerm) terms.get(i); 
          String tt = t.toKM3();
          if (t.modelElement != null) 
          { modelElement = t.modelElement; } 
          if (t.modelElements != null) 
          { modelElements = t.modelElements; } 
          res = res + tt; 
        }  
        return res; 
      } // modifiers before the member
    } 

    if ("classOrInterfaceType".equals(tag))
    { // a . b . c ...
      // a 
      // a (typeArguments ...)

      if (terms.size() == 3 && ".".equals(terms.get(1) + ""))  
      { // A relativised type T.S
        ASTTerm baseType = (ASTTerm) terms.get(2); 
        String btype = baseType.toKM3type();
        modelElement = baseType.modelElement; 
        expression = new BasicExpression((Type) modelElement); 
        return btype; 
      }  
      else if (terms.size() > 3 && ".".equals(terms.get(1) + ""))  
      { // A relativised type T.S
        Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        tailterms.remove(0); 

        ASTTerm tailast = 
          new ASTCompositeTerm(
                  "classOrInterfaceType", tailterms);
 
        String resx = tailast.toKM3type();
        modelElement = tailast.modelElement; 
        expression = tailast.expression; 
        return resx; 
      }  
      else if (terms.size() > 1 && 
               terms.get(1) instanceof ASTCompositeTerm && 
               "typeArguments".equals(
                  ((ASTTerm) terms.get(1)).getTag()))  
      { // parameterised type  T (typeArguments < pars >)
        ASTTerm baseType = (ASTTerm) terms.get(0); 
        ASTCompositeTerm typepars = 
             (ASTCompositeTerm) terms.get(1);
        String pars = typepars.toKM3type();
        
        Vector targs = 
          ((ASTCompositeTerm) typepars).getTypeParameterTypes(); 

        System.out.println(); 

        System.out.println(">> Parameterised type with parameters " + targs); 
        System.out.println(); 
 
        String btype = baseType.toKM3type();
        modelElement = baseType.modelElement; 

        System.out.println(">> Base type with parameters " + btype + " " + modelElement);
        System.out.println(); 
 
        expression = baseType.expression; // Not valid

        if ("Class".equals(baseType.literalForm()))
        { modelElement = new Type("OclType", null); 
          return "OclType";
        } 

        if ("Pair".equals(baseType.literalForm()) ||
            "Triple".equals(baseType.literalForm()))
        { modelElement = new Type("Map", null);
          Type ktype = new Type("String", null);  
          Type etype = (Type) targs.get(1); 
          ((Type) modelElement).setKeyType(ktype); 
          ((Type) modelElement).setElementType(etype);
          return "Map(String," + etype + ")"; 
        } 

        if (modelElement != null)
        { if (targs.size() > 1 && 
              modelElement instanceof Type && 
              ((Type) modelElement).isMap()) 
          { Type ktype = (Type) targs.get(0); 
            Type etype = (Type) targs.get(1); 
            ((Type) modelElement).setKeyType(ktype); 
            ((Type) modelElement).setElementType(etype);
          }  
          else if (targs.size() > 1 && 
                   modelElement instanceof Type && 
                   ((Type) modelElement).isFunction()) 
          { Type ktype = (Type) targs.get(0); 
            Type etype = (Type) targs.get(1); 
            ((Type) modelElement).setKeyType(ktype); 
            ((Type) modelElement).setElementType(etype);
          }  
          else if (targs.size() > 0 && 
                   modelElement instanceof Type && 
                   ((Type) modelElement).isCollectionType()) 
          { Type etype = (Type) targs.get(0); 
            ((Type) modelElement).setElementType(etype);
          }  
          else // general parameterised type 
          { ((Type) modelElement).setGenericTypeParameters(targs); }

          expression = new BasicExpression((Type) modelElement); 
          System.out.println(">> Parameterised type: " + modelElement);
          System.out.println(expression); 
          System.out.println(); 
        }  
        return btype + "(" + pars + ")"; 
      }
      else 
      { ASTTerm t0 = (ASTTerm) terms.get(0);
        String res = t0.toKM3();
        modelElement = t0.modelElement;
        expression = t0.expression;  
        return res;  
      } 
    } 
 
    if (tag.equals("typeArgumentsOrDiamond") && terms.size() == 1)
    { ASTTerm tt = (ASTTerm) terms.get(0); 
      String res = tt.typeArgumentsToKM3ElementType();
      modelElement = tt.modelElement;
      modelElements = new Vector(); 
      if (tt.modelElements != null) { modelElements.addAll(tt.modelElements); }  
      return res;   
    } 
    
    if (tag.equals("typeArgumentsOrDiamond") && 
             terms.size() == 2 && 
             "<".equals(terms.get(0) + "") && 
             ">".equals(terms.get(1) + ""))
    { String res = "OclAny";
      modelElement = new Type("OclAny", null);
      modelElements = new Vector(); 
      modelElements.add(modelElement); 
      return res;   
    } 
 
    if ("typeArguments".equals(tag) && terms.size() > 1 && 
        "<".equals(terms.get(0) + ""))
    { // < arg >   or   < arg1 , arg2 >
      modelElements = new Vector(); 
      String res = ""; 
      for (int i = 1; i < terms.size()-1; i++)
      { ASTTerm typepar0 = (ASTTerm) terms.get(i); 
        res = res + typepar0.toKM3type();

        System.out.println(">>> Type parameter: " + typepar0.modelElement); 

        if (typepar0 instanceof ASTSymbolTerm) { } 
        else 
        { modelElement = typepar0.modelElement; 
          if (modelElement != null) 
          { modelElements.add(modelElement); } 
        } 
      } 

      return res; 
    } 

    if ("nonWildcardTypeArguments".equals(tag) && 
        terms.size() > 2)
    { // < typelist >
      ASTTerm typepar0 = (ASTTerm) terms.get(1); 
      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
      modelElements = typepar0.modelElements; 
 
      return res; 
    } 

    if ("typeArgument".equals(tag) && terms.size() > 0)
    { // a (typeType _1)
      ASTTerm typepar0 = (ASTTerm) terms.get(0); 

      if (typepar0.hasTag("annotation"))
      { Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        ASTCompositeTerm tailast = 
          new ASTCompositeTerm("typeArgument", tailterms); 
        String resx = tailast.toKM3type(); 
        modelElement = tailast.modelElement; 
        return resx; 
      } 

      if (terms.size() == 3 && 
          "?".equals(typepar0.literalForm()) && 
          ("extends".equals(terms.get(1) + "") ||
           "super".equals(terms.get(1) + "") ) )
      { typepar0 = (ASTTerm) terms.get(2); } 

      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
 
      return res; 
    } 

    if ("enhancedForControl".equals(tag))
    { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
      ASTTerm varTerm = (ASTTerm) terms.get(1); 
      ASTTerm rangeTerm = (ASTTerm) terms.get(3); 
      // String km3type = typeTerm.toKM3(); 
      String km3var = varTerm.toKM3(); 
      String km3range = rangeTerm.toKM3(); 
      String res = km3var + " : " + km3range; 
      if (varTerm.expression != null && 
          rangeTerm.expression != null) 
      { expression = 
          new BinaryExpression(":", varTerm.expression, 
                               rangeTerm.expression); 
      } 

      // if (km3var != null) 
      // { res = res + " := " + km3init; }  
      return res; 
    }   

    if ("blockStatement".equals(tag))
    { if (terms.size() > 0) 
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        String res = tt.toKM3(); 
        statement = tt.statement; 
        modelElements = tt.modelElements; // for local decs
        System.out.println(); 
        System.out.println(">+>+> model elements of blockStatement " + res +
                           ": " + modelElements); 
        return res; 
      } 
    } 

    if ("block".equals(tag))
    { System.out.println(">> toKM3 Statement block with " + terms.size() + " terms " + terms); 

      if (terms.size() <= 2)
      { statement = new InvocationStatement("skip"); 
        return "skip"; 
      } 
      else if (terms.size() == 3) // Single statement
      { ASTTerm t = (ASTTerm) terms.get(1);
        String stat = t.toKM3(); 

        if (t.statement != null)  
        { statement = new SequenceStatement(); 
          ((SequenceStatement) statement).addStatement(t.statement); 
        }
        modelElements = t.modelElements; 

        return "( " + stat + " )"; 
      } 
      else // (terms.size() >= 2) // Series of statements
      { String res = "";
        int count = 0;  

        statement = new SequenceStatement(); 

        ASTTerm t0 = (ASTTerm) terms.get(0); 

        String prev = t0.toKM3();

        if (t0.statement != null) 
        { ((SequenceStatement) statement).addStatement(t0.statement); }

        if (modelElements == null) 
        { modelElements = new Vector(); } 

        if (t0.modelElements != null)
        { modelElements.addAll(t0.modelElements); } 
  
        for (int i = 1; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          String next = tt.toKM3(); 
          
          if (tt.statement != null) 
          { ((SequenceStatement) statement).addStatement(tt.statement); } 

          if (tt.modelElements != null)
          { modelElements.addAll(tt.modelElements); } 

          if (prev.length() > 0) 
          { res = res + " " + prev; 
            count++; 
          }  

          if (prev.length() > 0 && next.length() > 0)
          { res = res + " ;\n  "; }

          prev = next; 
        }
 
        if (prev.length() > 0) 
        { res = res + " " + prev; 
          count++; 
        }  
          
        if (count > 1) 
        { res = " ( " + res + " )"; }

        System.out.println(">>> Statement block: " + statement); 
        System.out.println(); 
        System.out.println(">>> model elements: " + modelElements); 
 
        return res + " ";  
      } 
    } 

    if ("genericMethodDeclaration".equals(tag) || 
        "genericInterfaceMethodDeclaration".equals(tag))
    { // (typeParameters < (typeParameter T) ... > )
      // (methodDeclaration ...)

      ASTTerm typePars = (ASTTerm) terms.get(0); 
      ASTTerm mDec = (ASTTerm) terms.get(1); 

      String gtype = typePars.toKM3type(); 
      System.out.println(">> Generic types = " + gtype); 

      String met = mDec.toKM3(); 
      modelElement = mDec.modelElement; 

      String res = met; 

      if (modelElement != null && 
          modelElement instanceof BehaviouralFeature)
      { BehaviouralFeature bf = (BehaviouralFeature) modelElement;
        bf.setTypeParameters(typePars.modelElements);
        String bfname = bf.getName();  
        res = met.replace(bfname, bfname + "" + gtype + ""); 
      }  

      for (int i = 0; i < typePars.modelElements.size(); i++)
      { ModelElement partype = 
          (ModelElement) typePars.modelElements.get(i); 
        Entity parEnt = null; 
        if (partype instanceof Type)
        { parEnt = ((Type) partype).getEntity(); } 
        else if (partype instanceof Entity)
        { parEnt = (Entity) partype; } 
 
        if (parEnt != null) 
        { ASTTerm.entities.remove(parEnt); } 
      } 

      return res; 
    } // replace operation name by name<gtype>

    if ("methodDeclaration".equals(tag))
    { ASTTerm mtype = (ASTTerm) terms.get(0); 
      ASTTerm mname = (ASTTerm) terms.get(1);
      ASTTerm mparams = (ASTTerm) terms.get(2); 
      
      BehaviouralFeature bf = 
        new BehaviouralFeature(mname.literalForm()); 

      String restype = mtype.toKM3type(); 
      String res = "  operation " + mname + mparams.toKM3() + " : " + restype  + "\n" + 
              "  pre: true\n" + "  post: true"; 

      System.out.println("+++ return type of " + mname + " is " + mtype.modelElement); 

      if (mtype.modelElement instanceof Type)
      { bf.setType((Type) mtype.modelElement); } 
      else if (mtype.modelElement instanceof Entity)
      { bf.setType(new Type((Entity) mtype.modelElement)); } 
      else if (restype != null) 
      { Type resT = Type.getTypeFor(restype, ASTTerm.enumtypes, ASTTerm.entities); 
        if (resT != null) 
        { bf.setType(resT); } 
      } 

      if (mparams.modelElements != null) 
      { bf.setParameters(mparams.modelElements); } 

      bf.setPrecondition(new BasicExpression(true)); 
      bf.setPostcondition(new BasicExpression(true)); 

      modelElement = bf; 

      modelElements = new Vector(); 
      modelElements.add(bf); 

      if (terms.size() > 3)
      { ASTTerm mbody = (ASTTerm) terms.get(3);

        if ("throws".equals(mbody.literalForm()))
        { mbody = (ASTTerm) terms.get(4); } 

        if (mbody.hasTag("qualifiedNameList"))
        { mbody = (ASTTerm) terms.get(5); } 

        if (";".equals(mbody.literalForm()))
        { if (mtype.modelElement != null && 
              mtype.modelElement instanceof Type) 
          { Expression retval = 
              ((Type) mtype.modelElement).getDefaultValueExpression();
            if (retval == null) 
            { return res + ";\n\n"; } 

            Statement interfacestat = 
              new ReturnStatement(retval); 
            bf.setActivity(interfacestat);  
            return res + "\n  activity: return " + retval + ";\n\n"; 
          } 
          return res + ";\n\n"; 
        }
  
        res = res + "\n  activity:\n"; 

        Vector labelfunctions = new Vector(); 

        for (int i = 3; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i);

          if (tt.hasTag("methodBody") && 
              tt instanceof ASTCompositeTerm)
          { boolean haslfs = 
               ((ASTCompositeTerm) tt).hasJavaLabelFunctions(bf);
            if (haslfs)
            { labelfunctions = 
               ((ASTCompositeTerm) tt).javaLabelFunctions(bf);
              System.out.println(">>> Operation " + bf + " has label functions " + labelfunctions);
              modelElements.addAll(labelfunctions);
              ASTTerm.functionsInScope = new Vector(); 
              ASTTerm.functionsInScope.addAll(labelfunctions); 
            }  
          } 

          if ("throws".equals(tt.literalForm()))
          { i++; } 
          else if (tt.hasTag("qualifiedNameList"))
          { i++; } 
          else if (tt.hasTag("methodBody")) 
          { res = res + "    " + tt.toKM3() + "\n"; 
            if (tt.statement != null)
            { bf.setActivity(tt.statement);
               
              System.out.println(">>> Operation " + bf + " has activity " + tt.statement); 
              System.out.println(); 
            } 
    
            if (tt.modelElements != null) 
            { for (int p = 0; p < tt.modelElements.size(); p++) 
              { if (tt.modelElements.get(p) instanceof Entity)
                { modelElements.add(tt.modelElements.get(p)); } 
              } 
            }
            
            System.out.println(">>> Operation " + bf + " has model elements " + modelElements); 
          }  
        }
      }  

      return res + "  ;\n\n"; 
    }

    if ("interfaceMethodDeclaration".equals(tag))
    { ASTTerm genericpars = null; 
      boolean isStatic = false; 
      int defstart = 0; 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm.hasTag("interfaceMethodModifier")) 
        { if ("static".equals(trm + ""))
          { isStatic = true; } 
          defstart = i+1; 
        } 
        else if (trm.hasTag("typeParameters"))
        { genericpars = trm; 
          defstart = i+1; 
        }
        else if (trm.hasTag("annotation"))
        { defstart = i+1; } 
        else 
        { break; } 
      } 

      ASTTerm mtype = (ASTTerm) terms.get(defstart); 
      ASTTerm mname = (ASTTerm) terms.get(defstart + 1);
      ASTTerm mparams = (ASTTerm) terms.get(defstart + 2); 
      
      BehaviouralFeature bf = 
        new BehaviouralFeature(mname.literalForm()); 

      String restype = mtype.toKM3type(); 
      String res = "  operation " + mname + mparams.toKM3() + " : " + restype  + "\n" + 
              "  pre: true\n" + "  post: true"; 

      System.out.println("+++ return type of " + mname + " is " + mtype.modelElement); 

      if (mtype.modelElement instanceof Type)
      { bf.setType((Type) mtype.modelElement); } 
      else if (mtype.modelElement instanceof Entity)
      { bf.setType(new Type((Entity) mtype.modelElement)); } 
      else if (restype != null) 
      { Type resT = Type.getTypeFor(restype, ASTTerm.enumtypes, ASTTerm.entities); 
        if (resT != null) 
        { bf.setType(resT); } 
      } 

      if (mparams.modelElements != null) 
      { bf.setParameters(mparams.modelElements); } 

      if (genericpars != null) 
      { genericpars.toKM3type(); 
        if (genericpars.modelElements != null) 
        { bf.setTypeParameters(genericpars.modelElements); } 
      } 

      bf.setPrecondition(new BasicExpression(true)); 
      bf.setPostcondition(new BasicExpression(true)); 

      bf.setStatic(isStatic); 

      modelElement = bf; 

      modelElements = new Vector(); 
      modelElements.add(bf); 

      if (terms.size() > defstart + 3)
      { ASTTerm mbody = (ASTTerm) terms.get(defstart + 3);

        if ("throws".equals(mbody.literalForm()))
        { mbody = (ASTTerm) terms.get(defstart + 4); } 

        if (mbody.hasTag("qualifiedNameList"))
        { mbody = (ASTTerm) terms.get(defstart + 5); } 

        if (";".equals(mbody.literalForm()))
        { if (mtype.modelElement != null && 
              mtype.modelElement instanceof Type) 
          { Expression retval = 
              ((Type) mtype.modelElement).getDefaultValueExpression();
            if (retval == null) 
            { return res + ";\n\n"; } 

            Statement interfacestat = 
              new ReturnStatement(retval); 
            bf.setActivity(interfacestat);  
            return res + "\n  activity: return " + retval + ";\n\n"; 
          } 
          return res + ";\n\n"; 
        }
  
        res = res + "\n  activity:\n"; 

        Vector labelfunctions = new Vector(); 

        for (int i = defstart + 3; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i);

          if (tt.hasTag("methodBody") && tt instanceof ASTCompositeTerm)
          { boolean lfs = 
              ((ASTCompositeTerm) tt).hasJavaLabelFunctions(bf);
            if (lfs) 
            { labelfunctions = 
                ((ASTCompositeTerm) tt).javaLabelFunctions(bf);
              System.out.println(">>> Operation " + bf + " has label functions " + labelfunctions);
              modelElements.addAll(labelfunctions);
              ASTTerm.functionsInScope = new Vector(); 
              ASTTerm.functionsInScope.addAll(labelfunctions);
            }   
          } 

          if ("throws".equals(tt.literalForm()))
          { i++; } 
          else if (tt.hasTag("qualifiedNameList"))
          { i++; } 
          else if (tt.hasTag("methodBody")) 
          { res = res + "    " + tt.toKM3() + "\n"; 
            if (tt.statement != null)
            { bf.setActivity(tt.statement);
               
              System.out.println(">>> Operation " + bf + " has activity " + tt.statement); 
              System.out.println(); 
            } 
    
            if (tt.modelElements != null) 
            { for (int p = 0; p < tt.modelElements.size(); p++) 
              { if (tt.modelElements.get(p) instanceof Entity)
                { modelElements.add(tt.modelElements.get(p)); } 
              } 
            }
            
            System.out.println(">>> Operation " + bf + " has model elements " + modelElements); 
          }  
        }
      }  

      return res + "  ;\n\n"; 
    }

    if ("methodBody".equals(tag))
    { ASTTerm code = (ASTTerm) terms.get(0); 
      String res = code.toKM3();
      statement = code.statement;
      modelElements = new Vector(); 
      if (code.modelElements != null) 
      { for (int p = 0; p < code.modelElements.size(); p++) 
        { if (code.modelElements.get(p) instanceof Entity)
          { modelElements.add(code.modelElements.get(p)); } 
        } 
      } 
      return res; 
    }

    if ("classBody".equals(tag) ||
        "interfaceBody".equals(tag))
    { modelElements = new Vector();
      String res = ""; 
  
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        res = res + t.toKM3(); 
        if (t.modelElement != null && t.modelElements == null) 
        { modelElements.add(t.modelElement); }
        else if (t.modelElements != null) 
        { modelElements.addAll(t.modelElements); }  
      } 
      return res; 
    } // WARNING: major revision above. 
         

    if ("constructorDeclaration".equals(tag))
    { ASTTerm mname = (ASTTerm) terms.get(0);
      ASTTerm mparams = (ASTTerm) terms.get(1); 
      String cname = mname.literalForm(); 
      Entity cent = (Entity)
          ModelElement.lookupByName(cname, 
                                    ASTTerm.entities); 
    
      String res = "\n  static operation new" + cname + mparams.toKM3() + " : " + cname + "\n" + 
              "  pre: true\n" + "  post: true\n"; 
      res = res + 
          "  activity:\n" + 
          "  ( var result : " + cname + " := create" + cname + "() ;\n" +  
          "    result.initialise(" +  getParNameList(mparams) + ") ;\n" + 
          "    return result );\n\n"; 
   
      BehaviouralFeature constr = 
        BehaviouralFeature.newConstructor(cname, cent,
                                 mparams.modelElements); 
      constr.setStatic(true); 
 
      res = res + "  operation initialise" + mparams.toKM3() + " : void\n" + 
              "  pre: true\n" + "  post: true\n"; 

      SequenceStatement initCode = new SequenceStatement(); 
      
      if (terms.size() > 2)
      { res = res + 
          "  activity:\n";  
        for (int i = 2; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          res = res + "   " + tt.toKM3();

          if (tt.statement != null) 
          { initCode.addStatement(tt.statement); } 

          if (i < terms.size() - 1) 
          { res = res + "\n"; }
          else 
          { res = res + " ;\n"; }  
        }
      }  

      BehaviouralFeature bfInit = new BehaviouralFeature("initialise"); 
      bfInit.setParameters(mparams.modelElements); 
      bfInit.setActivity(initCode); 
      bfInit.setPrecondition(new BasicExpression(true)); 
      bfInit.setPostcondition(new BasicExpression(true)); 
      // modelElement = bfInit; 

      modelElements = new Vector(); 
      modelElements.add(bfInit); 
      modelElements.add(constr); 

      if (cent != null && cent.getSuperclass() != null) 
      { Entity supent = cent.getSuperclass(); 
        BehaviouralFeature overriddenOp = 
           supent.getDefinedOperation("initialise", 
                                      mparams.modelElements); 
        if (overriddenOp != null) 
        { bfInit.addStereotype("override"); } 
      } 

      return res + "\n\n"; 
    }

    if ("genericConstructorDeclaration".equals(tag))
    { ASTTerm gpars = (ASTTerm) terms.get(0); 
      ASTCompositeTerm consdef = 
           (ASTCompositeTerm) terms.get(1); 

      ASTTerm mname = (ASTTerm) consdef.terms.get(0);
      ASTTerm mparams = (ASTTerm) consdef.terms.get(1);
 
      String cname = mname.literalForm(); 
      Entity cent = (Entity)
          ModelElement.lookupByName(cname, 
                                    ASTTerm.entities); 
    
      String gpartext = gpars.toKM3();

      System.out.println("*** Generic constructor type parameters: " + gpartext + " " + gpars.modelElements);  

      String res = "\n  static operation new" + cname + gpartext + mparams.toKM3() + " : " + cname + gpartext + "\n" + 
              "  pre: true\n" + "  post: true\n"; 
      res = res + 
          "  activity:\n" + 
          "  ( var result : " + cname + gpartext + " := create" + cname + gpartext + "() ;\n" +  
          "    result.initialise(" +  getParNameList(mparams) + ") ;\n" + 
          "    return result );\n\n"; 
   
      BehaviouralFeature constr = 
        BehaviouralFeature.newConstructor(cname, cent,
                                 mparams.modelElements,
                                 gpars.modelElements); 
      constr.setStatic(true); 
      constr.setTypeParameters(gpars.modelElements);
        
      res = res + "  operation initialise" + mparams.toKM3() + " : void\n" + 
              "  pre: true\n" + "  post: true\n"; 

      SequenceStatement initCode = new SequenceStatement(); 
      
      if (terms.size() > 2)
      { res = res + 
          "  activity:\n";  
        for (int i = 2; i < terms.size(); i++) 
        { ASTTerm tt = (ASTTerm) terms.get(i); 
          res = res + "   " + tt.toKM3();

          if (tt.statement != null) 
          { initCode.addStatement(tt.statement); } 

          if (i < terms.size() - 1) 
          { res = res + "\n"; }
          else 
          { res = res + " ;\n"; }  
        }
      }  

      if (initCode.isEmpty())
      { initCode.addStatement(new InvocationStatement("skip")); } 

      BehaviouralFeature bfInit = 
          new BehaviouralFeature("initialise"); 
      bfInit.setParameters(mparams.modelElements); 
      bfInit.setTypeParameters(gpars.modelElements);
      bfInit.setActivity(initCode); 
      bfInit.setPrecondition(new BasicExpression(true)); 
      bfInit.setPostcondition(new BasicExpression(true)); 
      // modelElement = bfInit; 

      modelElements = new Vector(); 
      modelElements.add(bfInit); 
      modelElements.add(constr); 

      if (cent != null && cent.getSuperclass() != null) 
      { Entity supent = cent.getSuperclass(); 
        BehaviouralFeature overriddenOp = 
           supent.getDefinedOperation("initialise", 
                                      mparams.modelElements); 
        if (overriddenOp != null) 
        { bfInit.addStereotype("override"); } 
      } 

      if (gpars.modelElements != null) 
      { for (int i = 0; i < gpars.modelElements.size(); i++) 
        { ModelElement partype = 
            (ModelElement) gpars.modelElements.get(i); 
          Entity parEnt = null; 
          if (partype instanceof Type)
          { parEnt = ((Type) partype).getEntity(); } 
          else if (partype instanceof Entity)
          { parEnt = (Entity) partype; } 
 
          if (parEnt != null) 
          { ASTTerm.entities.remove(parEnt); }
 
          cent.addTypeParameter(parEnt); 
        } 
      } 

      return res + "\n\n"; 
    }

    if ("formalParameter".equals(tag))
    { int nTerms = terms.size(); 
      ASTTerm mtype = (ASTTerm) terms.get(nTerms - 2); 
      ASTTerm mname = (ASTTerm) terms.get(nTerms - 1);
      
      String typ = mtype.toKM3type(); 
      String vv = mname.toKM3();


      Type tf = (Type) mtype.modelElement; 
      Type vtyp = mname.toKM3CollectionType(tf); 

      if (vtyp != null)
      { // vtyp.setElementType(tf); 
        tf = vtyp; 
        ASTTerm.setType(vv,"" + vtyp); 
                           // "Sequence(" + typ + ")"
        typ = "" + vtyp; // "Sequence(" + typ + ")"; 
      } 
      else 
      { ASTTerm.setType(vv,typ); } 

      Type tt = 
        Type.getTypeFor(typ, 
                   ASTTerm.enumtypes, ASTTerm.entities); 
      Type elemT = null; 

      if (tt != null)
      { System.out.println(">>> Type for parameter " + mname + " is " + tt + " ( " + tt.getElementType() + " )"); 
        elemT = tt.getElementType(); 
      } 
      else if (mtype.modelElement instanceof Type)
      { tt = tf; // (Type) mtype.modelElement; 
        System.out.println(">>> Type for parameter " + mname + " is " + tt + " ( " + tt.getElementType() + " )"); 
        elemT = tt.getElementType(); 
      }
      else 
      { System.out.println("! Warning: no type for parameter " + mname); 
        tt = new Type(typ,null); 
      } 
  
      System.out.println(); 

      modelElement = 
        new Attribute(vv, tt, ModelElement.INTERNAL); 
      // Attribute.newAttribute(vv, tt, 
      //    ASTTerm.enumtypes, ASTTerm.entities);  
      ((Attribute) modelElement).setElementType(elemT); 
  
      String res = vv + " : " + typ;  
      return res;
    }

    if ("lastFormalParameter".equals(tag))
    { int nTerms = terms.size(); 


      ASTTerm mtype = (ASTTerm) terms.get(nTerms - 3); 
      
      for (int i = 0; i < nTerms -1; i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt.hasTag("typeType"))
        { mtype = tt; 
          break; 
        } 
      } 
      ASTTerm mname = (ASTTerm) terms.get(nTerms - 1);
      
      String typ = mtype.toKM3type(); 
      String vv = mname.toKM3(); 
      ASTTerm.setType(vv,"Sequence(" + typ + ")");

      Type tt = Type.getTypeFor(typ, ASTTerm.enumtypes, ASTTerm.entities); 
      Type elemT = null; 

      if (tt != null)
      { System.out.println(">>> Type for parameter " + mname + " is Sequence(" + tt + ")"); 
        elemT = tt.getElementType(); 
      } 
      else 
      { System.out.println("! Warning: no type for parameter " + mname); }  
      System.out.println(); 

      Type seqtype = new Type("Sequence", null); 
      seqtype.setElementType(tt); 
      modelElement = new Attribute(vv, seqtype, 
                                   ModelElement.INTERNAL); 
      // Attribute.newAttribute(vv, tt, 
      //    ASTTerm.enumtypes, ASTTerm.entities);  
      ((Attribute) modelElement).setElementType(tt); 
  
      String res = vv + " : Sequence(" + typ + ")";  
      return res;
    }

    if ("formalParameters".equals(tag))
    { String res = ""; 

      modelElements = new Vector(); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm pterm = (ASTTerm) terms.get(i); 
        res = res + pterm.toKM3(); 
        if (pterm.modelElement != null) 
        { modelElements.add(pterm.modelElement); } 
        else if (pterm.modelElements != null) 
        { modelElements.addAll(pterm.modelElements); } 
      } 

      return res;
    }

    if ("formalParameterList".equals(tag))
    { String res = ""; 

      modelElements = new Vector(); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm pterm = (ASTTerm) terms.get(i); 
        res = res + pterm.toKM3(); 
        if (pterm.modelElement != null) 
        { modelElements.add(pterm.modelElement); } 
      } 

      return res;
    }

    if ("importDeclaration".equals(tag))
    { return "\n"; }  


    if ("enumDeclaration".equals(tag) && 
        terms.size() == 5 && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + ""))
    { // enum E { lits } 
      ASTTerm ename = (ASTTerm) terms.get(1); 
      ASTTerm literals = (ASTTerm) terms.get(3);
      Vector litvals = ((ASTCompositeTerm) literals).literalValues(); 

      Type etype = new Type(ename.literalForm(), litvals); 
      modelElement = etype; 
      ASTTerm.enumtypes.add(etype); 
 
      return "enumeration " + ename +
             " {\n" + literals.toKM3() + "}\n\n"; 
    }  // Simple enumeration

    if ("enumDeclaration".equals(tag) && 
        terms.size() == 6 && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(5) + ""))
    { // enum E { lits body } 

      ASTTerm enumname = (ASTTerm) terms.get(1); 
      ASTTerm literals = (ASTTerm) terms.get(3);
      // Vector litvals = ((ASTCompositeTerm) literals).literalValues(); 
      ASTTerm enumBody = (ASTTerm) terms.get(4);
      
      // Type etype = new Type(ename.literalForm(), litvals);

      String ename = enumname.literalForm(); 
      Entity etype = new Entity(ename);  
      modelElement = etype; 
      ASTTerm.entities.add(etype); 
 

      String bdy = enumBody.toKM3(); 
      etype.addModelElements(enumBody.modelElements); 
 
      return "class " + ename +
             " {\n" + 
             ((ASTCompositeTerm) literals).toKM3asObjects(etype) + "\n " + 
             bdy + "}\n\n"; 
    }  // Enumeration as class

    if ("enumDeclaration".equals(tag) && 
        terms.size() == 7 && 
        "implements".equals(terms.get(2) + "") &&
        "{".equals(terms.get(4) + "") &&  
        "}".equals(terms.get(6) + ""))
    { // enum E implements typeList { lits } 

      ASTTerm enumname = (ASTTerm) terms.get(1); 
      ASTTerm intfs = (ASTTerm) terms.get(3);
      ASTTerm literals = (ASTTerm) terms.get(5);
      
      String tlst = intfs.toKM3type(); 

      // Type etype = new Type(ename.literalForm(), litvals);

      String ename = enumname.literalForm(); 
      Entity etype = new Entity(ename);  
      modelElement = etype; 
      ASTTerm.entities.add(etype); 

      // String interfaceList = ""; 
      // interfaceList = intfs.literalForm(); 
      etype.addInterfaces(intfs.modelElements,  
                             ASTTerm.entities);  

      return "class " + ename + " implements " + 
                        tlst + 
             " {\n" + 
             ((ASTCompositeTerm) literals).toKM3asObjects(etype) + "\n " + 
             "}\n\n"; 
    }  // Enumeration as class

    if ("enumDeclaration".equals(tag) && 
        terms.size() == 7 && 
        "{".equals(terms.get(2) + "") &&
        ",".equals(terms.get(4) + "") &&  
        "}".equals(terms.get(6) + ""))
    { // enum E { lits , body } 

      ASTTerm enumname = (ASTTerm) terms.get(1); 
      ASTTerm literals = (ASTTerm) terms.get(3);
      // Vector litvals = ((ASTCompositeTerm) literals).literalValues(); 
      ASTTerm enumBody = (ASTTerm) terms.get(5);
      
      // Type etype = new Type(ename.literalForm(), litvals);

      String ename = enumname.literalForm(); 
      Entity etype = new Entity(ename);  
      modelElement = etype; 
      ASTTerm.entities.add(etype); 

      String bdy = enumBody.toKM3(); 
      etype.addModelElements(enumBody.modelElements); 
 
      return "class " + ename +
             " {\n" + 
             ((ASTCompositeTerm) literals).toKM3asObjects(etype) + "\n " + 
             bdy + "}\n\n"; 
    }  // Enumeration as class

    if ("enumDeclaration".equals(tag) && 
        terms.size() == 9 && 
        "implements".equals(terms.get(2) + "") &&
        "{".equals(terms.get(4) + "") &&  
        ",".equals(terms.get(6) + "") &&  
        "}".equals(terms.get(8) + ""))
    { // enum E implements typeList { lits , body } 

      ASTTerm enumname = (ASTTerm) terms.get(1); 
      ASTTerm intfs = (ASTTerm) terms.get(3);
      ASTTerm literals = (ASTTerm) terms.get(5);
      ASTTerm enumBody = (ASTTerm) terms.get(7);
      
      String tlst = intfs.toKM3type(); 

      // Type etype = new Type(ename.literalForm(), litvals);


      String ename = enumname.literalForm(); 
      Entity etype = new Entity(ename);  
      modelElement = etype; 
      ASTTerm.entities.add(etype); 

      String bdy = enumBody.toKM3(); 
      etype.addModelElements(enumBody.modelElements); 

      // String interfaceList = ""; 
      // interfaceList = intfs.literalForm(); 
      etype.addInterfaces(intfs.modelElements,  
                             ASTTerm.entities);  

      return "class " + ename + " implements " + 
                        tlst + 
             " {\n" + 
             ((ASTCompositeTerm) literals).toKM3asObjects(etype) + "\n " + 
             bdy + "}\n\n"; 
    }  // Enumeration as class

    if ("modifier".equals(tag))
    { if (terms.size() > 0)
      { String ltf = ((ASTTerm) terms.get(0)).literalForm(); 
        if ("static".equals(ltf))
        { return "  static "; } 
      } 
      return ""; 
    } 

    if ("enumConstants".equals(tag))
    { String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm lit = (ASTTerm) terms.get(i); 
        if (",".equals(lit + "")) { } 
        else
        { res = res + "  literal " + lit.toKM3() +
                ";\n";
        } 
      } 
      return res;  
    }  

    if ("packageDeclaration".equals(tag))
    { ASTTerm pname = (ASTTerm) terms.get(1); 
      String pn = pname.toKM3(); 
      ASTTerm.packageName = pn;
      return ""; 
    } 

    if ("compilationUnit".equals(tag))
    { String res = ""; 
      modelElements = new Vector(); 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        res = res + t.toKM3(); 
        if (t.modelElement != null) 
        { modelElements.add(t.modelElement);
          /* if (t.modelElements != null) 
          { for (int j = 0; j < t.modelElements.size(); j++) 
            { ModelElement tmod = 
                (ModelElement) t.modelElements.get(j); 
              if (tmod instanceof Entity)
              { modelElements.add(tmod); } 
            } 
          } */ 
        } 
        else if (t.modelElements != null) 
        { modelElements.addAll(t.modelElements); } 
      } 
      return res; 
    } 

    if ("typeDeclaration".equals(tag) || 
        "localTypeDeclaration".equals(tag))
    { String res = ""; 
      modelElements = new Vector(); 

      if (terms.size() == 1 && 
          ";".equals(terms.get(0) + ""))
      { return ""; } 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        
        String lfterm = t.literalForm(); 

        if ("abstract".equals(lfterm) ||
            "public".equals(lfterm) ||
            "private".equals(lfterm) || 
            "protected".equals(lfterm)) 
        { continue; } 

        res = res + t.toKM3(); 
        if (t.modelElement != null) 
        { modelElements.add(t.modelElement); 
          modelElement = t.modelElement; 
          /* if (t.modelElements != null) 
          { for (int j = 0; j < t.modelElements.size(); j++) 
            { ModelElement tmod = 
                (ModelElement) t.modelElements.get(j); 
              if (tmod instanceof Entity)
              { modelElements.add(tmod); } 
            } 
          } */ 
        } 
        else if (t.modelElements != null) 
        { modelElements.addAll(t.modelElements); } 
      } 
      return res; 
    } 

       
    if ("classDeclaration".equals(tag) && 
        terms.size() > 2)
    { // class name typeParameters? classBody

      ASTTerm ename = (ASTTerm) terms.get(1); 
      String entName = ename.literalForm(); 
      
      Entity newEnt = 
        (Entity) ModelElement.lookupByName(
                       entName, ASTTerm.entities); 
      if (newEnt == null && Entity.validEntityName(entName)) 
      { newEnt = new Entity(entName);
        ASTTerm.entities.add(newEnt); 
      } 

      ASTTerm.currentClass = newEnt; 

      int bodyIndex = 2;  

      String typePar = ""; 

      ASTTerm contents = (ASTTerm) terms.get(2);
      if (contents.hasTag("typeParameters") && 3 < terms.size())
      { // Generic class 
        typePar = contents.toKM3type(); 
        System.out.println(">>> Generic class " + entName + ", parameters: " + typePar);
 
        if (contents.modelElements != null && newEnt != null) 
        { newEnt.addGenericTypeParameters(
                              contents.modelElements,
                              ASTTerm.entities); 
        } 
        else if (contents.modelElement != null && 
            (contents.modelElement instanceof Type))
        { Entity newT = null; 
          if (((Type) contents.modelElement).isEntity())
          { newT = ((Type) contents.modelElement).getEntity(); } 
          else if (Entity.validEntityName(
                             contents.modelElement.getName()))
          { newT = new Entity(contents.modelElement.getName()); 
            ASTTerm.entities.add(newT); 
          } 

          if (newT != null) 
          { newT.genericParameter = true;  
            newEnt.addTypeParameter(new Type(newT));
            System.out.println(">>> Type parameter " + newT + " of class " + entName);
          }   
        } // modelElements

        bodyIndex = 3; 
        contents = (ASTTerm) terms.get(3); 
      } 

      if ("extends".equals(contents.literalForm()) && 
          bodyIndex + 2 < terms.size())
      { ASTTerm superclass = (ASTTerm) terms.get(bodyIndex+1);
        String sclass = superclass.toKM3type();  

        String supclass = sclass;
        if (superclass.modelElement != null) 
        { supclass = superclass.modelElement.getName(); } 
        // The name without type parameters. 

       
        if ("OclAny".equals(supclass)) { } 
        else if (superclass.modelElement instanceof Entity) 
        { newEnt.setSuperclass(
                   (Entity) superclass.modelElement); 
        }
        else if (superclass.modelElement instanceof Type && 
                 ((Type) superclass.modelElement).isEntity())
        { Entity supx = 
            ((Type) superclass.modelElement).getEntity(); 
          newEnt.setSuperclass(supx); 
        }  
        else
        { Entity sup = 
            (Entity) ModelElement.lookupByName(
                          supclass, ASTTerm.entities); 
          if (sup == null && Entity.validEntityName(supclass)) 
          { sup = new Entity(supclass); 
            ASTTerm.entities.add(sup); 
          } 

          newEnt.setSuperclass(sup);
        }

        contents = (ASTTerm) terms.get(bodyIndex+2); 
        bodyIndex = bodyIndex + 2; 
      }  
        
      if ("implements".equals(contents.literalForm()) && 
          bodyIndex + 2 < terms.size())
      { ASTTerm typeList = (ASTTerm) terms.get(bodyIndex + 1);
        String iList = typeList.toKM3type(); 
        String interfaceList = ""; 
        interfaceList = typeList.literalForm(); 
        newEnt.addInterfaces(typeList.modelElements,  
                             ASTTerm.entities);  
    
        // sclass = sclass + ", " + iList; 
          
          // add as interfaces of newEnt
        contents = (ASTTerm) terms.get(bodyIndex+2); 
      } 

      String km3Contents = contents.toKM3();
      if (contents.modelElements != null) 
      { newEnt.addModelElements(contents.modelElements);
        System.out.println(">>> Model elements of " + newEnt + " are: " + contents.modelElements);
      } 

      Vector entPars = newEnt.getTypeParameters(); 
      for (int kk = 0; kk < entPars.size(); kk++) 
      { Type tp = (Type) entPars.get(kk); 
        if (tp.isEntity())
        { ASTTerm.entities.remove(tp.entity); } 
      } 
  
      modelElement = newEnt; 
      // String stereotypeList = newEnt.stereotypesKM3(); 
      return newEnt.getKM3(); 
    } 

    if ("annotationTypeDeclaration".equals(tag))
    { // @ interface name (annotationTypeBody { decls })
 
      ASTTerm ename = (ASTTerm) terms.get(2); 

      String entName = ename.literalForm(); 
      Entity newEnt = 
        (Entity) ModelElement.lookupByName(
                        entName, ASTTerm.entities); 
      if (newEnt == null) 
      { newEnt = new Entity(entName);
        ASTTerm.entities.add(newEnt); 
      }  

      ASTTerm.currentClass = newEnt; 

      ASTTerm contents = (ASTTerm) terms.get(3);
      String km3Contents = contents.toKM3(); 
      if (contents.modelElements != null) 
      { newEnt.addModelElements(contents.modelElements); } 
    
      newEnt.addStereotype("interface");  
      modelElement = newEnt; 
 
      return "interface " + ename +
             " { \n" + km3Contents + "}\n\n"; 
    } 

    if ("annotationTypeBody".equals(tag))
    { modelElements = new Vector(); 
        
      if (terms.size() == 2) 
      { return ""; } 
      
      String res = ""; 
 
      for (int j = 1; j < terms.size()-1; j++)
      { ASTTerm annot = (ASTTerm) terms.get(j); 
        res = res + annot.toKM3(); 
        if (annot.modelElement != null) 
        { modelElements.add(annot.modelElement); } 
      } 
       
      return res; 
    }  
      
    if ("annotationTypeElementDeclaration".equals(tag))
    { if (terms.size() == 1 && ";".equals(terms.get(0) + ""))
      { return ""; } 

      boolean isStatic = false; 
      String resx = "  "; 

      for (int i = 0; i < terms.size()-1; i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if ("static".equals(tt.literalForm()))
        { isStatic = true; 
          resx = "  static "; 
        } 
      } 

      ASTTerm trm = (ASTTerm) terms.get(terms.size()-1);
      resx = resx + trm.toKM3();  
      modelElement = trm.modelElement;

      if (modelElement instanceof Attribute) 
      { ((Attribute) modelElement).setStatic(isStatic); } 
      else if (modelElement instanceof BehaviouralFeature) 
      { ((BehaviouralFeature) modelElement).setStatic(
                                               isStatic); 
      } 
 
      return resx; 
    } 

    if ("annotationTypeElementRest".equals(tag))
    { if (terms.size() == 3) 
      { // typeType annotationMethodOrConstantRest ;
        ASTTerm typterm = (ASTTerm) terms.get(0); 
        String typ = typterm.toKM3(); 
        
        ASTTerm elemterm = (ASTTerm) terms.get(1); 
        String elem = elemterm.toKM3(); 

        if (elemterm.modelElement != null && 
            typterm.modelElement != null) 
        { elemterm.modelElement.setType(
                      (Type) typterm.modelElement); 
        } 

        modelElement = elemterm.modelElement; 

        if (modelElement instanceof BehaviouralFeature)
        { return elem + " : " + typ + ";\n"; } 
        else 
        { return elem; }  
      } 

      if (terms.size() > 0) 
      { ASTTerm elem = (ASTTerm) terms.get(0); 
        String resx = elem.toKM3(); 
        modelElement = elem.modelElement; 
        return resx; 
      } 

      return ""; 
    } 

    if ("annotationMethodOrConstantRest".equals(tag))
    { ASTTerm elem = (ASTTerm) terms.get(0); 
      String resx = elem.toKM3(); 
      modelElement = elem.modelElement; 
      return resx; 
    } 

    if ("annotationMethodRest".equals(tag))
    { ASTTerm elemname = (ASTTerm) terms.get(0); 
      String opname = elemname.literalForm();
      BehaviouralFeature bf = new BehaviouralFeature(opname);
      bf.setPre(new BasicExpression(true)); 
      bf.setPost(new BasicExpression(true)); 
  
      modelElement = bf; 
   
      if (terms.size() == 3)
      { return "  operation " + opname + "() : OclAny\n" + 
               "  pre: true post: true;\n";
      } 
   
      if (terms.size() == 4)
      { ASTTerm defaultVal = (ASTTerm) terms.get(3); 
        String val = defaultVal.toKM3();
        if (defaultVal.expression != null) 
        { BasicExpression resbe = 
            BasicExpression.newVariableBasicExpression(
                                             "result"); 
          BinaryExpression setresult = 
            new BinaryExpression("=", 
                  resbe, defaultVal.expression);
          bf.setPost(setresult); 
        } 
  
        return "  operation " + opname + "() : OclAny\n" + 
               "  pre: true post: result = " + val + ";\n";
      }

      return ""; 
    } 

    if ("defaultValue".equals(tag))
    { ASTTerm trm = (ASTTerm) terms.get(1); 
      String resy = trm.queryForm();
      expression = trm.expression; 
      return resy;  
    } 

    if ("elementValue".equals(tag))
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      String resy = trm.queryForm();
      expression = trm.expression; 
      return resy;  
    } 

    if ("annotationConstantRest".equals(tag))
    { ASTCompositeTerm elem = (ASTCompositeTerm) terms.get(0); 
      String resx = elem.toKM3annotationConstantDeclarators(); 
      modelElement = elem.modelElement; 
      modelElements = elem.modelElements; 
      return resx; 
    } 


    // Can also be generic: 
    if ("interfaceDeclaration".equals(tag) && 
        terms.size() > 2)
    { // interface name typeParameters? interfaceBody

      ASTTerm ename = (ASTTerm) terms.get(1); 

      String entName = ename.literalForm(); 
      Entity newEnt = 
        (Entity) ModelElement.lookupByName(
                        entName, ASTTerm.entities); 
      if (newEnt == null) 
      { newEnt = new Entity(entName);
        ASTTerm.entities.add(newEnt); 
      }  

      ASTTerm.currentClass = newEnt; 

      ASTTerm contents = (ASTTerm) terms.get(2);

      int index = 2;  

      String typePars = ""; 
      if (contents instanceof ASTCompositeTerm && 
          contents.hasTag("typeParameters"))
      { typePars = contents.toKM3type(); 
        newEnt.setTypeParameters(contents.modelElements); 
        contents = (ASTTerm) terms.get(3); 
        index = 3; 
      } 

      if ("extends".equals(contents.literalForm()) && 
          terms.size() > 4)
      { ASTTerm superclass = (ASTTerm) terms.get(index+1);
        String sclass = superclass.toKM3type(); // several  

        newEnt.addInterfaces(superclass.modelElements,  
                             ASTTerm.entities);  

        contents = (ASTTerm) terms.get(index+2); 
        String km3Contents = contents.toKM3(); 

        if (contents.modelElements != null) 
        { newEnt.addModelElements(contents.modelElements); } 


        newEnt.addStereotype("interface");  
        modelElement = newEnt; 
 
        return "class " + ename + typePars + " extends " + sclass + "\n" + 
             "{ stereotype interface;\n" + km3Contents + "}\n\n"; 
      } 
      else 
      { String km3Contents = contents.toKM3(); 

        if (contents.modelElements != null) 
        { newEnt.addModelElements(contents.modelElements); } 
        newEnt.addStereotype("interface");  
        modelElement = newEnt; 

        ASTTerm.entities.add(newEnt); 

        return "class " + ename + typePars + "\n" + 
               "{ stereotype interface;\n" + 
               contents.toKM3() + "}\n\n"; 
      } 

    }  

    if ("annotation".equals(tag) || 
        "altAnnotationQualifiedName".equals(tag))
    { return ""; } 

    if (terms.size() == 1) // Identifier or literal
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.toKM3();     
    } 

    String res = "";  
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm tt = (ASTTerm) terms.get(i); 
      res = res + tt.toKM3() + " "; 
    } 
    return res; 
  }

  public String toKM3asObjects(Entity ent)
  { // enumeration literals as objects
    String res = ""; 
      
    if ("enumConstants".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm lit = (ASTTerm) terms.get(i); 
        if (",".equals(lit + "")) { } 
        else
        { res = res + "  " + 
                lit.toKM3asObject(ent) +
                ";\n";
        } 
      } 
      return res;  
    }  

    return ""; 
  } 

  public String toKM3asObject(Entity ent)
  { String res = ""; 
    String ename = ent.getName(); 
      
    if ("enumConstant".equals(tag))
    { if (terms.size() == 1) 
      { String cnst = terms.get(0) + ""; 
        res = "static attribute " + cnst + " : " + ename + " := " + ename + ".new" + ename + "()"; 
        Attribute att = 
          new Attribute(cnst, new Type(ent), 
                        ModelElement.INTERNAL);
        att.setStatic(true); 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression(
                            "new" + ename, ename); 
        att.setInitialExpression(call);  
        ent.addAttribute(att); 
      } 
      else if (terms.size() == 2 && 
               "arguments".equals(((ASTTerm) terms.get(1)).getTag())) 
      { String cnst = terms.get(0) + ""; 
        ASTTerm args = (ASTTerm) terms.get(1); 
        String pars = args.toKM3(); 
        res = "static attribute " + cnst + " : " + ename + " := " + ename + ".new" + ename + pars; 
        Attribute att = 
          new Attribute(cnst, new Type(ent), 
                        ModelElement.INTERNAL);
        att.setStatic(true);
        Vector exprs = args.getParameterExpressions(); 
 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression(
                            "new" + ename, ename, exprs); 
        att.setInitialExpression(call);  
        ent.addAttribute(att); 
      } 
      else if (terms.size() == 2 && 
               "classBody".equals(((ASTTerm) terms.get(1)).getTag())) 
      { String cnst = terms.get(0) + ""; 
        ASTTerm args = (ASTTerm) terms.get(1);
        String cname = ename + "_" + cnst + "_Class"; 
        Entity cclass = 
          new Entity(ename + "_" + cnst + "_Class"); 
        cclass.setSuperclass(ent); 
        ent.addSubclass(cclass); 
 
        String pars = args.toKM3();
        cclass.addModelElements(args.modelElements); 
        ASTTerm.entities.add(cclass); 
 
        res = "  class " + cname + " extends " + ename + " { " + pars + "  }\n" + 
           "    static attribute " + cnst + " : " + cname + " := " + cname + ".new" + cname + "()"; 
        Attribute att = 
          new Attribute(cnst, new Type(cclass), 
                        ModelElement.INTERNAL);
        att.setStatic(true);
 
        Expression call = 
          BasicExpression.newStaticCallBasicExpression(
                            "new" + cname, cname); 
        att.setInitialExpression(call);  
        ent.addAttribute(att); 
      } 
    } 

    return res; 
  } 

  public boolean updatesObject(ASTTerm t)
  { if ("methodCall".equals(tag))
    { 
      String called = terms.get(0) + "";
      if (("add".equals(called) && t != null && 
           t.isCollection()) || 
          "addAll".equals(called) || 
          "addFirst".equals(called) || 
          "addLast".equals(called) ||
          "addElement".equals(called) ||
          "append".equals(called) ||
          "offer".equals(called) ||  
          "offerFirst".equals(called) ||  
          "offerLast".equals(called) ||  
          "copyInto".equals(called) ||  
          "put".equals(called) || "putAll".equals(called) || 
          "removeAll".equals(called) || 
          "remove".equals(called) ||
          "removeFirst".equals(called) || 
          "removeFirstOccurrence".equals(called) || 
          "removeLast".equals(called) ||
          "removeLastOccurrence".equals(called) ||
          "insert".equals(called) || 
          "insertElementAt".equals(called) || 
          "removeAllElements".equals(called) ||  
          "set".equals(called) ||
          "setElementAt".equals(called) || 
          "setSize".equals(called) || 
          "setLength".equals(called) || 
          "removeRange".equals(called) || 
          "clear".equals(called) || "push".equals(called) || 
          "removeElement".equals(called) || 
          "removeElementAt".equals(called) ||
          "delete".equals(called) || 
          "deleteCharAt".equals(called) ||
          "setCharAt".equals(called) ||
          ("replace".equals(called) && t != null && 
           t.isSequence()) ||
          "reverse".equals(called) ||  
          "pop".equals(called) || "take".equals(called) ||
          "poll".equals(called) ||  
          "pollLast".equals(called) ||  
          "pollFirst".equals(called) ||  
          "retainAll".equals(called))
      { System.out.println(">**>**> methodCall " + called + " updates the object it is applied to."); 
        return true; 
      } 
      return false; 
    }
    else if ("expression".equals(tag))
    { if (terms.size() > 2 && ".".equals(terms.get(1) + ""))
      { ASTTerm call = (ASTTerm) terms.get(2); 
        return call.updatesObject((ASTTerm) terms.get(0)); 
      } 

      if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        // JOptionPane.showInputDialog(this + " updates object: " +
        //                             call.updatesObject(null));   
        return call.updatesObject(null); 
      } 
    } 

    return false; 
  } 

  public ASTTerm updatedObject()
  { if ("expression".equals(tag))
    { if (terms.size() > 2 && ".".equals(terms.get(1) + "") && 
          "methodCall".equals(((ASTTerm) terms.get(2)).getTag()))
      { ASTTerm obj = (ASTTerm) terms.get(0); 
        return obj.updatedObject(); 
      } 

      if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        // JOptionPane.showInputDialog(this + " updated object: " +
        //                            call.updatedObject());   
        return call.updatedObject(); 
      }
    }
    
    if (terms.size() == 4 && "primary".equals(tag) && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
    { // bracketed expression
      ASTTerm call = (ASTTerm) terms.get(1);
      return call.updatedObject(); 
    } 

    return this; 
  } 

  public boolean callSideEffect()
  { if ("methodCall".equals(tag))
    { 
      String called = terms.get(0) + "";
      if ("replaceAll".equals(called))
      { System.out.println(">>> methodCall " + called + " has side-effect."); 
        return true; 
      } // But not when applied to a string. 
      return false;  
    } 
    return false; 
  }

  public boolean hasSideEffect()
  { 
    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt.hasSideEffect()) 
        { return true; } 
      } 
      return false; 
    } 

    if ("expression".equals(tag))
    { if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        return t.hasSideEffect();          
      } 

      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        String op1 = op.toKM3(); 
        String arg1 = arg.toKM3(); 

        if ("++".equals(arg1) || "++".equals(op1))
        { return true; }
 
        if ("--".equals(arg1) || "--".equals(op1))
        { return true; }
      }  
      else if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(2); 

        if (".".equals(op + ""))
        { if ("Collections".equals(arg1.literalForm()) && 
              arg2.callSideEffect())
          { return true; }  
        } 

        if ("=".equals(op + "") || "+=".equals(op + "") || 
            "-=".equals(op + "") || "*=".equals(op + "") ||
            "/=".equals(op + "") || "|=".equals(op + "") ||
            "&=".equals(op + "") || "^=".equals(op + "") ||
            "%=".equals(op + "") || "<<=".equals(op + "") ||
            ">>=".equals(op + "") || ">>>=".equals(op + ""))
        { return true; } 
      
        return arg1.hasSideEffect() || arg2.hasSideEffect(); 
      } 
      else if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);

        // JOptionPane.showInputDialog(this + 
        //                         " has side effect: " +
        //                         call.hasSideEffect());   
        
        return call.hasSideEffect(); 
      } 
      else if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // brackets
        ASTTerm call = (ASTTerm) terms.get(1); 
        return call.hasSideEffect(); 
      } 
      else if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        if (arr.hasSideEffect()) 
        { return true; }  
        return ind.hasSideEffect(); 
      }
      else if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        boolean condx = cond.hasSideEffect(); 
        boolean ifx = ifoption.hasSideEffect(); 
        boolean elsex = elseoption.hasSideEffect();
          
        return (condx || ifx || elsex);  
      } 
    } 

    if ("methodCall".equals(tag))
    { return false; } 

    return false; 
  } 

  public boolean hasPreSideEffect()
  { if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
    { // brackets
      ASTTerm call = (ASTTerm) terms.get(1);
      return call.hasPreSideEffect(); 
    } 
     
    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i);
        if (tt.hasPreSideEffect()) 
        { return true; }
      } 
    } 

    if ("variableInitializer".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.hasPreSideEffect();          
    }


    if ("expression".equals(tag))
    { if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        return t.hasPreSideEffect();           
      } 
   
      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        String op1 = op.toKM3(); 
        String arg1 = arg.toKM3(); 

        if ("++".equals(op.literalForm()))
        { if (arg.expression != null) 
          { return true; }  
        }
 
        if ("--".equals(op.literalForm()))
        { if (arg.expression != null) 
          { return true; }  
        }
      }  
      else if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(2); 

        if (".".equals(op) && 
            "methodCall".equals(arg2.getTag()))
        { return false; }  

        SequenceStatement ssres = new SequenceStatement(); 

        return arg1.hasPreSideEffect() || 
               arg2.hasPreSideEffect();        
      } 
      else if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        return call.hasPreSideEffect();
      } 
      else if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // brackets
        ASTTerm call = (ASTTerm) terms.get(1);
        return call.hasPreSideEffect();
      } 
      else if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        return arr.hasPreSideEffect() ||
               ind.hasPreSideEffect(); 
      }
      else if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);

        return cond.hasPreSideEffect() || 
               ifoption.hasPreSideEffect() || 
               elseoption.hasPreSideEffect();
          
      } 
    } 

    return false; 
  } 

  public boolean hasPostSideEffect()
  { if ("methodCall".equals(tag))
    { 
      String called = terms.get(0) + "";
      // ASTTerm callargs = (ASTTerm) terms.get(2);
      // Vector cargs = getCallArguments(callargs); 

      if ("replaceAll".equals(called))
      { // System.out.println(">>> methodCall " + called + " has side-effect."); 

        return true;  
      }

      return false; 
    } 
    
    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt.hasPostSideEffect())
        { return true; }  
      } 
    } 

    if ("variableInitializer".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.hasPostSideEffect(); 
    }

    if ("expression".equals(tag))
    { if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        return t.hasPostSideEffect();         
      } 
   
      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);
       
        if ("++".equals(arg.literalForm()))
        { return true; }
 
        if ("--".equals(arg.literalForm()))
        { return true; }
      }  
      else if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(2); 

        if (".".equals(op + ""))
        { if ("Collections".equals(arg1.literalForm()) && 
              arg2.hasPostSideEffect())
          { return true; }  
          return false; 
        } 
      
        return arg1.hasPostSideEffect() ||
               arg2.hasPostSideEffect();
      } 
      else if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        return call.hasPostSideEffect();
      } 
      else if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { 
        ASTTerm call = (ASTTerm) terms.get(1);
        return call.hasPostSideEffect();
      } 
      else if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        return arr.hasPostSideEffect() || 
               ind.hasPostSideEffect();         
      }
      else if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        return cond.hasPostSideEffect() ||
               ifoption.hasPostSideEffect() || 
               elseoption.hasPostSideEffect();
          
      } 
    } 

    return false; 
  } 

  public String preSideEffect()
  { if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
    { // brackets
      ASTTerm call = (ASTTerm) terms.get(1);
      String res = call.preSideEffect();
      statement = call.statement;
      return res;  
    } 
     
    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i);
        if (tt.hasSideEffect()) 
        { String se = tt.preSideEffect(); 
          if (tt.statement != null) 
          { statement = tt.statement; 
            return se; 
          } 
        } 
      } 
    } 

    if ("variableInitializer".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      String res = t.preSideEffect(); 
      statement = t.statement; 
      return res;          
    }


    if ("expression".equals(tag))
    { if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        String res = t.preSideEffect(); 
        statement = t.statement; 
        return res;          
      } 
   
      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        String op1 = op.toKM3(); 
        String arg1 = arg.toKM3(); 

        if ("++".equals(op.literalForm()))
        { if (arg.expression != null) 
          { expression = new BinaryExpression("+", 
                              arg.expression, unitExpression); 
            statement = 
              new AssignStatement(arg.expression, expression);
          }  
          
          return arg1 + " := " + arg1 + " + 1"; 
        }
 
        if ("--".equals(op.literalForm()))
        { if (arg.expression != null) 
          { expression = new BinaryExpression("-", 
                              arg.expression, unitExpression); 
            statement = 
              new AssignStatement(arg.expression, expression);
          }  
          
          return arg1 + " := " + arg1 + " - 1"; 
        }
      }  
      else if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(2); 

        if (".".equals(op) && 
            "methodCall".equals(arg2.getTag()))
        { if (arg2.updatesObject(arg1))
          { }
          else 
          { statement = null; 
            return ""; // return null; 
          } 
        }  

        // JOptionPane.showInputDialog(arg2 + " updates " + arg1); 

        SequenceStatement ssres = new SequenceStatement(); 

        String se1 = arg1.preSideEffect(); 
        Statement stat1 = arg1.statement; 
        String se2 = arg2.preSideEffect();
        Statement stat2 = arg2.statement; 

        // JOptionPane.showInputDialog("Presideeffect: " + arg1 + op + arg2 + " --> " + stat1 + " | " + stat2); 

        if (stat1 != null) 
        { ssres.addStatement(stat1); } 

        if (stat2 != null) 
        { ssres.addStatement(stat2); } 

        String qf1 = arg1.queryForm(); 

        if (("=".equals(op + "") || "+=".equals(op + "") || 
             "-=".equals(op + "") || "*=".equals(op + "") ||
             "/=".equals(op + "") || "|=".equals(op + "") ||
             "&=".equals(op + "") || "^=".equals(op + "") ||
             "%=".equals(op + "") || "<<=".equals(op + "") ||
             ">>=".equals(op + "") || ">>>=".equals(op + ""))
             && arg1.expression != null && 
                arg2.expression != null)
        { ssres.addStatement(new 
                 AssignStatement(op+"", arg1.expression,
                                 arg2.expression));
          statement = ssres;  
          return qf1 + " := " + arg2.expression; 
        } // likewise for += etc
        
        if (stat1 == null && stat2 == null) 
        { return null; }  
        
        if (stat1 != null && stat2 != null) 
        { SequenceStatement stat = new SequenceStatement(); 
          stat.addStatement(stat1); 
          stat.addStatement(stat2); 
          statement = stat; 
          return "" + stat; 
        }

        if (se1 != null) 
        { statement = stat1; 
          return se1; 
        } 

        statement = stat2; 
        return se2;  
      } 
      else if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        String res = call.preSideEffect();
        statement = call.statement;
        return res;  
      } 
      else if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // brackets
        ASTTerm call = (ASTTerm) terms.get(1);
        String res = call.preSideEffect();
        statement = call.statement;
        return res;  
      } 
      else if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        String se1 = arr.preSideEffect();
        Statement stat1 = arr.statement;  
        String se2 = ind.preSideEffect(); 
        Statement stat2 = ind.statement;  
        
        if (se1 == null && se2 == null) 
        { return null; }  
        
        if (se1 != null && se2 != null) 
        { if (stat1 != null && stat2 != null) 
          { SequenceStatement stat = new SequenceStatement(); 
            stat.addStatement(stat1); 
            stat.addStatement(stat2); 
            statement = stat; 
          }
          return se1 + " ; " + se2; 
        }
 
        if (se1 != null) 
        { statement = arr.statement; 
          return se1; 
        }
  
        statement = ind.statement; 
        return se2;  
      }
      else if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        String condx = cond.preSideEffect(); 
        String ifx = ifoption.preSideEffect(); 
        String elsex = elseoption.preSideEffect();
          
        if (condx == null && ifx == null && elsex == null) 
        { return null; } 
 
        if (cond.statement == null && 
            ifoption.statement == null && 
            elseoption.statement == null) 
        { statement = null; 
          return null; 
        }  
        
        String res = ""; 
        SequenceStatement stat = new SequenceStatement(); 

        if (condx != null) 
        { res = res + condx;
          if (cond.statement != null) 
          { stat.addStatement(cond.statement); }  
        } 

        if (ifx != null)
        { if (res.length() > 0)
          { res = res + " ; " + ifx; } 
          else 
          { res = ifx; } 

          if (ifoption.statement != null) 
          { stat.addStatement(ifoption.statement); }  
        } 

        if (elsex != null) 
        { if (res.length() > 0)
          { res = res + " ; " + elsex; } 
          else 
          { res = elsex; } 

          if (elseoption.statement != null) 
          { stat.addStatement(elseoption.statement); }  
        }  

        
        if (stat.getStatements().size() == 1) 
        { statement = (Statement) stat.getStatement(0); } 
        else 
        { statement = stat; } 

        return res; 
      } 
    } 

    statement = null; 
    return ""; 
  } 

  public String postSideEffect()
  { if ("methodCall".equals(tag))
    { 
      String called = terms.get(0) + "";
      ASTTerm callargs = (ASTTerm) terms.get(2);
      Vector cargs = getCallArguments(callargs); 

      if ("replaceAll".equals(called))
      { System.out.println(">>> methodCall " + called + " has side-effect."); 

        ASTTerm callarg1 = (ASTTerm) cargs.get(0); 
        String callp1 = callarg1.toKM3(); 

        ASTTerm.setType(this,
                          ASTTerm.getType(callarg1)); 
          
        if (cargs.size() > 2) 
        { ASTTerm obj = (ASTTerm) cargs.get(1); 
          ASTTerm rep = (ASTTerm) cargs.get(2);
          String objx = obj.toKM3(); 
          String repx = rep.toKM3();

          if (callarg1.expression != null && 
                obj.expression != null &&  
                rep.expression != null) 
          { Expression xexp = 
                BasicExpression.newVariableBasicExpression("x_1"); 
            Expression eq = 
                new BinaryExpression("=", xexp, obj.expression); 
            Expression conde = 
                new ConditionalExpression(eq,rep.expression,xexp);
            Expression domexpr = 
                new BinaryExpression(":", xexp, callarg1.expression);  
            expression = 
                new BinaryExpression("|C", domexpr, conde); 
            statement = 
                new AssignStatement(callarg1.expression, expression); 
          } 
 
          return callp1 + " := " + callp1 + "->collect(x_1 | if x_1 = " + objx + " then " + repx + " else x_1 endif )"; 
        }
        return callp1;  
      }

      return null; 
    } 
    
    if ("primary".equals(tag) || "parExpression".equals(tag)) 
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        String se = tt.postSideEffect(); 
        if (se != null) 
        { expression = tt.expression; 
          statement = tt.statement; 
          return se; 
        } 
      } 
    } 

    if ("variableInitializer".equals(tag))
    { ASTTerm t = (ASTTerm) terms.get(0); 
      String res = t.postSideEffect(); 
      statement = t.statement; 
      return res;          
    }

    if ("expression".equals(tag))
    { if (terms.size() == 1) // Identifier or literal
      { 
        ASTTerm t = (ASTTerm) terms.get(0); 
        String res = t.postSideEffect();         
        expression = t.expression; 
        statement = t.statement; 
        return res; 
      } 
   
      if (terms.size() == 2) // UnaryExpression
      { ASTTerm op = (ASTTerm) terms.get(0); 
        ASTTerm arg = (ASTTerm) terms.get(1);

        String op1 = op.queryForm(); 
        
        if ("++".equals(arg.literalForm()))
        { if (op.expression != null) 
          { expression = new BinaryExpression("+", 
                              op.expression, unitExpression); 
            statement = 
              new AssignStatement(op.expression, expression);
          }  
          return op1 + " := " + op1 + " + 1"; 
        }
 
        if ("--".equals(arg.literalForm()))
        { if (op.expression != null) 
          { expression = new BinaryExpression("-", 
                              op.expression, unitExpression); 
            statement = 
              new AssignStatement(op.expression, expression);
          }  
          return op1 + " := " + op1 + " - 1"; 
        }
      }  
      else if (terms.size() == 3) // BinaryExpression
      { ASTTerm op = (ASTTerm) terms.get(1); 
        ASTTerm arg1 = (ASTTerm) terms.get(0);
        ASTTerm arg2 = (ASTTerm) terms.get(2); 

        if (".".equals(terms.get(1) + ""))
        { if ("Collections".equals(arg1.literalForm()) && 
              arg2.hasSideEffect())
          { String res = arg2.postSideEffect(); 
            statement = arg2.statement; 
            return res; 
          }  
        } 
      

        String se1 = arg1.postSideEffect(); 
        String se2 = arg2.postSideEffect();
        
        if (se1 == null && se2 == null) 
        { return null; }  
        
        if (se1 != null && se2 != null) 
        { if (arg1.statement != null && arg2.statement != null) 
          { statement = new SequenceStatement(); 
            ((SequenceStatement) statement).addStatement(arg1.statement); 
            ((SequenceStatement) statement).addStatement(arg2.statement);
          }
          return se1 + " ; " + se2; 
        } 

        if (se1 != null) 
        { statement = arg1.statement; 
          return se1; 
        }

        statement = arg2.statement;  
        return se2;  
      } 
      else if (terms.size() == 4 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { // casting 
        ASTTerm call = (ASTTerm) terms.get(3);
        String res = call.postSideEffect();
        statement = call.statement; 
        /* JOptionPane.showInputDialog("Post side effect of " + 
                    this + 
                    " = " + res + " " + statement); */  
        return res;  
      } 
      else if (terms.size() == 3 && 
          "(".equals(terms.get(0) + "") &&
          ")".equals(terms.get(2) + ""))
      { 
        ASTTerm call = (ASTTerm) terms.get(1);
        String res = call.postSideEffect();
        statement = call.statement; 
        return res;  
      } 
      else if (terms.size() == 4 && 
          "[".equals(terms.get(1) + "") && 
          "]".equals(terms.get(3) + "")) // array access
      { ASTTerm arr = (ASTTerm) terms.get(0); 
        ASTTerm ind = (ASTTerm) terms.get(2);

        String se1 = arr.postSideEffect(); 
        String se2 = ind.postSideEffect(); 
        
        if (se1 == null && se2 == null) 
        { return null; }  
        
        if (se1 != null && se2 != null) 
        { if (arr.statement != null && ind.statement != null) 
          { statement = new SequenceStatement(); 
            ((SequenceStatement) statement).addStatement(arr.statement); 
            ((SequenceStatement) statement).addStatement(ind.statement);
          } 

          return se1 + " ; " + se2; 
        }
 
        if (se1 != null) 
        { statement = arr.statement; 
          return se1; 
        } 

        statement = ind.statement; 
        return se2;  
      }
      else if (terms.size() == 5 && "?".equals(terms.get(1) + ""))
      { // ConditionalExpression
        ASTTerm cond = (ASTTerm) terms.get(0); 
        ASTTerm ifoption = (ASTTerm) terms.get(2);
        ASTTerm elseoption = (ASTTerm) terms.get(4);
        String condx = cond.postSideEffect(); 
        String ifx = ifoption.postSideEffect(); 
        String elsex = elseoption.postSideEffect();
          
        if (condx == null && ifx == null && elsex == null) 
        { return null; }  
        
        if (cond.statement == null && 
            ifoption.statement == null && 
            elseoption.statement == null) 
        { statement = null; 
          return null; 
        }  

        String res = ""; 
        SequenceStatement stat = new SequenceStatement(); 

        if (condx != null) 
        { res = res + condx;
          if (cond.statement != null) 
          { stat.addStatement(cond.statement); }  
        } 

        if (ifx != null)
        { if (res.length() > 0)
          { res = res + " ; " + ifx; } 
          else 
          { res = ifx; } 
          if (ifoption.statement != null) 
          { stat.addStatement(ifoption.statement); }  
        } 

        if (elsex != null) 
        { if (res.length() > 0)
          { res = res + " ; " + elsex; } 
          else 
          { res = elsex; } 
          if (elseoption.statement != null) 
          { stat.addStatement(elseoption.statement); }  
        }  

        if (stat.getStatements().size() == 1) 
        { statement = (Statement) stat.getStatement(0); } 
        else 
        { statement = stat; } 

        return res; 
      } 
    } 

    return null; 
  } 

  public static boolean isCollectionsWrapperOp(String op)
  { Vector wops = new Vector(); 
    wops.add("synchronizedCollection"); 
    wops.add("synchronizedList"); 
    wops.add("synchronizedSet"); 
    wops.add("synchronizedMap"); 
    wops.add("synchronizedSortedSet"); 
    wops.add("synchronizedSortedMap"); 

    wops.add("unmodifiableCollection"); 
    wops.add("unmodifiableList"); 
    wops.add("unmodifiableSet"); 
    wops.add("unmodifiableMap"); 
    wops.add("unmodifiableSortedSet"); 
    wops.add("unmodifiableSortedMap"); 
    return wops.contains(op); 
  } 

  public String caseStatementstoKM3(String etest, Expression swtest, Vector terms, Vector statements)
  { // From position 3, a series of switchBlockStatementGroup.
    String res = ""; 

    Vector stats = new Vector();

    Vector remainingTerms = new Vector(); 
    remainingTerms.addAll(terms); 
    remainingTerms.remove(0); // switch
    remainingTerms.remove(0); // (parExpression ...)
    remainingTerms.remove(0); // {
    
    for (int i = 2; i < terms.size(); i++)
    { if (terms.get(i) instanceof ASTCompositeTerm)
      { ASTCompositeTerm sbsg = (ASTCompositeTerm) terms.get(i); 
        remainingTerms.remove(0); 
        stats.add(sbsg.switchBlocktoKM3(etest,swtest,remainingTerms));

        if (sbsg.statement != null) 
        { statements.add(sbsg.statement); }     
      } 
    } 

    for (int j = 0; j < stats.size(); j++) 
    { String stat = (String) stats.get(j); 
      res = res + stat;
      if (j < stats.size() - 1) 
      { res = res + ";\n"; }  
    }   

    return res;
  }  
     
  private String switchBlocktoKM3(String etest, Expression swtest, Vector followingBlocks)
  { String res = ""; 
    if ("switchBlockStatementGroup".equals(tag))
    { // (switchBlockStatementGroup (switchLabel ...)* (blockStatement ...)*
      // accumulate all the tests. 
      // Then accumulate the longest series of statements
      // without a break to the end of the switch
      // (followingBlocks). 

      Vector tests = new Vector(); 
      Vector statements = new Vector(); 

      Vector exprs = new Vector(); 
      Vector stats = new Vector(); 
      boolean hasBreak = false; 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm cx = (ASTTerm) terms.get(i); 
        if ((cx instanceof ASTCompositeTerm) && 
            ((ASTCompositeTerm) cx).tag.equals("switchLabel") && 
             "case".equals(((ASTCompositeTerm) cx).terms.get(0) + ""))
        { ASTCompositeTerm slabel = (ASTCompositeTerm) cx; 
          ASTTerm sexpr = (ASTTerm) slabel.terms.get(1);
          String sval = sexpr.toKM3(); 
          tests.add("(" + etest + " = " + sval + ")"); 
          
          if (swtest != null && sexpr.expression != null) 
          { BinaryExpression texpr = 
              new BinaryExpression("=", swtest, sexpr.expression); 
            texpr.setBrackets(true); 
            exprs.add(texpr);  
          }
        }  
        else if ((cx instanceof ASTCompositeTerm) && 
                 ((ASTCompositeTerm) cx).tag.equals("blockStatement"))
        { statements.add(cx.toKM3()); 
          if (cx.statement != null) 
          { stats.add(cx.statement);
            if (cx.statement instanceof BreakStatement)
            { hasBreak = true; }
          } 
        } 
      }

      if (!hasBreak)
      { System.out.println(">>> Need to continue branch for " + tests + " into following statements: " + followingBlocks); 
        getContinuedSwitchCode(followingBlocks,statements,stats); 
      }


      String sequenceStatement = ""; 
      for (int j = 0; j < statements.size(); j++) 
      { String stat = (String) statements.get(j); 

        sequenceStatement = sequenceStatement + 
          "      " + stat; 
        if (j < statements.size() - 1)
        { sequenceStatement = sequenceStatement + " ;\n"; } 
        else 
        { sequenceStatement = sequenceStatement + "\n"; } 
      }

      SequenceStatement sq = new SequenceStatement(stats); 

      // if ("or" of tests) then statements else skip
      if (tests.size() > 0)
      { Expression condexpr = new BasicExpression(false); 

        String cond = ""; 
        for (int j = 0; j < tests.size(); j++) 
        { cond = cond + tests.get(j);
 
          if (j < tests.size() - 1) 
          { cond = cond + " or "; } 

          if (j < exprs.size())
          { Expression cexpr = (Expression) exprs.get(j); 
            condexpr = Expression.simplifyOr(condexpr,cexpr);
          }  
        }


        InvocationStatement skp = new InvocationStatement("skip"); 

        statement = new ConditionalStatement(condexpr, sq, skp); 

        return "    if " + cond + " then\n" + 
               sequenceStatement + 
               "    else skip ";  
      } 
      else 
      { statement = sq; 
        return sequenceStatement; 
      } 
    }
    return res;  
  }

  static void getContinuedSwitchCode(Vector followingBlocks, Vector statements, Vector stats)
  { for (int i = 0; i < followingBlocks.size(); i++) 
    { ASTTerm trm = (ASTTerm) followingBlocks.get(i); 
      if (trm instanceof ASTCompositeTerm)
      { ASTCompositeTerm sbsg = (ASTCompositeTerm) trm;
        if ("switchBlockStatementGroup".equals(sbsg.getTag())) 
        { boolean hasBreak = 
            getContinuedSwitchBlockCode(sbsg.terms, statements,stats);
          if (hasBreak) 
          { return; }
        }   
      } 
    } 
  }

  private Statement ccasestatementToKM3(Expression svar, 
            java.util.Map vt, java.util.Map vet, 
            Vector types, Vector entities)
  { // case t1 : case t2 : stat becomes 
    // if (svar = t1) or (svar = t2) then stat' else ...

    if ("blockItem".equals(tag))
    { ASTCompositeTerm cx = (ASTCompositeTerm) terms.get(0); 
      return cx.ccasestatementToKM3(
                         svar,vt,vet,types,entities);
    } 

    if ("statement".equals(tag))
    { ASTCompositeTerm cx = (ASTCompositeTerm) terms.get(0); 
      return cx.ccasestatementToKM3(
                         svar,vt,vet,types,entities);
    }

    if ("labeledStatement".equals(tag) && 
        terms.size() == 4) 
    { ASTTerm keywd = (ASTTerm) terms.get(0);
      String keyword = keywd.literalForm();  
      if ("case".equals(keyword)) 
      { // case val : stat
        ASTTerm cval = (ASTTerm) terms.get(1); 
        ASTCompositeTerm cstat = 
           (ASTCompositeTerm) terms.get(3); 
        Expression cexpr = cval.cexpressionToKM3(
              vt, vet, types, entities); 
        Statement caction = cstat.ccasestatementToKM3(
              svar, vt, vet, types, entities);
        Expression ctest = 
          new BinaryExpression("=", svar, cexpr); 
        Statement skipstat = 
          new InvocationStatement("skip");
  
        if (cstat.literalForm().startsWith("case"))
        { Statement res = 
            ConditionalStatement.mergeConditionals(ctest,
                                                   caction); 
          return res; 
        } 

        ConditionalStatement cs = 
          new ConditionalStatement(ctest, caction, skipstat); 
        return cs; 
      } 
    } 

    return cstatementToKM3(vt, vet, types, entities); 
  }  

  private Statement cswitchstatementToKM3(Expression svar, 
            java.util.Map vt, java.util.Map vet, 
            Vector types, Vector entities)
  { Vector stats = new Vector(); 

    if ("statement".equals(tag))
    { ASTCompositeTerm ct = (ASTCompositeTerm) terms.get(0); 
      return ct.cswitchstatementToKM3(
                  svar,vt,vet,types,entities); 
    } 

    if ("compoundStatement".equals(tag) && 
        terms.size() == 3 && 
        "{".equals(terms.get(0) + "") && 
        "}".equals(terms.get(2) + "")) 
    { ASTCompositeTerm ct = (ASTCompositeTerm) terms.get(1); 
      return ct.cswitchstatementToKM3(
                  svar,vt,vet,types,entities); 
    } 
    

    if ("blockItemList".equals(tag))
    { // (blockItemList (blockItem ...) (blockItem ...) ...
      // accumulate all the items which are case tests. 
      // Then accumulate the longest series of following 
      // statements
      // without a break to the end of the switch
      // (followingBlocks). 

      Vector tests = new Vector(); 

      Vector exprs = new Vector(); 
      Statement lastConditional = null;  

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm cx = (ASTTerm) terms.get(i); 

        System.out.println(">> switch term: " + cx); 

        if ((cx instanceof ASTCompositeTerm) && 
            cx.literalForm().startsWith("case"))
        { // System.out.println(">> Case test: " + cx); 
          // System.out.println();  
          ASTCompositeTerm sterm = (ASTCompositeTerm) cx; 

          /* ASTTerm sexpr = (ASTTerm) slabel.terms.get(0);
          Expression sval = sexpr.cexpressionToKM3(vt,vet,
                                             types,entities);
          if (sval != null) 
          { Expression test = 
              new BinaryExpression("=", svar, sval);   
            exprs.add(test); 
          }  */
 
          Statement ifstat = 
            sterm.ccasestatementToKM3(
                             svar,vt,vet,types,entities); 
          if (ifstat != null) 
          { stats.add(ifstat); 
            lastConditional = ifstat; 
          }  
        } // Could be more in the statement part of cx. 
        else if ((cx instanceof ASTCompositeTerm) && 
            cx.literalForm().startsWith("default"))
        { System.out.println(">> Case test: " + cx); 
          System.out.println();  
          Statement brk = cx.cstatementToKM3(
                            vt,vet,types,entities);
          stats.add(brk); 
        } 
        else if (cx instanceof ASTCompositeTerm)
        { Statement brk = cx.cstatementToKM3(
                            vt,vet,types,entities);
          if (brk instanceof BreakStatement)
          { ConditionalStatement.addToIfBranch(
                                   lastConditional,brk); 
          }
          else 
          { stats.add(brk); }   
        } 
      }

    }

    /*  if (!hasBreak)
      { System.out.println(">>> Need to continue branch for " + tests + " into following statements: " + followingBlocks); 
        getContinuedSwitchCode(followingBlocks,statements,stats); 
      }


      String sequenceStatement = ""; 
      for (int j = 0; j < statements.size(); j++) 
      { String stat = (String) statements.get(j); 

        sequenceStatement = sequenceStatement + 
          "      " + stat; 
        if (j < statements.size() - 1)
        { sequenceStatement = sequenceStatement + " ;\n"; } 
        else 
        { sequenceStatement = sequenceStatement + "\n"; } 
      }

      SequenceStatement sq = new SequenceStatement(stats); 

      // if ("or" of tests) then statements else skip
      if (tests.size() > 0)
      { Expression condexpr = new BasicExpression(false); 

        String cond = ""; 
        for (int j = 0; j < tests.size(); j++) 
        { cond = cond + tests.get(j);
 
          if (j < tests.size() - 1) 
          { cond = cond + " or "; } 

          if (j < exprs.size())
          { Expression cexpr = (Expression) exprs.get(j); 
            condexpr = Expression.simplifyOr(condexpr,cexpr);
          }  
        }


        InvocationStatement skp = new InvocationStatement("skip"); 

        statement = new ConditionalStatement(condexpr, sq, skp); 

        return "    if " + cond + " then\n" + 
               sequenceStatement + 
               "    else skip ";  
      } 
      else 
      { statement = sq; 
        return sequenceStatement; 
      } 
    } */ 

    SequenceStatement res = 
         new SequenceStatement(stats); 
    return res;  
  }

  static void getContinuedSwitchCodeC(Vector followingBlocks, 
      Vector statements, Vector stats,
      java.util.Map vt, java.util.Map vet, Vector types,
      Vector entities)
  { for (int i = 0; i < followingBlocks.size(); i++) 
    { ASTTerm trm = (ASTTerm) followingBlocks.get(i); 
      if (trm instanceof ASTCompositeTerm)
      { ASTCompositeTerm sbsg = (ASTCompositeTerm) trm;
        if (sbsg.literalForm().startsWith("case")) 
        { boolean hasBreak = 
            getContinuedSwitchBlockCodeC(
              sbsg.terms, statements,stats,
              vt,vet,types,entities);
          if (hasBreak) 
          { return; }
        }   
      } 
    } 
  }

  static boolean getContinuedSwitchBlockCode(Vector blockElements, Vector statements, Vector stats)
  { for (int i = 0; i < blockElements.size(); i++) 
    { ASTTerm trm = (ASTTerm) blockElements.get(i); 
      if (trm instanceof ASTCompositeTerm) 
      { ASTCompositeTerm sbelem = (ASTCompositeTerm) trm; 
        if ("switchLabel".equals(sbelem.getTag())) { } 
        else if ("blockStatement".equals(sbelem.getTag()))
        { String extraStat = sbelem.toKM3(); 
          statements.add(extraStat); 

          if (sbelem.statement != null) 
          { stats.add(sbelem.statement); } 
          if (sbelem.statement instanceof BreakStatement) 
          { return true; } // or return
        }  
      } 
    } 
    return false; 
  }

  static boolean getContinuedSwitchBlockCodeC(
     Vector blockElements, Vector statements, Vector stats,
     java.util.Map vt, java.util.Map vet, Vector types,
     Vector entities)
  { for (int i = 0; i < blockElements.size(); i++) 
    { ASTTerm trm = (ASTTerm) blockElements.get(i); 
      if (trm instanceof ASTCompositeTerm) 
      { ASTCompositeTerm sbelem = (ASTCompositeTerm) trm; 
        if (sbelem.literalForm().startsWith("case")) { } 
        else if ("blockItem".equals(sbelem.getTag()))
        { Statement extraStat = 
             sbelem.cstatementToKM3(vt,vet,types,entities); 
          statements.add(extraStat); 

          if (extraStat != null) 
          { stats.add(extraStat); } 
          if (extraStat instanceof BreakStatement) 
          { return true; } // or return
        }  
      } 
    } 
    return false; 
  }
      

  public boolean isIdentifier()
  { if ("primary".equals(tag) && 
        terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      String value = t.literalForm(); 
      if (value.length() > 0 && 
          Character.isJavaIdentifierStart(value.charAt(0)))
      { return true; } 
      return false; 
    } 
    
    if ("expression".equals(tag) && 
        terms.size() == 1)
    { ASTTerm t = (ASTTerm) terms.get(0); 
      return t.isIdentifier(); 
    }
 
    return false; 
  } 

  public String toKM3type()
  { // JOptionPane.showInputDialog("+++ toKM3type on term " + this); 

    if ("creator".equals(tag) || "innerCreator".equals(tag))
    { // 2 arguments, the type, and any constructor pars
      return creatorQueryForm(); 
    } 

    if ("createdName".equals(tag))
    { return creatorQueryForm(); } 
    // Ignores type parameters in creation. 

    if ("classCreatorRest".equals(tag))
    { return creatorQueryForm(); } 

    if ("typeType".equals(tag))
    { if (terms.size() == 2 && 
          ((ASTTerm) terms.get(0)).hasTag("annotation"))
      { ASTTerm rest = (ASTTerm) terms.get(1); 
        String resx = rest.toKM3type();
        modelElement = rest.modelElement; 
        expression = rest.expression; 
        return resx; 
      } 

      if (terms.size() >= 3 && 
          "[".equals(terms.get(1) + "") &&
          "]".equals(terms.get(2) + ""))
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        Type elementType = null; 
        if (typeTerm.modelElement instanceof Type) 
        { elementType = (Type) typeTerm.modelElement; } 
        else if (typeTerm.modelElement instanceof Entity)
        { elementType = new Type((Entity) typeTerm.modelElement); } 

        for (int i = 1; i+1 < terms.size(); i = i + 2) 
        { if ((terms.get(i) + "").equals("[") &&
              (terms.get(i+1) + "").equals("]"))
          { tt = "Sequence(" + tt + ")"; 

            modelElement = new Type("Sequence", null);
            if (elementType != null) 
            { ((Type) modelElement).setElementType(elementType); }
            elementType = (Type) modelElement;   
          } 
        } 
        return tt;  
      } 
      
      if (terms.size() == 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement;
        expression = typeTerm.expression; 
        // System.out.println("Type: " + modelElement); 
        // System.out.println(expression); 
        // System.out.println(); 
        return tt; 
      } 
    } 

    if ("typeTypeOrVoid".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement;
        expression = typeTerm.expression;  
        return tt; 
      } 
    } 

    if ("classType".equals(tag))
    { if (terms.size() > 1)
      { ASTTerm t0 = (ASTTerm) terms.get(0); 
        if (t0.hasTag("annotation"))
        { Vector tailterms = new Vector(); 
          tailterms.addAll(terms); 
          tailterms.remove(0); 
          ASTCompositeTerm rem = new ASTCompositeTerm("classOrInterfaceType", tailterms); 
          String res = rem.toKM3type(); 
          modelElement = rem.modelElement; 
          expression = rem.expression; 
          return res; 
        } 
        else if (terms.size() > 2 && 
                 ".".equals(terms.get(1) + ""))
        { Vector tailterms = new Vector(); 
          tailterms.addAll(terms); 
          tailterms.remove(0); 
          tailterms.remove(0); 
          ASTCompositeTerm rem = 
            new ASTCompositeTerm("classOrInterfaceType", tailterms); 
          String res = rem.toKM3type(); 
          modelElement = rem.modelElement; 
          expression = rem.expression; 
          return res; 
        }
      }  
      Vector tailterms = new Vector(); 
      tailterms.addAll(terms); 
      ASTCompositeTerm rem = 
        new ASTCompositeTerm("classOrInterfaceType", tailterms); 
      String res = rem.toKM3type(); 
      modelElement = rem.modelElement; 
      expression = rem.expression; 
      return res;
    }   


    if ("classOrInterfaceType".equals(tag))
    { if (terms.size() == 3 && ".".equals(terms.get(1) + ""))  
      { // A relativised type T.S
        ASTTerm baseType = (ASTTerm) terms.get(2); 
        String btype = baseType.toKM3type();
        modelElement = baseType.modelElement; 
        if (modelElement instanceof Type) 
        { expression = new BasicExpression((Type) modelElement); } 
        else if (modelElement instanceof Entity)
        { expression = new BasicExpression((Entity) modelElement); } 

        System.out.println("+++ Model element of " + this + " is: " + modelElement); 

        return btype; 
      }  
      else if (terms.size() > 3 && ".".equals(terms.get(1) + ""))  
      { // A relativised type T.S
        Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        tailterms.remove(0); 

        ASTTerm tailast = 
          new ASTCompositeTerm(
                  "classOrInterfaceType", tailterms);
 
        String resx = tailast.toKM3type();
        modelElement = tailast.modelElement; 
        expression = tailast.expression; 
        return resx; 
      }        
      else if (terms.size() > 3 && ".".equals(terms.get(2) + ""))  
      { // A relativised type T<pars>.S
        Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        tailterms.remove(0); 
        tailterms.remove(0); 

        ASTTerm tailast = 
          new ASTCompositeTerm(
                  "classOrInterfaceType", tailterms);
 
        String resx = tailast.toKM3type();
        modelElement = tailast.modelElement; 
        expression = tailast.expression; 
        return resx; 
      }        
      else if (terms.size() > 1 && 
               terms.get(1) instanceof ASTCompositeTerm && 
               "typeArguments".equals(
                  ((ASTTerm) terms.get(1)).getTag()))  
      { // parameterised type  T (typeArguments < pars >)

        ASTTerm baseType = (ASTTerm) terms.get(0); 
        ASTCompositeTerm typepars = 
             (ASTCompositeTerm) terms.get(1);
        String pars = typepars.toKM3type();
        
        Vector targs = 
          ((ASTCompositeTerm) typepars).getTypeParameterTypes(); 

        System.out.println(); 

        System.out.println("+++ Parameterised type with parameters " + pars + " " + targs); 
        System.out.println(); 
 
        String btype = baseType.toKM3type();
        String res = btype; 

        modelElement = baseType.modelElement; 
        expression = baseType.expression; // Not valid

        if (modelElement == null) 
        { modelElement = Type.getTypeFor(btype,
                   ASTTerm.enumtypes,ASTTerm.entities); 
        } 

        if (modelElement == null) 
        { modelElement = 
            ModelElement.lookupByName(btype,ASTTerm.entities); 
        } 

        System.out.println(">+++> Base type with parameters " + btype + " " + modelElement);
        System.out.println(); 


        if ("Class".equals(baseType.literalForm()))
        { modelElement = new Type("OclType", null); 
          return "OclType";
        } 

        if ("Pair".equals(baseType.literalForm()) ||
            "Triple".equals(baseType.literalForm()))
        { modelElement = new Type("Map", null);
          Type ktype = new Type("String", null);  
          Type etype = (Type) targs.get(1); 
          ((Type) modelElement).setKeyType(ktype); 
          ((Type) modelElement).setElementType(etype);
          return "Map(String," + etype + ")"; 
        } 


        if (modelElement == null && 
            Entity.validEntityName(btype)) 
        { modelElement = new Entity(btype); 
          entities.add(modelElement); 
          modelElement = new Type((Entity) modelElement); 
        } 

        // The *same* model element is used for different 
        // parameter instantiations btype<T1>, btype<T2> etc

        if (modelElement != null)
        { if (targs.size() > 1 && 
              modelElement instanceof Type && 
              ((Type) modelElement).isMap()) 
          { Type ktype = (Type) targs.get(0); 
            Type etype = (Type) targs.get(1); 
            ((Type) modelElement).setKeyType(ktype); 
            ((Type) modelElement).setElementType(etype);
            res = btype + "(" + ktype + "," + etype + ")"; 
            expression = new BasicExpression(
                                  (Type) modelElement); 
          }  
          else if (targs.size() > 1 && 
                   modelElement instanceof Type && 
                   ((Type) modelElement).isFunction()) 
          { Type ktype = (Type) targs.get(0); 
            Type etype = (Type) targs.get(1); 
            ((Type) modelElement).setKeyType(ktype); 
            ((Type) modelElement).setElementType(etype);
            res = btype + "(" + ktype + "," + etype + ")"; 
            expression = new BasicExpression(
                                  (Type) modelElement); 
          }  
          else if (targs.size() > 0 && 
                   modelElement instanceof Type && 
                   ((Type) modelElement).isCollectionType()) 
          { Type etype = (Type) targs.get(0); 
            ((Type) modelElement).setElementType(etype);
            res = btype + "(" + etype + ")"; 
            expression = new BasicExpression(
                                  (Type) modelElement); 
          }  
          else if (modelElement instanceof Type) 
          { Entity ent = 
              (Entity) ModelElement.lookupByName(
                                      btype,  
                                      ASTTerm.entities); 
            if (ent == null) 
            { ent = new Entity(btype); 
              ASTTerm.entities.add(ent); 
            } 
  
            if (ent.hasTypeParameters(targs))
            { modelElement = new Type(ent); }
            else        
            { Entity newent = new Entity(btype); 
              newent.setTypeParameters(targs);
              modelElement = new Type(newent); 
            }  
            res = btype + "<" + pars + ">"; 
            expression = new BasicExpression(
                                  (Type) modelElement); 
          }
          else if (modelElement instanceof Entity)
          { Entity ent = (Entity) modelElement; 
            if (ent.hasTypeParameters(targs))
            { modelElement = new Type(ent); }
            else        
            { Entity newent = new Entity(btype); 
              newent.setTypeParameters(targs);
              modelElement = new Type(newent); 
            }  
            res = btype + "<" + pars + ">"; 
            expression = new BasicExpression(
                                  (Type) modelElement); 
          } 

        }  

        System.out.println("+++ Parameterised type: " + modelElement);
        System.out.println("+++ as expression: " + expression); 
        System.out.println(); 

        return res; 
      }
      
      ASTTerm t0 = (ASTTerm) terms.get(0);
      String res = t0.toKM3type();
      modelElement = t0.modelElement;
      expression = t0.expression;  
      return res;  
    } 
 
    if ("typeArguments".equals(tag) && terms.size() > 1 && 
        "<".equals(terms.get(0) + ""))
    { // < arg >   or   < arg1 , arg2 >
      modelElements = new Vector(); 
      String res = ""; 
      for (int i = 1; i < terms.size()-1; i++)
      { ASTTerm typepar0 = (ASTTerm) terms.get(i); 
        res = res + typepar0.toKM3type();

        if (typepar0 instanceof ASTSymbolTerm) { } 
        else 
        { modelElement = typepar0.modelElement; 
          if (modelElement != null) 
          { modelElements.add(modelElement); } 
          System.out.println("+++ Type parameter: " + typepar0.modelElement); 
        } 
      } 

      return res; 
    } 

    if ("nonWildcardTypeArguments".equals(tag) && 
        terms.size() > 2)
    { // < typelist >
      ASTTerm typepar0 = (ASTTerm) terms.get(1); 
      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
      modelElements = typepar0.modelElements; 
 
      return res; 
    } 


    if ("typeArgument".equals(tag) && terms.size() > 0)
    { // a (typeType _1)
      ASTTerm typepar0 = (ASTTerm) terms.get(0); 

      if (typepar0.hasTag("annotation"))
      { Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        ASTCompositeTerm tailast = 
          new ASTCompositeTerm("typeArgument", tailterms); 
        String resx = tailast.toKM3type(); 
        modelElement = tailast.modelElement; 
        return resx; 
      } 

      if (terms.size() == 3 && 
          "?".equals(typepar0.literalForm()) && 
          ("extends".equals(terms.get(1) + "") ||
           "super".equals(terms.get(1) + "") ) )
      { typepar0 = (ASTTerm) terms.get(2); } 

      String res = typepar0.toKM3type();
      modelElement = typepar0.modelElement; 
 
      return res; 
    } 

    if ("createdName".equals(tag))
    { ASTTerm mainclass = (ASTTerm) terms.get(0);
      if (terms.size() > 2 && 
          ".".equals(terms.get(1) + ""))
      { mainclass = (ASTTerm) terms.get(2); } 

      String res = mainclass.toKM3type();
      ASTTerm.setType(this,res);

      System.out.println("+++ Type of " + this + " is " + res); 

      Type typ; 
      Entity ent = 
        (Entity) ModelElement.lookupByName(
                        res, ASTTerm.entities); 
      if (ent != null) 
      { typ = new Type(ent); } 
      else if (ModelElement.lookupByName(res,ASTTerm.enumtypes) != null) 
      { typ = (Type) ModelElement.lookupByName(res,ASTTerm.enumtypes); } 
      else 
      { typ = new Type(res,null); } 

      modelElement = typ; 
      expression = new BasicExpression(res);
  
      if (terms.size() > 1 && 
          ((ASTTerm) terms.get(terms.size()-1)).hasTag(
                 "typeArgumentsOrDiamond")) 
      { // type arguments -- 
        // it must be a collection, function, 
        // map or  entity type

        if (typ.isSequenceType() || typ.isSetType())
        { ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 
          String elemT = t2.typeArgumentsToKM3ElementType(); 
        
          System.out.println("++ Collection creation element type = " + elemT); 
        
          Type et = 
            Type.getTypeFor(elemT,
               ASTTerm.enumtypes,ASTTerm.entities); 
          if (et != null) 
          { typ.setElementType(et); 
            res = res + "(" + elemT + ")"; 
          } 
        } 
        else if (typ.isMapType() || typ.isFunctionType())
        { ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 

          String allpars = t2.toKM3(); 

          System.out.println(">>> Object creation all pars = " + allpars); 

          if (t2.modelElements != null) 
          { typ.setTypeParameters(t2.modelElements); } 

          res = res + "(" + allpars + ")"; 
        }
        else 
        { 
          if (ent == null && Entity.validEntityName(res)) 
          { ent = new Entity(res);
            ASTTerm.entities.add(ent);
          } 

          modelElement = ent; 

          ASTTerm t2 = (ASTTerm) terms.get(terms.size()-1); 
        
          String allpars = t2.toKM3(); 

          System.out.println(">>> Object creation all pars = " + allpars); 

          if (t2.modelElements != null) 
          { ent.setTypeParameters(t2.modelElements); } 

          res = res + "<" + allpars + ">"; 
        } 
      } 

      return res; 
    } // Ignores type parameters in creation. 
    
    if ("typeParameters".equals(tag))
    { modelElements = new Vector();
        
      if (terms.size() == 3 && 
          "<".equals(terms.get(0) + "") && 
          ">".equals(terms.get(2) + "")) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(1); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement;
        if (modelElement == null) // new class
        { modelElement = new Entity(tt); 
          ((Entity) modelElement).setIsParameter(true); 
        }  
        modelElements.add(modelElement);

        System.out.println(">>> Type parameter: " + modelElement + " of " + typeTerm); 

        return "<" + tt + ">"; 
      } 

      if (terms.size() >= 3 && 
          "<".equals(terms.get(0) + ""))
      { String resx = "<";   
        for (int i = 1; i < terms.size()-1; i++) 
        { ASTTerm trm = (ASTTerm) terms.get(i); 
          if (trm instanceof ASTSymbolTerm) 
          { resx = resx + trm; } 
          else 
          { String tt = trm.toKM3type();
            modelElement = trm.modelElement;
            if (modelElement != null) 
            { modelElements.add(modelElement); } 
            else 
            { modelElement = new Entity(tt); 
              ((Entity) modelElement).setIsParameter(true);
              modelElements.add(modelElement);
            } 
            resx = resx + tt; 
          } 
        }  
        return resx + ">"; 
      } 

      return ""; 
    } 

    if ("typeParameter".equals(tag))
    { if (terms.size() == 1) 
      { ASTTerm tt = (ASTTerm) terms.get(0);
        String val = tt.literalForm();  
        modelElement = 
           Type.getTypeFor(val, ASTTerm.enumtypes, 
                           ASTTerm.entities); 

        if (modelElement == null && 
            Entity.validEntityName(val))
        { Entity ent = new Entity(val); 
          ent.setIsGenericParameter(true); 
          ASTTerm.entities.add(ent);
          modelElement = new Type(ent);  
        }  

        if (modelElement instanceof Type)
        { expression = 
            new BasicExpression((Type) modelElement); 
        }
  
        return val; 
      } 
      else if (terms.size() >= 3 && 
               "extends".equals(terms.get(1) + ""))
      { ASTTerm tt = (ASTTerm) terms.get(0); 
        String val = tt.literalForm();  
        modelElement = 
           Type.getTypeFor(val, ASTTerm.enumtypes, 
                           ASTTerm.entities); 

        if (modelElement == null && Entity.validEntityName(val))
        { Entity entpar = new Entity(val); 
          entpar.setIsGenericParameter(true); 
          ASTTerm.entities.add(entpar);
          modelElement = new Type(entpar);  
        }  

        if (modelElement instanceof Type)
        { expression = 
            new BasicExpression((Type) modelElement);
        } 
  
        return val; 
      } // These should be typeParameter entities
      else if (terms.size() >= 2 && 
               ((ASTTerm) terms.get(0)).hasTag("annotation"))
      { Vector tailterms = new Vector(); 
        tailterms.addAll(terms); 
        tailterms.remove(0); 
        ASTCompositeTerm tailast = 
              new ASTCompositeTerm("typeParameter", tailterms);
        String resx = tailast.toKM3type();
        expression = tailast.expression; 
        modelElement = tailast.modelElement; 
        return resx;  
      } 

      modelElement = new Type("OclAny", null);
      return "OclAny";  
    } 

    if ("typeBound".equals(tag))
    { if (terms.size() >= 1) 
      { ASTTerm typeTerm = (ASTTerm) terms.get(0); 
        String tt = typeTerm.toKM3type();
        modelElement = typeTerm.modelElement; 
        expression = typeTerm.expression; 
        return tt; 
      } 
    } 

    if ("typeList".equals(tag))
    { modelElements = new Vector();
        
      String resx = "";   
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTSymbolTerm) 
        { resx = resx + trm; } 
        else 
        { String tt = trm.toKM3type();
          modelElement = trm.modelElement;
          if (modelElement != null) 
          { modelElements.add(modelElement); }
          resx = resx + tt; 
        }  
      } 

      return resx; 
    } 

    return ""; 
  } 

  public Vector jsLabelFunctions(java.util.Map vtypes,
                                 java.util.Map vetypes,
                                 Vector types, 
                                 Vector entities)
  { Vector res = new Vector(); 

    if (terms.size() == 0)
    { return res; } 

    if ("functionBody".equals(tag) && 
        "{".equals(terms.get(0) + "") && 
        terms.get(1) instanceof ASTCompositeTerm)
    { ASTCompositeTerm body = (ASTCompositeTerm) terms.get(1); 
      // Entity ent = bf.getOwner(); 
      /* java.util.Map localvars = new java.util.HashMap(); 
      Vector pars = bf.getParameters();
      for (int i = 0; i < pars.size(); i++) 
      { Attribute att = (Attribute) pars.get(i); 
        localvars.put(att.getName(), att); 
      }  */ 

      return body.jsLabelFunctions(vtypes,vetypes,
                                   types,entities); 
    }

    if ("sourceElements".equals(tag) && terms.size() >= 1)
    { 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        
        if (t.isJSLabeledStatement())
        { // start new function from this point for the label
          String label = t.getJSLabel(); 
          ASTTerm labstat = t.getJSLabeledStatement(); 

          if (ModelElement.lookupByName(label,res) != null)
          { continue; } 

          Entity ent = 
            (Entity) 
                ModelElement.lookupByName(
                    "FromJavaScript", entities); 

          BehaviouralFeature bf = 
              new BehaviouralFeature(label); 
          bf.setParameters(vtypes); 
          bf.setPre(new BasicExpression(true)); 
          bf.setPost(new BasicExpression(true)); 
          bf.addStereotype("unsafe"); 
          // bf.setStatic(mbf.isStatic()); 
          ASTTerm.functionsInScope.add(bf);
          if (ent != null) 
          { ent.addOperation(bf); } 
 
          Vector tailterms = VectorUtil.vectorTail(i+1,terms); 
          ASTCompositeTerm act = 
                 new ASTCompositeTerm(tag, tailterms);

          System.out.println(">> Remaining code: " + act); 
 
          Vector stat0 = new Vector(); 
          if (labstat != null) 
          { stat0 = labstat.jsstatementToKM3(
                                        vtypes,vetypes,
                                        types,entities); 
          }
 
          Vector stats = act.jsstatementToKM3(vtypes,vetypes,
                                        types,entities);
          SequenceStatement caction = new SequenceStatement(); 
          if (labstat != null && stat0 != null) 
          { caction.addStatements(stat0); } 
          if (stats != null) 
          { caction.addStatements(stats); }   

          System.out.println(">> Label code action: " + caction); 
 
          Vector retvals = 
                 Statement.getReturnValues(caction); 

          System.out.println(">> Return values: " + retvals); 

          bf.setActivity(caction); 
          if (retvals != null && retvals.size() > 0)
          { Type retType = Type.determineType(retvals); 
            bf.setType(retType); 
          } 

          System.out.println(">>> Label function: " + bf.display()); 

          res.add(bf);
          // if (tailterms.size() > 1) 
          // { Vector remainingFunctions = 
          //           act.javaLabelFunctions(ent,mbf,vars); 
          //   res.addAll(remainingFunctions); 
          // } 
        } 
        else 
        // for localVariableDeclarations add to vars
        { t.jsstatementToKM3(vtypes,vetypes,
                             types,entities);
          Vector tailterms = VectorUtil.vectorTail(i+1,terms);
          if (tailterms.size() > 1) 
          { ASTCompositeTerm act = 
              new ASTCompositeTerm(tag, tailterms); 
            Vector rems = 
              act.jsLabelFunctions(
                       vtypes,vetypes,types,entities);
            res.addAll(rems);  
          }
        }          
      } 
    } 
 
    return res; 
  } 

  public boolean hasLabelFunctions(BehaviouralFeature bf)
  { if (terms.size() == 0)
    { return false; } 

    if ("methodBody".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm body = (ASTCompositeTerm) terms.get(0); 
      return body.hasJavaLabelFunctions(bf); 
    }   
    return false; 
  } 

  public boolean hasJavaLabelFunctions(
                                   BehaviouralFeature mbf)
  { 
    if (terms.size() == 0)
    { return false; } 
     
    if ("block".equals(tag) && terms.size() >= 1)
    { 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        if (t.isJavaLabeledStatement())
        { return true; } 
      } 
    } 

    return false; 
  }

  public Vector javaLabelFunctions(BehaviouralFeature bf)
  { if (terms.size() == 0)
    { return new Vector(); } 

    if ("methodBody".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm body = (ASTCompositeTerm) terms.get(0); 
      // Entity ent = bf.getOwner(); 
      java.util.Map localvars = new java.util.HashMap(); 
      Vector pars = bf.getParameters();
      for (int i = 0; i < pars.size(); i++) 
      { Attribute att = (Attribute) pars.get(i); 
        localvars.put(att.getName(), att); 
      }  
      return body.javaLabelFunctions(null,bf,localvars); 
    }
 
    return new Vector(); 
  } 

  public Vector javaLabelFunctions(Entity ent,
                                   BehaviouralFeature mbf, 
                                   java.util.Map vars)
  { Vector res = new Vector();

    if (terms.size() == 0)
    { return res; } 
     
    if ("block".equals(tag) && terms.size() >= 1)
    { 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        if (t.isLocalDeclarationStatement())
        { t.toKM3(); 
          if (t.modelElements != null) 
          { for (int j = 0; j < t.modelElements.size(); j++) 
            { ModelElement me = 
                 (ModelElement) t.modelElements.get(j);
              if (me instanceof Attribute)
              { vars.put(me.getName(), me); } 
            } 
          } 
        }  
        else if (t.isJavaLabeledStatement())
        { // start new function from this point for the label
          String label = t.getJavaLabel(); 
          ASTTerm labstat = t.getJavaLabeledStatement(); 

          if (ModelElement.lookupByName(label,res) != null)
          { continue; } 

          BehaviouralFeature bf = 
              new BehaviouralFeature(label); 
          if (ent != null) 
          { ent.refineOperation(bf);                        
            bf.setOwner(ent); 
          }
          bf.setParameters(vars); 
          bf.setPre(new BasicExpression(true)); 
          bf.setPost(new BasicExpression(true)); 
          bf.addStereotype("unsafe"); 
          bf.setStatic(mbf.isStatic()); 

          Vector tailterms = VectorUtil.vectorTail(i+1,terms); 
          ASTCompositeTerm act = 
                 new ASTCompositeTerm(tag, tailterms);

          System.out.println(">> Remaining code: " + act); 
 
          if (labstat != null) 
          { String stat0 = labstat.toKM3(); } 
          String stats = act.toKM3();
          SequenceStatement caction = new SequenceStatement(); 
          if (labstat != null && labstat.statement != null) 
          { caction.addStatement(labstat.statement); } 
          if (act.statement != null) 
          { caction.addStatement(act.statement); }   

          System.out.println(">> Label code action: " + caction); 
 
          Vector retvals = 
                 Statement.getReturnValues(caction); 

          System.out.println(">> Return values: " + retvals); 

          bf.setActivity(caction); 
          if (retvals != null && retvals.size() > 0)
          { Type retType = Type.determineType(retvals); 
            bf.setType(retType); 
          } 

          System.out.println(">>> Label function: " + bf.display()); 

          res.add(bf);
          // if (tailterms.size() > 1) 
          // { Vector remainingFunctions = 
          //           act.javaLabelFunctions(ent,mbf,vars); 
          //   res.addAll(remainingFunctions); 
          // } 
        } 
        else 
        // for localVariableDeclarations add to vars
        { // t.toKM3();
          Vector tailterms = VectorUtil.vectorTail(i+1,terms);
          if (tailterms.size() > 1) 
          { ASTCompositeTerm act = 
              new ASTCompositeTerm(tag, tailterms); 
            Vector rems = 
              act.javaLabelFunctions(ent,mbf,vars);
            res.addAll(rems);  
          }
        }          
      } 
    } 

    return res; 
  }

  public boolean isJavaLabeledStatement()
  { if ("blockStatement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.isJavaLabeledStatement(); 
    } 

    if ("statement".equals(tag) && terms.size() == 3 && 
        ":".equals(terms.get(1) + ""))
    { return true; } 

    return false; 
  } 

  public ASTTerm getJavaLabeledStatement()
  { if ("blockStatement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.getJavaLabeledStatement(); 
    } 

    if ("statement".equals(tag) && terms.size() == 3 && 
        ":".equals(terms.get(1) + ""))
    { return (ASTTerm) terms.get(2); } 

    return null; 
  } 

  public boolean isLocalDeclarationStatement()
  { if ("blockStatement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.isLocalDeclarationStatement(); 
    } 

    if ("localVariableDeclaration".equals(tag))
    { return true; } 

    return false; 
  } 

  public String getJavaLabel()
  { if ("blockStatement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.getJavaLabel(); 
    } 

    if ("statement".equals(tag) && terms.size() == 3 && 
        ":".equals(terms.get(1) + ""))
    { return terms.get(0) + ""; } 

    return null; 
  } 

  public boolean isJSLabeledStatement()
  { if ("sourceElement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.isJSLabeledStatement(); 
    } 

    if ("statement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.isJSLabeledStatement(); 
    } 

    if ("labelledStatement".equals(tag) && terms.size() == 3 && 
        ":".equals(terms.get(1) + ""))
    { return true; } 

    return false; 
  } 

  public ASTTerm getJSLabeledStatement()
  { if ("sourceElement".equals(tag) || 
        "statement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.getJSLabeledStatement(); 
    } 

    if ("labelledStatement".equals(tag) && 
        terms.size() == 3 && ":".equals(terms.get(1) + ""))
    { return (ASTTerm) terms.get(2); } 

    return null; 
  } 

  public String getJSLabel()
  { if ("sourceElement".equals(tag) || 
        "statement".equals(tag))
    { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(0); 
      return tt.getJSLabel(); 
    } 

    if ("labelledStatement".equals(tag) && 
        terms.size() == 3 && ":".equals(terms.get(1) + ""))
    { return ((ASTTerm) terms.get(0)).literalForm(); } 

    return null; 
  } 


  public String antlr2cstl()
  { /* System.out.println(">>> Tag: " + tag + " terms: " + 
                       terms.size()); */ 
   
    if (tag.equals("grammarSpec"))
    { for (int i = 0; i < terms.size(); i++)
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if ("rules".equals(trm.getTag()))
        { return trm.antlr2cstl(); } 
      } 
      return ""; 
    } 
 
    if (tag.equals("rules"))
    { String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(i); 
        res = res + tt.antlr2cstl() + "\n\n"; 
      } 
      return res; 
    } 

    if (tag.equals("ruleSpec") || 
        tag.equals("ruleBlock") ||
        tag.equals("lexerRuleBlock") || 
        tag.equals("labeledAlt") ||
        tag.equals("lexerAlt"))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.antlr2cstl(); 
    } 

    if (tag.equals("parserRuleSpec") || 
        tag.equals("lexerRuleSpec"))
    { String rname = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTSymbolTerm) 
        { String symb = tt + ""; 
          if (":".equals(symb)) 
          { if (i < terms.size() - 1) 
            { ASTTerm rblock = 
                (ASTTerm) terms.get(i+1); 
              String blockcode = rblock.antlr2cstl(); 
              return rname + "::\n" + blockcode; 
            }
            return rname + "::\n_* |-->";
          }   
          else 
          { rname = symb; } 
        }
      } 
    }

    if ("ruleAltList".equals(tag) || 
        "lexerAltList".equals(tag) || 
        "altList".equals(tag))
    { String res = ""; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        String symb = tt + ""; 
        if ("|".equals(symb))
        { res = res + "\n"; } 
        if (tt instanceof ASTCompositeTerm) 
        { ASTCompositeTerm ct = (ASTCompositeTerm) tt; 
          Vector normalisedct = 
                       ct.normaliseAntlr(); 

       /*   System.out.println(">>> " + this + " >> Normalised= " + normalisedct);  */ 

          for (int j = 0; j < normalisedct.size(); j++) 
          { Vector pathj = (Vector) normalisedct.get(j); 
            ASTCompositeTerm newct = new ASTCompositeTerm("alternative", pathj); 
            res = res + newct.antlr2cstl() + "\n";
          }  
        } 
      } 
      return res;
    } 

    if ("alternative".equals(tag) ||
        "lexerElements".equals(tag))
    { String res = ""; 

      Vector conditions = new Vector(); 
      Vector rulerefs = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        String tg = tt.getTag(); 
        if ("element".equals(tg) || "atom".equals(tg) ||
            "lexerElement".equals(tg) || 
            "lexerAtom".equals(tg))
        { String elem = 
             tt.antlrElement2cstl(rulerefs,conditions); 
          res = res + elem; 
        } 
      } 

      String cstring = ""; 
      if (conditions.size() > 0)
      { cstring = "<when> "; 
        for (int i = 0; i < conditions.size(); i++) 
        { String cond = (String) conditions.get(i); 
          cstring = cstring + cond; 
          if (i < conditions.size()-1) 
          { cstring = cstring + ", "; } 
        } 
      } 

      return res + " |--> " + cstring; 
    } 

    return "";  
  }

  public String antlrElement2cstl(Vector rulerefs, 
                                  Vector conditions) 
  { if ("atom".equals(tag) || 
        "lexerAtom".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.antlrElement2cstl(rulerefs,conditions); 
    }

    if ("terminal".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1 + " "; 
    } 

    if ("ruleref".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0);
      int i = rulerefs.size();
      String t1lit = t1.literalForm();   
      conditions.add("_" + (i+1) + " " + t1lit);
      rulerefs.add(t1lit);  
      return "_" + (i+1) + " "; 
    }

    if (("element".equals(tag) || 
         "lexerElement".equals(tag)) && terms.size() == 2)
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      ASTTerm suffix = (ASTTerm) terms.get(1);
      int i = rulerefs.size();
      String t1lit = trm.literalForm();   
      conditions.add("_" + (i+1) + " " + t1lit);
      rulerefs.add(t1lit);  
      return "_" + (i+1) + suffix.antlr2cstl() + " "; 
    } 

    if ("element".equals(tag) || 
        "lexerElement".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      return t1.antlrElement2cstl(rulerefs,conditions); 
    }
    
    return ""; 
  } 

  public Vector normaliseAntlr()
  { Vector alternatives = new Vector(); 
    Vector emptyAlt = new Vector(); 
    alternatives.add(emptyAlt); 

    // result for an alternative is all combinations of 
    // possibilities for each of its elements

    if (tag.equals("labeledAlt") || 
        tag.equals("lexerAlt"))
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(0); 
      return t1.normaliseAntlr(); 
    } 

    if (tag.equals("ebnf") && terms.size() == 1)
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(0); 
      return t1.normaliseAntlr(); 
    } 

    // ebnf can also have ebnfSuffix: ( r1 | r2 )*

    if (tag.equals("ebnf") && terms.size() == 2)
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(0); 
      Vector innerpaths = t1.normaliseAntlr();
      ASTTerm suffix = (ASTTerm) terms.get(1);
      String suf = suffix.literalForm(); 
      if ("?".equals(suf))
      { alternatives.addAll(innerpaths);  
        return alternatives;   
      }
      else if ("+".equals(suf))
      { Vector res = new Vector();
     
        for (int k = 0; k < innerpaths.size(); k++) 
        { Vector path = (Vector) innerpaths.get(k); 
          res.add(path);        /* one occurrence */
        }  
        ASTBasicTerm ts1 = 
                 new ASTBasicTerm("terminal", "'_*'"); 
        ASTCompositeTerm terminalStar = 
                new ASTCompositeTerm("atom", ts1); 
        Vector iterations = new Vector(); 
        iterations.add(terminalStar);
        res.add(iterations); 
        
        return res;   
      } 
      else if ("*".equals(suf))
      { Vector res = new Vector(); 
        res.add(new Vector()); 
        for (int k = 0; k < innerpaths.size(); k++) 
        { Vector path = (Vector) innerpaths.get(k);
          res.add(path); 
        }  
        ASTBasicTerm ts1 = 
                 new ASTBasicTerm("terminal", "'_*'"); 
        ASTCompositeTerm terminalStar = 
                new ASTCompositeTerm("atom", ts1); 
        Vector iterations = new Vector(); 
        iterations.add(terminalStar);
        res.add(iterations); 
        return res;   
      } 
    } 

    if (tag.equals("block") && "(".equals(terms.get(0) + ""))
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(1); 
      return t1.normaliseAntlr(); 
    } 

    if (tag.equals("lexerRuleBlock"))
    { ASTCompositeTerm t1 = (ASTCompositeTerm) terms.get(1); 
      return t1.normaliseAntlr(); 
    } 

    if ("alternative".equals(tag) || 
        "lexerElements".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        String tg = tt.getTag(); 
        if ("element".equals(tg) || 
            "lexerElement".equals(tg))
        { Vector elemchoices = tt.normaliseAntlr(); 
          Vector newalts = new Vector(); 
          for (int j = 0; j < alternatives.size(); j++) 
          { Vector altern = (Vector) alternatives.get(j); 
            for (int k = 0; k < elemchoices.size(); k++) 
            { Vector choice = (Vector) elemchoices.get(k); 
              Vector newbranch = new Vector(); 
              newbranch.addAll(altern); 
              newbranch.addAll(choice); 
              newalts.add(newbranch); 
            } 
          }
          alternatives = newalts;  
        } 
      } 
      return alternatives; 
    } 

    if ("ruleAltList".equals(tag) || "altList".equals(tag) ||
        "lexerAltList".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if (tt instanceof ASTCompositeTerm) 
        { ASTCompositeTerm ct = (ASTCompositeTerm) tt; 
          Vector normalisedct = 
                       ct.normaliseAntlr(); 
          res.addAll(normalisedct); 
        }
      } 
      return res;  
    } 

    if ("atom".equals(tag) || 
        "lexerAtom".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      emptyAlt.add(t1); 
      return alternatives;  
    } // Sequence{ Sequence{t1} }

    if ("terminal".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      emptyAlt.add(t1); 
      return alternatives;
    } 

    if ("ruleref".equals(tag))
    { emptyAlt.add(this); 
      return alternatives;
    }

    if (("element".equals(tag) || 
         "lexerElement".equals(tag)) && terms.size() == 2)
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      ASTTerm suffix = (ASTTerm) terms.get(1);
      String suf = suffix.literalForm(); 
      if ("?".equals(suf))
      { emptyAlt.add(trm); 
        Vector newEmpty = new Vector(); 
        alternatives.add(newEmpty);
      } 
      else if ("+".equals(suf))
      { emptyAlt.add(trm);
        ASTBasicTerm ts1 = new ASTBasicTerm("terminal", "'_*'"); 
        ASTCompositeTerm terminalStar = 
          new ASTCompositeTerm("atom", ts1); 
        Vector newEmpty = new Vector(); 
        newEmpty.add(terminalStar);
        alternatives.add(newEmpty); 
      } 
      else if ("*".equals(suf))
      { Vector newalts = new Vector(); 
        Vector newEmpty = new Vector(); 
        newalts.add(newEmpty);
        newalts.addAll(alternatives); 
        emptyAlt.add(trm);
        ASTBasicTerm ts1 = new ASTBasicTerm("terminal", "'_*'"); 
        ASTCompositeTerm terminalStar = 
          new ASTCompositeTerm("atom", ts1);
        Vector iterations = new Vector();  
        iterations.add(terminalStar);
        newalts.add(iterations); 
        alternatives = newalts; 
      } 
 
      return alternatives;
    } 

    if ("element".equals(tag) || 
        "lexerElement".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0); 
      if ("ebnf".equals(t1.getTag()))
      { return t1.normaliseAntlr(); } 
      emptyAlt.add(t1); 
      return alternatives; 
    }
    
    return alternatives; 
  } 
          
  public int cobolDataWidth()
  { if ("dataPictureClause".equals(tag))
    { // (PIC | PICTURE) IS? pictureString

      int sze = terms.size(); 
      ASTTerm ptrm = (ASTTerm) terms.get(sze-1); 
      return ptrm.cobolDataWidth(); 
    } 

    if ("pictureString".equals(tag))
    { int res = 0; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        int wdth = tt.cobolDataWidth(); 
        res = res + wdth; 
      } 
      return res; 
    } 

    if ("pictureCardinality".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(1); 
      String lit = val.literalForm(); 
      try { 
        int crd = Integer.parseInt(lit); 
        return crd-1; 
      } catch (Exception _ex) { return 0; } 
    } 

    if ("pictureChars".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(0); 
      return val.cobolDataWidth(); 
    }   

    return 0; 
  } 

  public int cobolIntegerWidth()
  { if ("dataPictureClause".equals(tag))
    { // (PIC | PICTURE) IS? pictureString

      int sze = terms.size(); 
      ASTTerm ptrm = (ASTTerm) terms.get(sze-1); 
      return ptrm.cobolIntegerWidth(); 
    } 

    if ("pictureString".equals(tag))
    { int res = 0; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i);
        String lit = tt.literalForm();  
        if (".".equals(lit) || "V".equals(lit))
        { return res; } 
        if ("X".equals(lit))
        { return 0; } 
        int wdth = tt.cobolIntegerWidth(); 
        res = res + wdth; 
      } 
      return res; 
    } 

    if ("pictureCardinality".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(1); 
      String lit = val.literalForm(); 
      try { 
        int crd = Integer.parseInt(lit); 
        return crd-1; 
      } catch (Exception _ex) { return 0; } 
    } 

    if ("pictureChars".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(0); 
      return val.cobolIntegerWidth(); 
    }   

    return 0; 
  } 

  public int cobolFractionWidth()
  { if ("dataPictureClause".equals(tag))
    { // (PIC | PICTURE) IS? pictureString

      int sze = terms.size(); 
      ASTTerm ptrm = (ASTTerm) terms.get(sze-1); 
      return ptrm.cobolFractionWidth(); 
    } 

    if ("pictureString".equals(tag))
    { int res = 0; 
      boolean isRealNumber = false; 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i);
        String lit = tt.literalForm();
  
        if ("X".equals(lit))
        { return 0; } 
        
        if (".".equals(lit) || "V".equals(lit))
        { isRealNumber = true; }
        else if (isRealNumber)
        { int wdth = tt.cobolFractionWidth(); 
          res = res + wdth; 
        } 
      } 

      return res; 
    } 

    if ("pictureCardinality".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(1); 
      String lit = val.literalForm(); 
      try { 
        int crd = Integer.parseInt(lit); 
        return crd-1; 
      } catch (Exception _ex) { return 0; } 
    } 

    if ("pictureChars".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(0); 
      return val.cobolFractionWidth(); 
    }   

    return 0; 
  } 

  public Type cobolDataType()
  { if ("dataPictureClause".equals(tag))
    { // (PIC | PICTURE) IS? pictureString

      int sze = terms.size(); 
      ASTTerm ptrm = (ASTTerm) terms.get(sze-1); 
      return ptrm.cobolDataType(); 
    } 

    if ("pictureString".equals(tag))
    { Type res = null; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Type typ = tt.cobolDataType();
        if (res == null) 
        { res = typ; }
        else if (typ == null) { } // no information 
        else if (typ == doubleType)
        { return typ; } 
        else if (res == intType && typ == intType)
        { res = intType; } 
        else if (res == longType && typ == longType)
        { res = longType; } 
        else if (res == longType && typ == intType)
        { res = longType; } 
        else if (res == intType && typ == longType)
        { res = longType; } 
        else // typ or res are String
        { res = stringType; }  
      } 

      if (res == intType) 
      { int wdth = this.cobolIntegerWidth(); 
        if (wdth > 9)
        { res = longType; } 
      } 

      return res; 
    } 

    if ("pictureCardinality".equals(tag))
    { return null; } 

    if ("pictureChars".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(0); 
      return val.cobolDataType(); 
    }   

    return stringType; 
  } 

  public boolean cobolIsSigned()
  { if ("dataPictureClause".equals(tag))
    { // (PIC | PICTURE) IS? pictureString

      int sze = terms.size(); 
      ASTTerm ptrm = (ASTTerm) terms.get(sze-1); 
      System.out.println(">> " + ptrm + " is signed: " + ptrm.cobolIsSigned()); 
      return ptrm.cobolIsSigned(); 
    } 

    if ("pictureString".equals(tag))
    { boolean res = false; 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        boolean bb = tt.cobolIsSigned();
        if (bb == true) 
        { return true; }
      } 

      return res; 
    } 

    if ("pictureChars".equals(tag))
    { ASTTerm val = (ASTTerm) terms.get(0); 
      return "S".equals(val.literalForm()); 
    }   

    return false; 
  } 

  public int cobolOccursTimes()
  { if ("dataOccursClause".equals(tag))
    { // OCCURS integerLiteral dataOccursTo? TIMES? 
      // (DEPENDING ON? qualifiedDataName)? 
      // dataOccursSort* (INDEXED BY? LOCAL? indexName+)?
      ASTTerm times = (ASTTerm) terms.get(1); 
      String lit = times.literalForm(); 
      try 
      { int x = Integer.parseInt(lit); 
        return x; 
      } catch (Exception _ex) { } 
    } 
    return 1; 
  } // But actually the TO is a maximum. 

     
  public Vector cobolDataDefinitions(java.util.Map context, Vector invs)
  { // Each non-filler item at level > 01 becomes an attribute
    // of a relevant container. If composite (no picture), 
    // it also becomes a class & container in turn.

    Vector res = new Vector();

    if ("compilationUnit".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolDataDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("programUnit".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolDataDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("identificationDivision".equals(tag))
    { // (IDENTIFICATION | ID) DIVISION . programIdParagraph identificationDivisionBody*

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if ("programIdParagraph".equals(trm.getTag()))
        { trm.cobolDataDefinitions(context,invs); } 
      } 

      return res; 
    } 

    if ("programIdParagraph".equals(tag))
    { // PROGRAM-ID . programName _* 
      ASTTerm nme = (ASTTerm) terms.get(2);
      String pxname = nme.literalForm();  
      String pname = pxname + "_Class"; 
      context.put("programName", pname);

      ASTTerm.cobolClasses.add(pxname); 
      ASTTerm.setTaggedValue(pxname, "programNumber", 
                     "" + ASTTerm.cobolClasses.size());  
      
      return res; 
    } 

    if ("dataDivision".equals(tag))
    { // DATA DIVISION . dataDivisionSection*

      for (int i = 3; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolDataDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("dataDivisionSection".equals(tag))
    { // fileSection | dataBaseSection | 
      // workingStorageSection | linkageSection | ...

      ASTTerm tt = (ASTTerm) terms.get(0); 
      Vector ttres = tt.cobolDataDefinitions(context, invs); 
      return ttres; 
    } 

    if ("workingStorageSection".equals(tag))
    { // WORKING-STORAGE SECTION . dataDescriptionEntry*

      context.put("container", null); 
      context.put("previousLevel", new Integer(-1));
      context.put("startPosition", new Integer(1));  
	  
      Vector wsRecordEntries = new Vector(); 
      
      for (int i = 3; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if ("dataDescriptionEntry".equals(tt.getTag()))
        { wsRecordEntries.add(tt); }
      } 

      Vector containers = new Vector();
	  
      Entity prog = null; 
      String pname = 
          (String) context.get("programName");
      if (pname != null)  
      { prog = new Entity(pname);
        prog.levelNumber = 0;  
      } 
     
      Vector remainder = new Vector(); 
      res = ASTCompositeTerm.cobolProcessDataEntries(context, 
              wsRecordEntries, prog, 0, 
              1, containers, invs, remainder); 
      // Should be no remainder.

      Vector entries = new Vector(); 
      entries.addAll(remainder); 
      while (entries.size() > 0)
      { Vector remainingEntries = new Vector(); 
        Vector localInvs = new Vector(); 
        Vector newRemainder = new Vector(); 

        Vector newRes = 
              cobolProcessDataEntries(context, 
                 entries, prog, 0, 
                 1, containers, localInvs, newRemainder);

        res.addAll(newRes);   
        invs.addAll(localInvs); 

        entries.clear();
        entries.addAll(newRemainder);
      } 
 
      /* for (int i = 3; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolDataDefinitions(context, invs); 
        res.addAll(ttres); 
      } */ 

      return res; 
    } 

    if ("fileSection".equals(tag))
    { // FILE SECTION . fileDescriptionEntry*

      for (int i = 3; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolDataDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 
    
    if ("fileDescriptionEntry".equals(tag))
    { // (FD | SD) fileName (.? fileDescriptionEntryClause)* . dataDescriptionEntry*

      context.put("container", null); 
      context.put("previousLevel", new Integer(-1));
      context.put("startPosition", new Integer(1));  

      ASTTerm fname = (ASTTerm) terms.get(1); 
      String fnme = fname.literalForm(); 

      Attribute frec = 
        new Attribute(fnme + "_Record", 
                      new Type("String", null), 
                      ModelElement.INTERNAL); 
      BasicExpression frecbe = 
           new BasicExpression(frec); 
	  
      Vector fileRecordEntries = new Vector(); 
      
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        if ("dataDescriptionEntry".equals(tt.getTag()))
        { fileRecordEntries.add(tt); 
          // Vector ttres = tt.cobolDataDefinitions(context, invs);    
          // res.addAll(ttres); 
        }
      } 
	  
      Entity prog = null; 
      String pname = 
          (String) context.get("programName");
      if (pname != null)  
      { prog = new Entity(pname);
        prog.levelNumber = 0;  
      } 
     
      Vector containers = new Vector();
      containers.add(frecbe);  

      Vector remainder = new Vector(); 
      Vector decs = 
        ASTCompositeTerm.cobolProcessDataEntries(context, 
              fileRecordEntries, prog, 0, 
              1, containers, invs, remainder); 
      // Should be no remainder.

      res.addAll(decs); 
      return res;
    } 

    if ("dataDescriptionEntry".equals(tag))
    { // dataDescriptionEntryFormat1 |
      // dataDescriptionEntryFormat2 | 
      // dataDescriptionEntryFormat3 | 
      // dataDescriptionEntryExecSql

      ASTTerm tt = (ASTTerm) terms.get(0); 
      Vector ttres = tt.cobolDataDefinitions(context, invs); 
      return ttres; 
    } 
      
    if ("dataDescriptionEntryFormat1".equals(tag))
    { // Level (FILLER | dataName)? dataClause* .

      // If preceding item at lower or same levelnumber,
      // container != null and this is attribute of 
      // container or padding (FILLER).
      // If preceding item at higher levelnumber, or no 
      // preceding item (container = null), this is 
      // a new container class. 
 
      ASTTerm tt = (ASTTerm) terms.get(0); 
      String level = tt.literalForm(); 
      int levelNumber = 0; 
      String fieldName = ""; 

      if ("77".equals(level) || "66".equals(level)) 
      { context.put("container", null); 
        if (ASTTerm.hasTag(terms,"dataPictureClause"))
        { // It is a basic data item, not an entity

          ASTTerm pictureClause = 
            ASTTerm.getTermByTag(terms,"dataPictureClause"); 
          int intwidth = pictureClause.cobolIntegerWidth();
          int fractwidth = pictureClause.cobolFractionWidth();
          Type typ = pictureClause.cobolDataType();
          int wdth = pictureClause.cobolDataWidth();  
          boolean isSigned = pictureClause.cobolIsSigned();  
          
          ASTTerm t2 = (ASTTerm) terms.get(1); 
          if (t2.getTag().equals("dataName"))
          { String fname = t2.literalForm(); 
            ASTTerm.setTaggedValue(fname, "integerWidth", 
                                     "" + intwidth); 
            ASTTerm.setTaggedValue(fname, "fractionWidth", 
                                     "" + fractwidth); 
            ASTTerm.setTaggedValue(fname, "oclType", 
                                     "" + typ);  
            ASTTerm.setTaggedValue(fname, "width", 
                                     "" + wdth);       
            // JOptionPane.showMessageDialog(null, 
            //   "Type of " + fname + " is " + typ + 
            //   " " + intwidth + " " + 
            //   fractwidth, 
            //   "", 
            //   JOptionPane.INFORMATION_MESSAGE);
            if (typ != null) 
            { String dval = typ.defaultValue(); 
              ASTTerm.setTaggedValue(fname, "defaultValue", 
                                     dval);  
            } 
          }
          else 
          { // ASTTerm.setTaggedValue(fname, "integerWidth", "0"); 
            // ASTTerm.setTaggedValue(fname, "fractionWidth", "0"); 
            // ASTTerm.setTaggedValue(fname, "oclType", "String"); 
          } 
        } 

        return res; 
      } 

      try 
      { levelNumber = Integer.parseInt(level); } 
      catch (Exception ex) { return res; } 

      if (terms.size() == 1) 
      { return res; } 

      ASTTerm t2 = (ASTTerm) terms.get(1); 
      if ("FILLER".equals(t2 + "") || 
          t2.getTag().equals("dataName"))
      { fieldName = t2.literalForm(); }
      else 
      { fieldName = "FILLER"; } 

      Entity container = (Entity) context.get("container"); 

      int multiplicity = 1;
      if (ASTTerm.hasTag(terms,"dataOccursClause")) 
      { ASTTerm occursClause = 
          ASTTerm.getTermByTag(terms,"dataOccursClause"); 
        if (occursClause != null) 
        { multiplicity = 
            ((ASTCompositeTerm) occursClause).cobolOccursTimes(); 
        } 
      } 
    
      if (ASTTerm.hasTag(terms,"dataPictureClause"))
      { // It is a basic data item, not an entity

        ASTTerm pictureClause = 
          ASTTerm.getTermByTag(terms,"dataPictureClause"); 
        int wdth = 0;
        int integerWidth = 0; 
        int fractionalWidth = 0; 

        Type typ = stringType; 
 
        if (pictureClause != null) 
        { wdth = pictureClause.cobolDataWidth() * multiplicity; 
          typ = pictureClause.cobolDataType();  
          if (multiplicity > 1) 
          { Type elemT = typ; 
            typ = new Type("Sequence", null);
            typ.setElementType(elemT); 
          }  

          boolean isSigned = pictureClause.cobolIsSigned();  
          integerWidth = pictureClause.cobolIntegerWidth(); 
          fractionalWidth = 
              pictureClause.cobolFractionWidth(); 

          /* JOptionPane.showMessageDialog(null, 
             "Type of " + fieldName + " is " + typ + 
             " Signed: " + isSigned + 
             " Width: " + wdth + " " + integerWidth + " " + 
             fractionalWidth, 
             "", 
             JOptionPane.INFORMATION_MESSAGE);  */ 

          ASTTerm.setTaggedValue(fieldName, "integerWidth", 
                                     "" + integerWidth); 
          ASTTerm.setTaggedValue(fieldName, "fractionWidth", 
                                     "" + fractionalWidth);       
          ASTTerm.setTaggedValue(fieldName, "oclType", 
                                     "" + typ);    
          ASTTerm.setTaggedValue(fieldName, "width", 
                                     "" + wdth);       
          if (typ != null) 
          { if ("String".equals(typ.getName()))
            { typ.setFixedSize(true, 
                               new BasicExpression(wdth)); 
            }
            String dval = typ.defaultValue(); 
            ASTTerm.setTaggedValue(fieldName, "defaultValue", 
                                   dval);  
          }   
        } 

        if (container == null) // no container, so top-level attribute
        { if ("FILLER".equals(fieldName)) 
          { /* Should not occur */ } 
          else 
          { Attribute att = 
              new Attribute(fieldName, typ, 
                            ModelElement.INTERNAL); 
            res.add(att);  
          
            context.put("previousLevel", new Integer(levelNumber)); 
          } 
        }
        else // basic attribute of some container 
        { int contLevel = container.levelNumber; 
          int contMult = container.cardinalityValue; 

          Integer startPosition = 
              (Integer) context.get("startPosition"); 

          int startPos = 1; 
          int endPos = wdth; 
            
          if (startPosition != null) 
          { startPos = startPosition.intValue(); 
            endPos = startPos + wdth - 1; 
            context.put("startPosition", endPos + 1);

            if ("FILLER".equals(fieldName)) 
            { fieldName = "FILLER$" + startPos + "$" + endPos; }
 
            String cname = container.getName(); 
            String ownername = 
               cname.substring(0,cname.length()-6); 
            String progname = 
               (String) context.get("programName"); 

            if (multiplicity == 1 && contMult == 1)
            { // fieldName = owner.subrange(startPos,endPos)

              /* JOptionPane.showMessageDialog(null, 
                 progname + ":: " + fieldName + 
                 " = " + ownername + 
                 ".subrange(" + startPos + "," + endPos + ")", 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE); */ 
              BasicExpression owner = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
              BasicExpression attr = 
                BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typ);
              Vector spars = new Vector(); 
              spars.add(new BasicExpression(startPos)); 
              spars.add(new BasicExpression(endPos));  
              BasicExpression substr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", owner, spars); 
              Expression convertedExpr = 
                Type.typeConversionFromString(
                                          substr,typ); 
              BinaryExpression inv = 
                new BinaryExpression("=", attr, 
                                     convertedExpr);
              Constraint cons = 
                Constraint.getConstraint(inv); 
              cons.ownerName = progname;  
              invs.add(cons);
            } 
            else if (multiplicity > 1 && contMult == 1)
            { // fieldName = owner.subrange(startPos,endPos)

              int fwdth = wdth/multiplicity; 
              /* JOptionPane.showMessageDialog(null, 
                 progname + ":: " + fieldName + 
                 "[i] = " + ownername + 
                 ".subrange(" + startPos + " + (i-1)*" + fwdth + ",  i*" + fwdth + ")", 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE); */ 
              BasicExpression owner = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
              BasicExpression attr = 
                BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typ);
              Vector spars = new Vector(); 
              spars.add(new BasicExpression(startPos)); 
              spars.add(new BasicExpression(endPos));  
              BasicExpression substr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", owner, spars); 
              BinaryExpression inv = 
                new BinaryExpression("=", 
                   new UnaryExpression("->sum", attr), 
                                       substr);
              Constraint cons = 
                Constraint.getConstraint(inv); 
              cons.ownerName = progname;  
              invs.add(cons);
            } 
            else if (multiplicity == 1 & contMult > 1)
            { // fieldName[i] = owner[i].subrange(...)

              /* JOptionPane.showMessageDialog(null, progname + ":: " + fieldName + 
                 "[i] = " + ownername + 
                 "[i].subrange(" + startPos + "," + endPos + ")", 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE); */ 

              BasicExpression indx = 
                BasicExpression.newVariableBasicExpression(
                                   "indx", 
                                   intType); 
                            
              Type seqType = new Type("Sequence", null); 
              seqType.setElementType(stringType); 
              Type typSeq = new Type("Sequence", null); 
              typSeq.setElementType(typ); 
              BasicExpression owner = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, 
                                   seqType); 
              owner.setArrayIndex(indx); 
              BasicExpression attr = 
                BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typSeq);
              Vector spars = new Vector(); 
              attr.setArrayIndex(indx); 
              spars.add(new BasicExpression(startPos)); 
              spars.add(new BasicExpression(endPos));  
              BasicExpression substr = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", owner, spars); 
              Expression convertedExpr = 
                Type.typeConversionFromString(
                                          substr,typ); 
              BinaryExpression inv = 
                new BinaryExpression("=", attr, 
                                     convertedExpr);
              Vector ipars = new Vector(); 
              ipars.add(new BasicExpression(1)); 
              ipars.add(
                new BasicExpression(contMult)); 

              BasicExpression dmn = 
                 BasicExpression.newFunctionBasicExpression(
                     "subrange", "Integer", ipars);
              BinaryExpression indmn = 
                  new BinaryExpression(":", indx, dmn);       
      
              inv = 
                new BinaryExpression("!", indmn, inv);

              Constraint cons = 
                Constraint.getConstraint(inv); 
              cons.ownerName = progname;  
              invs.add(cons);
            } 
          } 
          else 
          { context.put("startPosition", 1 + wdth); } 

          Integer previousLevel = 
                (Integer) context.get("previousLevel");
          int prevLevel = previousLevel.intValue(); 
 
          if (levelNumber >= prevLevel) 
          { // attribute of container 
            if ("FILLER".equals(fieldName)) 
            { fieldName = "FILLER$" + startPos + "$" + endPos; }
            else 
            { ASTTerm.setTaggedValue(fieldName, "startPosition", 
                                     "" + startPos); 
              ASTTerm.setTaggedValue(fieldName, "endPosition", 
                                     "" + endPos); 
              ASTTerm.setTaggedValue(fieldName, "integerWidth", 
                                     "" + integerWidth); 
              ASTTerm.setTaggedValue(fieldName, "fractionWidth", 
                                     "" + fractionalWidth); 
              ASTTerm.setTaggedValue(fieldName, "width", 
                                     "" + wdth);       
            } // For the CSTL.
            
            Attribute att = 
                new Attribute(fieldName, typ, 
                          ModelElement.INTERNAL); 
            if (typ != null && "String".equals(typ.getName()))
            { typ.setFixedSize(true, 
                               new BasicExpression(wdth)); 
            }
            att.setWidth(wdth); 
            att.setMultiplicity(multiplicity); 

            container.addAttribute(att); 
            // could itself be composite

            context.put("previousLevel", 
                        new Integer(levelNumber)); 
          }
          else if (levelNumber < prevLevel) 
          { // attribute of another container 
            if ("FILLER".equals(fieldName)) 
            { fieldName = "FILLER_F" + startPos + "_T" + endPos; }
            else 
            { Attribute att = 
                new Attribute(fieldName, typ, 
                          ModelElement.INTERNAL);
              att.setWidth(wdth); 
              att.setMultiplicity(multiplicity); 

              Entity actualContainer = 
                 container.findContainer(levelNumber);  
              if (actualContainer != null) 
              { actualContainer.addAttribute(att);
                context.put("container", actualContainer); 
              }  

              ASTTerm.setTaggedValue(fieldName, "startPosition", 
                                     "" + startPos); 
              ASTTerm.setTaggedValue(fieldName, "endPosition", 
                                     "" + endPos); 
              ASTTerm.setTaggedValue(fieldName, "integerWidth", 
                                     "" + integerWidth); 
              ASTTerm.setTaggedValue(fieldName, "fractionWidth", 
                                     "" + fractionalWidth); 
              ASTTerm.setTaggedValue(fieldName, "width", 
                                     "" + wdth); 
            } // could itself be composite
            context.put("previousLevel", 
                        new Integer(levelNumber)); 
          }
        }
      } 
      else // No PICTURE => new entity
      { Integer startPosition = 
              (Integer) context.get("startPosition"); 
        int startPos = startPosition.intValue(); 

        if ("FILLER".equals(fieldName)) {} 
        else 
        { Entity newent = new Entity(fieldName + "_Class");
          newent.levelNumber = levelNumber; 
          newent.cardinalityValue = multiplicity; 

          ASTTerm.setTaggedValue(fieldName, "oclType", 
                                            "String");    
          ASTTerm.setTaggedValue(fieldName, "defaultValue", 
                                 "\"\"");
  
          Type typ = new Type(newent); 
          if (multiplicity > 1) 
          { Type elemT = typ; 
            typ = new Type("Sequence", null);
            typ.setElementType(elemT); 
          }  

          Attribute att = 
            new Attribute(fieldName, typ, 
                         ModelElement.INTERNAL); 

          Integer previousLevel = 
            (Integer) context.get("previousLevel");

          int prevLevel = -1; 
          if (previousLevel != null) 
          { prevLevel = previousLevel.intValue(); }     

          String ownername = ""; 
      
          res.add(newent);
          if (container == null) // top-level
          { String pname = 
              (String) context.get("programName");
            if (pname != null)  
            { Entity prog = new Entity(pname);
              prog.levelNumber = -1;  
              newent.container = prog;
              ownername = pname; 
            }  
            res.add(att); 
          } 
          else if (levelNumber >= prevLevel)  
          { newent.container = container; 
            container.addAttribute(att); 
            String cname = container.getName(); 
            ownername = 
               cname.substring(0,cname.length()-6); 
          } 
          else 
          { Entity actualContainer = 
              container.findContainer(levelNumber);  
            if (actualContainer != null) 
            { newent.container = actualContainer; 
              actualContainer.addAttribute(att); 
              String cname = actualContainer.getName(); 
              ownername = 
                 cname.substring(0,cname.length()-6);
            }  
          } 

        /*  JOptionPane.showMessageDialog(null, 
                 fieldName + 
                 " is subrecord of " + ownername + 
                 " from " + startPos, 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE);
        */
 
          context.put("container", newent); 
          context.put("previousLevel", new Integer(levelNumber));
          context.put("startPosition", new Integer(1));  
        } 
      }  
    } 
  
    return res; 
  } 

  public static boolean is88Entry(ASTTerm trm)
  { String ttag = trm.getTag(); 
    if ("dataDescriptionEntryFormat3".equals(ttag))
    { return true; }
    if ("dataDescriptionEntry".equals(ttag))
    { ASTTerm subterm = 
          (ASTTerm) ((ASTCompositeTerm) trm).terms.get(0); 
      return is88Entry(subterm);
    }
    return false; 
  }

  public static Vector 
         cobolProcessDataEntries(java.util.Map context, 
              Vector entries, Entity cent, int centLevel, 
              int startPos, Vector containers, 
              Vector invs, Vector remainder)
  { // Extract the items that are subfields of cent,
    // directly or recursively. Stop if field with level <=
    // centLevel is found, and return it & following terms in
    // remainder.
    // Add invariants  part = cont.subrange(a,b) for each
    // cont in containers

    String cname = cent.getName(); 
    String ownername = 
         cname.substring(0,cname.length()-6); 
    String progname = 
         (String) context.get("programName"); 
    String pname = 
         progname.substring(0,progname.length()-6); 

    // cname = pname for top-level records 

    Vector res = new Vector(); 
    int totalWidth = 0; // sum of widths of all subfields 

    while (entries.size() > 0) 
    { ASTTerm trm = (ASTTerm) entries.get(0);
	 
      if ("dataDescriptionEntry".equals(trm.getTag()))
      { ASTTerm subterm = 
          (ASTTerm) ((ASTCompositeTerm) trm).terms.get(0); 
        trm = subterm; 
      } 

      /* JOptionPane.showMessageDialog(null, 
                 trm + 
                 " " + cent + 
                 " " + centLevel, 
                 "", 
                 JOptionPane.INFORMATION_MESSAGE); */ 

      if ("dataDescriptionEntryFormat3".equals(trm.getTag()))
      { // 88 conditionName dataValueClause .
        
        ASTCompositeTerm ctrm = (ASTCompositeTerm) trm; 
        String condName = ""; 
        ASTTerm t2 = (ASTTerm) ctrm.terms.get(1); 
        if (t2.getTag().equals("conditionName"))
        { condName = t2.literalForm(); 
          ASTTerm.setTaggedValue(condName, "oclType", 
                                 "boolean");
          ASTTerm.setTaggedValue(condName, "defaultValue", 
                                 "false");  
            
          ASTTerm t3 = (ASTTerm) ctrm.terms.get(2); 
          if (t3.getTag().equals("dataValueClause"))
          { String varName = cent.getName(); 
            varName = varName.substring(0,varName.length()-6);
            Attribute varAttr = 
               new Attribute(varName, 
                             new Type("String", null), 
                             ModelElement.INTERNAL); 

            BasicExpression vattr = 
               new BasicExpression(varAttr); 

            // VALUE IS v 
            // means (varName = v => condName = true) & 
            //   (varName /= v => condName = false)
        
            Expression dataValueConstraint = 
              ((ASTCompositeTerm) t3).cobolDataValue(vattr); 
             
            /* JOptionPane.showMessageDialog(null, 
                "Type of " + condName + " is boolean" +  
                " (" + dataValueConstraint + " => " + 
                    condName + " = true)", 
                "", 
                JOptionPane.INFORMATION_MESSAGE); */ 

            Attribute condAttr = 
               new Attribute(condName, 
                             new Type("boolean", null), 
                             ModelElement.INTERNAL); 
            // cent.addAttribute(condAttr); // ?? 

            BasicExpression cattr = 
               new BasicExpression(condAttr); 
            BinaryExpression inv1succ = 
                new BinaryExpression("=", cattr, 
                                     new BasicExpression(true));

            BinaryExpression inv1 = 
              new BinaryExpression("=>", dataValueConstraint, 
                                   inv1succ); 
      
            Constraint cons1 = 
                Constraint.getConstraint(inv1); 
            cons1.ownerName = progname;  
            invs.add(cons1); 

            BinaryExpression inv2succ = 
              new BinaryExpression("=", cattr, 
                    new BasicExpression(false));
            
            for (int k = 0; k < containers.size(); k++) 
            { Expression conbe = 
                (Expression) containers.get(k); 
              if (varName.equals(conbe + "")) { } 
              else 
              { Expression invxante = 
                  ((ASTCompositeTerm) t3).cobolDataValue(conbe); 
                BinaryExpression invx = 
                  new BinaryExpression("=>", invxante,                 
                                       inv1succ); 
      
                Constraint consx = 
                  Constraint.getConstraint(invx); 
                consx.ownerName = progname;  
                invs.add(consx); 
            
                Expression invyante =
                  Expression.negate(invxante);  
                BinaryExpression invy = 
                  new BinaryExpression("=>", invyante, inv2succ); 
      
                Constraint consy = 
                    Constraint.getConstraint(invy); 
                consy.ownerName = progname;  
                invs.add(consy);  
              }
            }
 
            Expression inv2ante =
              Expression.negate(dataValueConstraint);  
            BinaryExpression inv2 = 
                new BinaryExpression("=>", inv2ante, inv2succ); 
      
            Constraint cons2 = 
                Constraint.getConstraint(inv2); 
            cons2.ownerName = progname;  
            invs.add(cons2);  
          }
        }  
      }

      if ("dataDescriptionEntryFormat1".equals(trm.getTag()))
      { // Level (FILLER | dataName)? dataClause* .

        ASTCompositeTerm ctrm = (ASTCompositeTerm) trm; 

        // If this level is at > centLevel,
        // container is cent or subentity and 
        // trm is attribute of 
        // container or padding (FILLER).
        // If it is itself composite, repeat process with
        // a new container class for it. 
 
        ASTTerm tt = (ASTTerm) ctrm.terms.get(0); 
        String level = tt.literalForm(); 
        int levelNumber = 0; 
        String fieldName = ""; 

        if ("77".equals(level) || "66".equals(level)) 
        { context.put("container", null); 
          if (ASTTerm.hasTag(ctrm.terms,"dataPictureClause"))
          { // It is a basic data item, not an entity

            ASTTerm pictureClause = ASTTerm.getTermByTag(
                            ctrm.terms,"dataPictureClause"); 
            int wdth = pictureClause.cobolDataWidth(); 
            int intwidth = pictureClause.cobolIntegerWidth();
            int fractwidth = 
                       pictureClause.cobolFractionWidth();
            Type typ = pictureClause.cobolDataType();  
            boolean isSigned = pictureClause.cobolIsSigned();  
          
            ASTTerm t2 = (ASTTerm) ctrm.terms.get(1); 
            if (t2.getTag().equals("dataName"))
            { String fname = t2.literalForm(); 
              ASTTerm.setTaggedValue(fname, "integerWidth", 
                                     "" + intwidth); 
              ASTTerm.setTaggedValue(fname, "fractionWidth", 
                                     "" + fractwidth); 
              ASTTerm.setTaggedValue(fname, "oclType", 
                                     "" + typ);  
              ASTTerm.setTaggedValue(fname, "width", 
                                     "" + wdth);       

              /* JOptionPane.showMessageDialog(null, 
                "Type of " + fname + " is " + typ + 
                " Signed: " + isSigned + 
                " Width: " + wdth + 
                " Integer width: " + intwidth + 
                " Fract width: " + fractwidth, 
                "", 
                JOptionPane.INFORMATION_MESSAGE); */ 

              if (typ != null) 
              { if ("String".equals(typ.getName()))
                { typ.setFixedSize(true, 
                               new BasicExpression(wdth)); 
                }

                String dval = typ.defaultValue(); 
                ASTTerm.setTaggedValue(fname, "defaultValue", 
                                       dval); 
                Constraint consV = 
                   Constraint.getDataConstraint(fname,
                                 typ,intwidth,fractwidth,
                                 isSigned); 
                if (consV != null)
                { consV.ownerName = progname;  
                  invs.add(consV);  
                } 
              } 
            }
            else 
            { // ASTTerm.setTaggedValue(fname, "integerWidth", "0"); 
              // ASTTerm.setTaggedValue(fname, "fractionWidth", "0");  
              // ASTTerm.setTaggedValue(fname, "oclType", "String");  
            } 
          } 

          for (int j = 1; j < entries.size(); j++) 
          { remainder.add(entries.get(j)); } 

          return res; 
        } 

        try 
        { levelNumber = Integer.parseInt(level); } 
        catch (Exception ex) 
        { for (int j = 1; j < entries.size(); j++) 
          { remainder.add(entries.get(j)); } 
          return res; 
        } 

        if (levelNumber <= centLevel) // it is not a part of cent
        { remainder.addAll(entries); 
          cent.totalWidth = totalWidth; 
          return res; 
        } 

        if (ctrm.terms.size() == 1) // malformed item.
        { for (int j = 1; j < entries.size(); j++) 
          { remainder.add(entries.get(j)); }
          return res; 
        } 

        ASTTerm t2 = (ASTTerm) ctrm.terms.get(1);
        String t2lit = t2.literalForm();  
        if (t2lit.startsWith("FILLER_F") || 
            t2.getTag().equals("dataName"))
        { fieldName = t2lit; }
        else // anonymous filler
        { ASTTerm.cobolFillerCount++; 
          fieldName = "FILLER_F" + ASTTerm.cobolFillerCount; 
        } 

        Entity container = cent; 
          // (Entity) context.get("container"); 

        int multiplicity = 1;
        if (ASTTerm.hasTag(ctrm.terms,"dataOccursClause")) 
        { ASTTerm occursClause = 
            ASTTerm.getTermByTag(
                      ctrm.terms,"dataOccursClause"); 
          if (occursClause != null) 
          { multiplicity = 
              ((ASTCompositeTerm) occursClause).cobolOccursTimes(); 
          } 
        } 

        // JOptionPane.showMessageDialog(null, 
        //       fieldName +  
               // " Signed: " + isSigned + 
        //       " Width: " + totalWidth + 
               // " Integer width: " + integerWidth + 
               // " Fraction width: " + fractionalWidth + 
        //       " Multiplicity: " + multiplicity, 
        //       "", 
        //       JOptionPane.INFORMATION_MESSAGE);  
    
        if (ASTTerm.hasTag(ctrm.terms, "dataPictureClause"))
        { // It is a basic data item, not an entity
          // But could have 88's within it.

          ASTTerm pictureClause = 
            ASTTerm.getTermByTag(ctrm.terms, 
                                 "dataPictureClause"); 
          int wdth = 0;
          int integerWidth = 0; 
          int fractionalWidth = 0; 

          int contLevel = cent.levelNumber; 
          int contMult = cent.cardinalityValue; 

          Type typ = stringType; 
 
          if (pictureClause != null) 
          { wdth = pictureClause.cobolDataWidth() * multiplicity; 
            typ = pictureClause.cobolDataType();  
            boolean isSigned = pictureClause.cobolIsSigned();  
          
            if (multiplicity > 1) 
            { Type elemT = typ; 
              typ = new Type("Sequence", null);
              typ.setElementType(elemT); 
            }  

            integerWidth = pictureClause.cobolIntegerWidth(); 
            fractionalWidth = 
                pictureClause.cobolFractionWidth(); 

            int endPosn = startPos + wdth - 1; 

            // if ("FILLER".equals(fieldName)) 
            // { fieldName = "FILLER$" + startPos + "$" + endPosn; }

            
            /* JOptionPane.showMessageDialog(null, 
               "Type of " + fieldName + " is " + typ + 
               " Signed: " + isSigned + 
               " Width: " + wdth + 
               " Integer width: " + integerWidth + 
               " Fraction width: " + fractionalWidth + 
               " Multiplicity: " + multiplicity + 
               " Container multiplicity: " + contMult, 
               "", 
               JOptionPane.INFORMATION_MESSAGE); */  
         
            ASTTerm.setTaggedValue(fieldName, "startPosition", 
                                     "" + startPos); 
            ASTTerm.setTaggedValue(fieldName, "endPosition", 
                                     "" + endPosn); 
              
            ASTTerm.setTaggedValue(fieldName, "integerWidth", 
                                     "" + integerWidth); 
            ASTTerm.setTaggedValue(fieldName, "fractionWidth", 
                                     "" + fractionalWidth);       
            ASTTerm.setTaggedValue(fieldName, "oclType", 
                                     "" + typ);    
            ASTTerm.setTaggedValue(fieldName, "width", 
                                     "" + wdth);       
            if (typ != null) 
            { if ("String".equals(typ.getName()))
              { typ.setFixedSize(true, 
                               new BasicExpression(wdth)); 
              }

              String dval = typ.defaultValue(); 
              ASTTerm.setTaggedValue(
                                   fieldName, "defaultValue", 
                                   dval);  
              Constraint consV = 
                Constraint.getDataConstraint(fieldName,
                      typ,integerWidth,fractionalWidth, 
                      isSigned); 

              if (multiplicity == 1 && consV != null)
              { consV.ownerName = progname;  
                invs.add(consV);  
              }
            }   

            int dIndex = fieldName.lastIndexOf("$"); 
            if (dIndex > 0 && dIndex < fieldName.length())
            { String baseName = fieldName.substring(dIndex+1); 
              ASTTerm.setTaggedValue(baseName, "width", 
                                     "" + wdth);       
              // JOptionPane.showMessageDialog(null,
              //   "Base name of " + fieldName + " is " + baseName, 
              //   "", JOptionPane.INFORMATION_MESSAGE); 
              ASTTerm.setTaggedValue(baseName, 
                                     "startPosition", 
                                     "" + startPos); 
              ASTTerm.setTaggedValue(baseName, 
                                     "endPosition", 
                                     "" + endPosn); 
            } 

            Attribute att = 
              new Attribute(fieldName, typ, 
                            ModelElement.INTERNAL);
            att.setElementType(typ.getElementType());  
            att.setWidth(wdth); // total width
            att.setMultiplicity(multiplicity);
              // width of each element is width/multiplicity
            att.setStartPosition(startPos); 
            att.setEndPosition(endPosn);   
            cent.addAttribute(att); 
          }
          else // no type
          { for (int j = 1; j < entries.size(); j++) 
            { remainder.add(entries.get(j)); } 
            return res; 
          } 


            // Integer startPosition = 
            //   (Integer) context.get("startPosition"); 

            // int startPos = 1; 
          int endPos = startPos + wdth - 1; 
            // context.put("startPosition", endPos + 1);
          totalWidth = totalWidth + wdth; 
          int fwdth = wdth/multiplicity; 


          if (multiplicity == 1 && contMult == 1)
          { // fieldName = owner.subrange(startPos,endPos)

            BasicExpression ownerbe = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
            Vector localcontainers = new Vector(); 
            localcontainers.addAll(containers); 
            localcontainers.add(ownerbe);
 
            BasicExpression attr = 
                BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typ);
            
            // for each cbe : containers
            // add this invariant: 

            for (int k = 0; k < localcontainers.size(); k++) 
            { Expression cbe = 
                (Expression) localcontainers.get(k); 

              Vector spars = new Vector(); 
              spars.add(new BasicExpression(startPos)); 
              spars.add(new BasicExpression(endPos));  
              BasicExpression substr = 
                BasicExpression.newFunctionBasicExpression(
                    "subrange", cbe, spars); 

              Expression simpsubstr = 
                                 substr.simplify(); 

          /*    JOptionPane.showMessageDialog(null, 
                 progname + ":: " + fieldName + 
                 " = " + simpsubstr + "\n" + 
                 "Field width = " + fwdth, 
                 "", 
                 JOptionPane.INFORMATION_MESSAGE); */ 

              ASTTerm.setTaggedValue("" + simpsubstr, 
                                     "width", 
                                     "" + fwdth);       
            
              Expression convertedExpr = 
                Type.typeConversionFromString(
                                          simpsubstr,typ); 
              BinaryExpression inv = 
                new BinaryExpression("=", attr, 
                                     convertedExpr);
              Constraint cons = 
                Constraint.getConstraint(inv); 
              cons.ownerName = progname;  
              invs.add(cons);
            }
          } 
          else if (multiplicity > 1 && contMult == 1)
          { // fieldName[i] = 
            //    owner.subrange(startPos[i],endPos[i])

            JOptionPane.showMessageDialog(null, 
                 progname + ":: " + fieldName + 
                 "[i] = " + ownername + 
                 ".subrange(" + startPos + " + (i-1)*" + 
                            fwdth + 
                            ",  " + startPos + 
                            " + i*" + fwdth + " - 1)", 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE);

            BasicExpression owner = 
              BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
            BasicExpression attr = 
              BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typ);

            for (int h = 1; h <= multiplicity; h++) 
            { // attr[h] = owner.subrange(sph, eph), converted
              Expression attrh = 
                BasicExpression.newIndexedBasicExpression(
                                   attr,
                                   new BasicExpression(h)); 
              int sph = startPos + (h-1)*fwdth; 
              int eph = startPos + h*fwdth - 1; 
              BasicExpression sphexpr = 
                    new BasicExpression(sph); 
              BasicExpression ephexpr = 
                    new BasicExpression(eph); 
              Vector hpars = new Vector(); 
              hpars.add(sphexpr); 
              hpars.add(ephexpr); 

              ASTTerm.setTaggedValue(fieldName + 
                                     "(" + h + ")", 
                                     "width", 
                                     "" + fwdth);       

              BasicExpression ownh = 
                BasicExpression.newFunctionBasicExpression(
                  "subrange", owner, hpars); 
              Expression convExprh = 
                Type.typeConversionFromString(
                       ownh, typ.getElementType()); 
              BinaryExpression invh = 
                new BinaryExpression("=", attrh, convExprh);
              Constraint consh = 
                 Constraint.getConstraint(invh); 
              consh.ownerName = progname;  
              invs.add(consh);
            }
          } 
          else if (multiplicity == 1 & contMult > 1)
          { // fieldName[i] = owner[i].subrange(...)

            JOptionPane.showMessageDialog(null, 
               progname + ":: " + fieldName + 
               "[i] = " + ownername + 
               "[i].subrange(" + startPos + "," + endPos + ")", 
               "", 
               JOptionPane.INFORMATION_MESSAGE);

            // BasicExpression indx = 
            //     BasicExpression.newVariableBasicExpression(
            //                        "indx", 
            //                        intType); 
                            
            Type seqType = new Type("Sequence", null); 
            seqType.setElementType(stringType); 
            Type typSeq = new Type("Sequence", null); 
            typSeq.setElementType(typ); 
            
            BasicExpression owner = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, 
                                   seqType); 
            // owner.setArrayIndex(indx); 

            BasicExpression attr = 
                 BasicExpression.newAttributeBasicExpression(
                                    fieldName, 
                                    typSeq);
            Vector spars = new Vector(); 
            // attr.setArrayIndex(indx); 
            spars.add(new BasicExpression(startPos)); 
            spars.add(new BasicExpression(endPos));  
            
            // Vector ipars = new Vector(); 
            // ipars.add(new BasicExpression(1)); 
            // ipars.add(
            //     new BasicExpression(contMult)); 

            int hwidth = endPos - startPos + 1; 

            for (int h = 1; h <= contMult; h++) 
            { // attr[h] = owner[h].subrange(sph, eph)

              Expression attrh = 
                BasicExpression.newIndexedBasicExpression(
                                   attr,
                                   new BasicExpression(h)); 

              ASTTerm.setTaggedValue(fieldName + 
                                     "(" + h + ")", 
                                     "width", 
                                     "" + hwidth);       
              Expression ownerh = 
                BasicExpression.newIndexedBasicExpression(
                                   owner, 
                                   new BasicExpression(h)); 
            
              BasicExpression substr = 
                  BasicExpression.newFunctionBasicExpression(
                     "subrange", ownerh, spars); 
              Expression convExprh = 
                  Type.typeConversionFromString(
                                          substr,typ); 
              BinaryExpression invh = 
                new BinaryExpression("=", attrh, convExprh);
              Constraint consh = 
                 Constraint.getConstraint(invh); 
              consh.ownerName = progname;  
              invs.add(consh);
            }
          } // else case that they are both multiple. 
          else if (multiplicity > 1 & contMult > 1)
          { // fieldName[i] = sequence made from 
            //                owner[i].subrange(...)

            JOptionPane.showMessageDialog(null, 
              progname + ":: " + 
                fieldName + "[i] = Integer.subrange(1," + 
                multiplicity + ")->collect( _j | " + ownername + 
                                                "[i].subrange(" + 
                startPos + " + (_j - 1)*" + fwdth + ", " + 
                startPos + " + _j*" + fwdth + " - 1))", 
              "", 
              JOptionPane.INFORMATION_MESSAGE);

                            
            Type seqType = new Type("Sequence", null); 
            seqType.setElementType(stringType); 
            Type typSeq = new Type("Sequence", null); 
            typSeq.setElementType(typ); 
            Type seqseqType = new Type("Sequence", null); 
            seqseqType.setElementType(typSeq); 
            
            BasicExpression owner = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, 
                                   seqType); 

            BasicExpression attr = 
                 BasicExpression.newAttributeBasicExpression(
                                    fieldName, 
                                    typSeq);
      
            BasicExpression _j = 
                 BasicExpression.newVariableBasicExpression(
                                    "_j", 
                                    intType); 
            Vector ipars = new Vector(); 
            ipars.add(new BasicExpression(1)); 
            ipars.add(
                new BasicExpression(multiplicity)); 

            BasicExpression dmn = 
              BasicExpression.newFunctionBasicExpression(
                     "subrange", "Integer", ipars);
            BinaryExpression indmn = 
                new BinaryExpression(":", _j, dmn);       
      
            for (int h = 1; h <= contMult; h++) 
            { // attr[h] = 
              //   Integer.subrange(1,multiplicity)->collect( 
              //     _j | owner[h].subrange(sphj, ephj)
              // where sphj = startPos + fwdth*(_j-1)
              //       ephj = startPos + fwdth*_j - 1

              Expression attrh = 
                BasicExpression.newIndexedBasicExpression(
                                   attr,
                                   new BasicExpression(h));
              attrh.setType(seqseqType); 
              attrh.setElementType(typSeq); 

              ASTTerm.setTaggedValue(fieldName + 
                                     "(" + h + ")", 
                                     "width", 
                                     "" + fwdth);       
 
              BasicExpression spexpr = 
                   new BasicExpression(startPos);
              BasicExpression widthbe = 
                   new BasicExpression(fwdth); 
              BinaryExpression jminus = 
                   new BinaryExpression("-", _j, oneExpression);
              jminus.setBrackets(true);   
              BinaryExpression sphexpr = 
                   new BinaryExpression("*", widthbe, jminus);  
              BinaryExpression sphj = 
                   new BinaryExpression("+", spexpr, sphexpr); 
              
              BinaryExpression ephexpr = 
                   new BinaryExpression("*", widthbe, _j);  
              BinaryExpression ephj = 
                   new BinaryExpression("+", 
                         new BasicExpression(startPos - 1),  
                                        ephexpr); 
              
              Vector spars = new Vector(); 
              spars.add(sphj); 
              spars.add(ephj); 
 
              owner.setType(seqType); 
              owner.setElementType(stringType); 
              Expression ownerh = 
                BasicExpression.newIndexedBasicExpression(
                                   owner, 
                                   new BasicExpression(h));
              ownerh.setType(stringType);  
            
              BasicExpression substr = 
                  BasicExpression.newFunctionBasicExpression(
                     "subrange", ownerh, spars); 
              Expression convExprh = 
                  Type.typeConversionFromString(
                              substr, typ.getElementType());
              BinaryExpression collectExpr = 
                new BinaryExpression("|C", indmn, convExprh);  
              BinaryExpression invh = 
                new BinaryExpression("=", attrh, collectExpr);
              Constraint consh = 
                 Constraint.getConstraint(invh); 
              consh.ownerName = progname;  
              invs.add(consh);
            }
          } 

          entries.remove(0);  

          if (entries.size() > 0 && 
              levelNumber != 88 &&
              is88Entry((ASTTerm) entries.get(0)))
          { Vector remainingEntries = new Vector(); 
            for (int j = 0; j < entries.size(); j++) 
            { remainingEntries.add(entries.get(j)); }

            Vector localInvs = new Vector();
            Vector newRemainder = new Vector(); 
            Vector newcontainers = new Vector(); 
            // cbe.subrange(startPos) for each 
            // cbe : containers, 
            // plus contbe.subrange(startPos)

            BasicExpression startbe = 
               new BasicExpression(startPos);
            BasicExpression endbe = 
               new BasicExpression(endPos);
            Vector subrangepars = new Vector(); 
            subrangepars.add(startbe); 
            subrangepars.add(endbe);

            for (int k = 0; k < containers.size(); k++) 
            { BasicExpression cbe = 
                (BasicExpression) containers.get(k); 
              BasicExpression newcbe = 
                BasicExpression.newFunctionBasicExpression(
                   "subrange", cbe, subrangepars);
              newcontainers.add(newcbe); 
            }

            Entity newent = new Entity(fieldName + "_Class");
            newent.levelNumber = levelNumber; 
            newent.cardinalityValue = multiplicity; 

            if (ownername.equals(pname)) { } 
            else 
            { BasicExpression ownerbe = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
              BasicExpression newcbe = 
                BasicExpression.newFunctionBasicExpression(
                   "subrange", ownerbe, subrangepars);  
              newcontainers.add(newcbe); 
            }

            Vector newRes = 
              cobolProcessDataEntries(context, 
                 remainingEntries, newent, levelNumber, 
                 1, newcontainers, localInvs, newRemainder);

            res.addAll(newRes);   
            invs.addAll(localInvs); 

            entries.clear();
            entries.addAll(newRemainder);
          }

          startPos = endPos + 1; 
        } 
        else // No PICTURE => new entity
        { // Integer startPosition = 
          //    (Integer) context.get("startPosition"); 
          // int startPos = startPosition.intValue(); 

          if ("FILLER".equals(fieldName)) {} 
          else 
          { Entity newent = new Entity(fieldName + "_Class");
            newent.levelNumber = levelNumber; 
            newent.cardinalityValue = multiplicity; 

            ASTTerm.setTaggedValue(fieldName, "oclType", 
                                              "String");    
            ASTTerm.setTaggedValue(fieldName, "defaultValue", 
                                   "\"\"");
  
            Type typ = new Type(newent); 
            if (multiplicity > 1) 
            { Type elemT = typ; 
              typ = new Type("Sequence", null);
              typ.setElementType(elemT); 
            }  

            Attribute att = 
              new Attribute(fieldName, typ, 
                         ModelElement.INTERNAL); 
      
            res.add(newent);
            newent.container = cent;
            //    ownername = pname; 
            //  }  
            //   res.add(att); 
            
            cent.addAttribute(att); 
            ownername = 
                 cname.substring(0,cname.length()-6);
            
            JOptionPane.showMessageDialog(null, 
                 fieldName + 
                 " is subrecord of " + ownername + 
                 " from " + startPos + 
                 " multiplicity " + multiplicity, 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE);
             att.setMultiplicity(multiplicity); 
             
       // context.put("container", newent); 
       // context.put("previousLevel", new Integer(levelNumber));
       // context.put("startPosition", new Integer(1));

            Vector remainingEntries = new Vector(); 
            for (int j = 1; j < entries.size(); j++) 
            { remainingEntries.add(entries.get(j)); }

            Vector localInvs = new Vector();
            Vector newRemainder = new Vector(); 
            Vector newcontainers = new Vector(); 
            // cbe.subrange(startPos) for each 
            // cbe : containers, 
            // plus contbe.subrange(startPos)

            for (int k = 0; k < containers.size(); k++) 
            { BasicExpression cbe = 
                (BasicExpression) containers.get(k); 
              BasicExpression newcbe = 
                BasicExpression.newFunctionBasicExpression(
                   "subrange", cbe, 
                   new BasicExpression(startPos));
              newcontainers.add(newcbe); 
            }

            if (ownername.equals(pname)) { } 
            else 
            { BasicExpression ownerbe = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
              BasicExpression newcbe = 
                BasicExpression.newFunctionBasicExpression(
                   "subrange", ownerbe, 
                   new BasicExpression(startPos));
              newcontainers.add(newcbe); 
            }

            Vector newRes = 
              cobolProcessDataEntries(context, 
                 remainingEntries, newent, levelNumber, 
                 1, newcontainers, localInvs, newRemainder);

            res.addAll(newRes);   
            entries.clear();
            entries.addAll(newRemainder);
            // startPos = startPos + newent.totalWidth 

            int fwdth = newent.totalWidth; 
            int totwdth = newent.totalWidth * multiplicity;

            /* JOptionPane.showMessageDialog(null, 
                 newent + 
                 " total width = " + totwdth, 
                 "", 
                 JOptionPane.INFORMATION_MESSAGE); */ 

            att.setWidth(totwdth); 
            ASTTerm.setTaggedValue(fieldName, "width", 
                                   "" + totwdth);       


            int endPos = startPos + totwdth - 1;
            ASTTerm.setTaggedValue(fieldName, "startPosition", 
                                   "" + startPos);       
            ASTTerm.setTaggedValue(fieldName, "endPosition", 
                                   "" + endPos);       


            if (ownername.equals(pname)) { } 
            else 
            { BasicExpression ownerbe = 
                BasicExpression.newAttributeBasicExpression(
                                   ownername, stringType);  
              BasicExpression attr = 
                BasicExpression.newAttributeBasicExpression(
                                   fieldName, 
                                   typ);
              Vector localcontainers = new Vector(); 
              localcontainers.addAll(containers); 
              localcontainers.add(ownerbe); 
 
              for (int k = 0; k < localcontainers.size(); k++) 
              { Expression cbe = 
                   (Expression) localcontainers.get(k); 
                Vector spars = new Vector(); 
                spars.add(new BasicExpression(startPos)); 
                spars.add(new BasicExpression(endPos));
                if (multiplicity == 1)   
                { BasicExpression substr = 
                    BasicExpression.newFunctionBasicExpression(
                      "subrange", cbe, spars); 
                  Expression simpsubstr = 
                    substr.simplify(); 
                  Expression convertedExpr = 
                    Type.typeConversionFromString(
                                          simpsubstr,typ); 
                  BinaryExpression inv = 
                    new BinaryExpression("=", attr, 
                                       convertedExpr);

                  /* JOptionPane.showMessageDialog(null, 
                     progname + ":: " + inv, 
                          "", 
                          JOptionPane.INFORMATION_MESSAGE); */ 

                  Constraint cons = 
                    Constraint.getConstraint(inv); 
                  cons.ownerName = progname;  
                  invs.add(cons);
                } 
                else 
                { for (int h = 1; h <= multiplicity; h++) 
                  { // attr[h] = owner.subrange(sph, eph), converted
                    Expression attrh = 
                      BasicExpression.newIndexedBasicExpression(
                                   attr,
                                   new BasicExpression(h)); 
                    int sph = startPos + (h-1)*fwdth; 
                    int eph = startPos + h*fwdth - 1; 
                    BasicExpression sphexpr = 
                      new BasicExpression(sph); 
                    BasicExpression ephexpr = 
                      new BasicExpression(eph); 
                    Vector hpars = new Vector(); 
                    hpars.add(sphexpr); 
                    hpars.add(ephexpr); 

                    BasicExpression ownh = 
                      BasicExpression.newFunctionBasicExpression(
                      "subrange", cbe, hpars); 
                    Expression convExprh = 
                    Type.typeConversionFromString(
                          ownh,typ.getElementType()); 
                    BinaryExpression invh = 
                      new BinaryExpression("=", attrh, convExprh);
                    Constraint consh = 
                       Constraint.getConstraint(invh); 
                    consh.ownerName = progname;  
                    invs.add(consh);
                  }
                }
              }
            } 

            totalWidth = totalWidth + totwdth; 
            startPos = endPos + 1; 
            invs.addAll(localInvs); 
          }
        } 
      }
      else 
      { entries.remove(0); }   
    }

    cent.totalWidth = totalWidth; 
    return res; 
  } 

  public Expression cobolDataValue(Expression varbe)
  { if ("dataValueClause".equals(tag))
    { // (VALUE IS? | VALUES ARE?) dataValueInterval
      String keyword = terms.get(0) + ""; 
      ASTTerm trm = (ASTTerm) terms.get(terms.size() - 1); 
        
      if (trm.size() == 1)
      { String dataValue = trm.literalForm(); 
        if (varbe instanceof BasicExpression && 
            ((BasicExpression) varbe).getData().equals(
                                                 "subrange"))
        { // varbe is a String
          if (Expression.isInteger(dataValue))
          {
            varbe = 
              Type.typeConversionFromString(
                            varbe,new Type("int", null)); 
          } 
          else if (Expression.isNumber(dataValue))
          { varbe = 
              Type.typeConversionFromString(
                            varbe,new Type("double", null)); 
          } 
        }

        BinaryExpression inv1ante = 
          new BinaryExpression("=", varbe, 
                    new BasicExpression(dataValue));
        return inv1ante; 
      } 
      else if (trm.size() > 1) // "VALUES".equals(keyword))
      { ASTTerm fromTerm = trm.getTerm(0); 
        ASTTerm toTerm = trm.getTerm(1); 
        String dataValue1 = fromTerm.literalForm(); 
        ASTTerm toValue = toTerm.getTerm(1); 
        String dataValue2 = toValue.literalForm();

        if (varbe instanceof BasicExpression && 
            ((BasicExpression) varbe).getData().equals(
                                                 "subrange"))
        { // varbe is a String
          if (Expression.isInteger(dataValue1))
          {
            varbe = 
              Type.typeConversionFromString(
                            varbe,new Type("int", null)); 
          } 
          else if (Expression.isNumber(dataValue1))
          { varbe = 
              Type.typeConversionFromString(
                            varbe,new Type("double", null)); 
          } 
        }

        BinaryExpression expr1 = 
          new BinaryExpression("<=",  
                    new BasicExpression(dataValue1), varbe);
        BinaryExpression expr2 = 
          new BinaryExpression("<=", varbe, 
                    new BasicExpression(dataValue2));
        return 
          new BinaryExpression("&", expr1, expr2); 
      } 
    } 

    return new BinaryExpression("=", varbe, 
                       new BasicExpression("\" \"")); 
  } 
  
  public Vector cobolPerformThruDefinitions(java.util.Map context, Vector invs)
  { // Each PERFORM X THRU/THROUGH Y yields Z_thru_Y operation
    // for Z from X upto Y. 
 
    Vector res = new Vector();

    if ("compilationUnit".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = tt.cobolPerformThruDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("programUnit".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = 
          tt.cobolPerformThruDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("identificationDivision".equals(tag))
    { 
      return res; 
    } 

    if ("programIdParagraph".equals(tag))
    { return res; } 

    if ("dataDivision".equals(tag))
    { return res; } 

    if ("procedureDivision".equals(tag))
    { // sequence of paragraphs/sections
 
      int n = terms.size(); 
      ASTTerm tt = (ASTTerm) terms.get(n-1); 
      Vector ttres = 
         tt.cobolPerformThruDefinitions(context, invs); 
      return ttres; 
    } 

    if ("procedureDivisionBody".equals(tag))
    { // paragraphs procedureSection*

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = 
           tt.cobolPerformThruDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 

    if ("paragraphs".equals(tag))
    { // sentence* paragraph*

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm tt = (ASTTerm) terms.get(i); 
        Vector ttres = 
           tt.cobolPerformThruDefinitions(context, invs); 
        res.addAll(ttres); 
      } 
      return res; 
    } 
    
    if ("procedureSection".equals(tag))
    { // procedureSectionHeader . paragraphs

      if (terms.size() <= 2) 
      { return res; } 

      ASTTerm paras = (ASTTerm) terms.get(2);       
      Vector ttres = 
         paras.cobolPerformThruDefinitions(context, invs);        
      res.addAll(ttres);
      return res;
    } 

    if ("paragraph".equals(tag))
    { // paragraphName . (alteredGoTo | sentence*)

      ASTTerm tt = (ASTTerm) terms.get(0);
      String lit = tt.literalForm(); 
      res.add(lit);  
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm ttx = (ASTTerm) terms.get(i); 
        ttx.cobolPerformThruDefinitions(context, invs);
      }  
      return res; 
    } 
      
    if ("sentence".equals(tag))
    { // statement* .

      for (int i = 0; i < terms.size() - 1; i++) 
      { ASTTerm ttx = (ASTTerm) terms.get(i); 
        ttx.cobolPerformThruDefinitions(context, invs);
      }  

      return res; 
    } 

    if ("performStatement".equals(tag))
    { // PERFORM (performInlineStatement | 
      //    performProcedureStatement)

      if (terms.size() <= 1) 
      { return res; } 

      ASTTerm tt = (ASTTerm) terms.get(1);
      Vector ttres = 
           tt.cobolPerformThruDefinitions(context, invs); 
      res.addAll(ttres); 
      return res; 
    } 

    if ("performProcedureStatement".equals(tag))
    { // procedureName 
      // ((THROUGH | THRU) procedureName)? performType?

      if (terms.size() <= 1) 
      { return res; } 

      ASTTerm tt = (ASTTerm) terms.get(1);
      String lit = tt.literalForm(); 

      if ("THRU".equals(lit) || "THROUGH".equals(lit))
      { ASTTerm tt0 = (ASTTerm) terms.get(0);
        String frompara = tt0.literalForm();
        ASTTerm tt1 = (ASTTerm) terms.get(2);
        String topara = tt1.literalForm(); 
        context.put(frompara,topara); 
      } 

      return res; 
    } 

    /* Default: */ 
  
    for (int i = 0; i < terms.size(); i++) 
    { ASTTerm ttx = (ASTTerm) terms.get(i); 
      ttx.cobolPerformThruDefinitions(context, invs);
    }  

    return res; 
  } 

  public Vector vbLabelFunctions()
  { // System.out.println(tag); 
    
    if ("module".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("moduleBody".equals(tt.getTag()))
          { return tt.vbLabelFunctions(); } 
        } 
      } 
      return res; 
    }

    if ("moduleBody".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("moduleBodyElement".equals(tt.getTag()))
          { Vector fns = tt.vbLabelFunctions(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("subStmt".equals(tag) || 
        "functionStmt".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("block".equals(tt.getTag()))
          { Vector fns = tt.vbLabelFunctions(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("moduleBodyElement".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbLabelFunctions(); 
    } 

    if ("moduleBlock".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbLabelFunctions(); 
    } 

    if ("block".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("blockStmt".equals(tt.getTag()))
          { Vector fns = tt.vbLabelFunctions(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("blockStmt".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbLabelFunctions(); 
    } 

    if ("lineLabel".equals(tag) && 
        terms.size() > 0)
    { ASTTerm trm = (ASTTerm) terms.get(0); 
      Vector res = new Vector(); 
      res.add(trm.literalForm()); 
      return res;  
    } 
 
    return new Vector(); 
  } 

  public Vector vbProcessDeclarations()
  { // System.out.println(tag); 
    
    if ("module".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("moduleBody".equals(tt.getTag()))
          { return tt.vbProcessDeclarations(); } 
        } 
      } 
      return res; 
    }

    if ("moduleBody".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("moduleBodyElement".equals(tt.getTag()))
          { Vector fns = tt.vbProcessDeclarations(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("subStmt".equals(tag) || 
        "functionStmt".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("block".equals(tt.getTag()))
          { Vector fns = tt.vbProcessDeclarations(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("moduleBodyElement".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbProcessDeclarations(); 
    } 

    if ("moduleBlock".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbProcessDeclarations(); 
    } 

    if ("block".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm)
        { ASTCompositeTerm tt = (ASTCompositeTerm) trm; 
          if ("blockStmt".equals(tt.getTag()))
          { Vector fns = tt.vbProcessDeclarations(); 
            res.addAll(fns); 
          } 
        } 
      } 
      return res; 
    }

    if ("blockStmt".equals(tag) && 
        terms.get(0) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(0); 
      return trm.vbProcessDeclarations(); 
    } 

    if ("variableStmt".equals(tag) && 
        terms.size() > 1 && terms.get(1) instanceof ASTCompositeTerm)
    { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(1); 
      Vector res = new Vector(); 
      res.addAll(trm.vbProcessDeclarations()); 
      return res;  
    } 

    if ("variableListStmt".equals(tag) && 
        terms.size() > 0)
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { if (terms.get(i) instanceof ASTCompositeTerm)
        { ASTCompositeTerm trm = (ASTCompositeTerm) terms.get(i); 
          res.addAll(trm.vbProcessDeclarations());
        } 
      }  
      return res;  
    } 

    if ("variableSubStmt".equals(tag) && 
        terms.size() > 1)
    { // ambiguousIdentifier asTypeClause
      Vector res = new Vector();
      ASTTerm vname = (ASTTerm) terms.get(0); 
      String var = vname.literalForm(); 
      ASTTerm vtype = (ASTTerm) terms.get(1); 
      if (vtype instanceof ASTCompositeTerm)
      { ASTCompositeTerm ct = (ASTCompositeTerm) vtype; 
        String vbtype = ct.vbType(); 
        String vblength = ct.vbLength();
        if (vblength.equals("0")) { } 
        else if (vbtype.equals("String"))
        { ASTTerm.setTaggedValue(var, "isFixedWidth", 
                                 "true");
          ASTTerm.setTaggedValue(var, "width", 
                                 vblength);
          /* JOptionPane.showMessageDialog(null, 
                 var + 
                 " total width = " + vblength, 
                 "", 
                 JOptionPane.INFORMATION_MESSAGE); */ 
        }   
        
        res.add(var + " : " + vbtype + "[" + vblength + "]");
      }  
      return res;  
    } 
 
    return new Vector(); 
  } 

  public String vbType()
  { if ("asTypeClause".equals(tag) && terms.size() > 1)
    { // AS (NEW)? type_ (fieldLength)? 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        if (t instanceof ASTCompositeTerm && 
            "type_".equals(t.getTag()))
        { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(i);
          return tt.vbType(); 
        } 
      } 
    }

    if ("type_".equals(tag))
    { // (baseType | complexType) ('(' ')')?
      ASTTerm t = (ASTTerm) terms.get(0); 
      return t.literalForm(); 
    } 

    return "OclAny"; 
  }  
      
  public String vbLength()
  { if ("asTypeClause".equals(tag) && terms.size() > 1)
    { // AS (NEW)? type_ (fieldLength)? 

      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm t = (ASTTerm) terms.get(i); 
        if (t instanceof ASTCompositeTerm && 
            "fieldLength".equals(t.getTag()))
        { ASTCompositeTerm tt = (ASTCompositeTerm) terms.get(i);
          return tt.vbLength(); 
        } 
      } 
    }

    if ("fieldLength".equals(tag))
    { // * (integerLiteral | ambiguousIdentifier)
      ASTTerm t = (ASTTerm) terms.get(terms.size()-1); 
      return t.literalForm(); 
    } 

    return "0"; 
  }  

  public static void convertAntlr2CSTL()
  { // Testing of JS to KM3

    BufferedReader br = null;
    Vector res = new Vector();
    String s;
    boolean eof = false;
    File sourcefile = new File("output/ast.txt");  
      /* default */ 

    try
    { br = new BufferedReader(new FileReader(sourcefile)); }
    catch (FileNotFoundException _e)
    { System.out.println("!! File not found: " + sourcefile);
      return; 
    }

    String sourcestring = ""; 
    int noflines = 0; 

    while (!eof)
    { try { s = br.readLine(); }
      catch (IOException _ex)
      { System.out.println("!! Reading Antlr AST file output/ast.txt failed.");
        return; 
      }
      if (s == null) 
      { eof = true; 
        break; 
      }
      else 
      { sourcestring = sourcestring + s + " "; } 
      noflines++; 
    }

    System.out.println(">>> Read " + noflines + " lines"); 

    Compiler2 c = new Compiler2();    

    ASTTerm xx =
      c.parseGeneralAST(sourcestring); 

    if (xx == null) 
    { System.err.println(">>> Invalid text for general AST"); 
      System.err.println(c.lexicals); 
      return; 
    } 
  
    java.util.Map m1 = new java.util.HashMap();
    java.util.Map m2 = new java.util.HashMap();
    Vector v1 = new Vector();
    Vector v2 = new Vector(); 

    String rr = xx.antlr2cstl(); 
    System.out.println(rr); 


    // Object sobj = "string object"; 
    // Object robj = new Object(); 
    // System.out.println(sobj); 
    // System.out.println(robj); 

  }

  public void checkMathOCL()
  { // System.out.println(">>> MathOCL term " + this); 
    
    if ("specification".equals(tag))
    { // specification ID _*  
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        trm.checkMathOCL(); 
        // System.out.println(ASTTerm.mathoclvars); 
      } 
      return; 
    } 

    if ("part".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      trm.checkMathOCL(); 
      return; 
    } 

    if ("instruction".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      trm.checkMathOCL(); 
      return; 
    } 

    if (terms.size() == 1)
    { // one term
      ASTTerm ct = (ASTTerm) terms.get(0); 
      ct.checkMathOCL();  
      return; 
    } 

    if (terms.size() == 3 &&
        ("logicalExpression".equals(tag) ||
         "additiveExpression".equals(tag) || 
         "equalityExpression".equals(tag))  
        )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();  
      return; 
    } 

    if (terms.size() == 6 &&
        "logicalExpression".equals(tag)  
        )
    { // FORALL id : typ . expr
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm(); 
      Object oldval = ASTTerm.mathoclvars.get(vname); 
      ASTTerm.mathoclvars.put(vname, ""); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ct2.checkMathOCL();
      ASTTerm.mathoclvars.put(vname, oldval);   
      return; 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();  
      return; 
    } 

    if (terms.size() == 6 &&
        "factorExpression".equals(tag) && 
        "C_{".equals(terms.get(1) + "")  
       )
    { // C_{ expr } ^{ expr }
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(4); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();  
      return; 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        "E[".equals(terms.get(1) + "")  
       )
    { // E_[ expr ]
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ct1.checkMathOCL();
      return; 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) 
       )
    { // INTEGRAL expr id
      ASTTerm var = (ASTTerm) terms.get(2); 
      String vname = var.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      Object oldval = ASTTerm.mathoclvars.get(vv);
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put(vv, nullTerm); 
      ASTTerm ct = (ASTTerm) terms.get(1); 
      ct.checkMathOCL();
      ASTTerm.mathoclvars.put(vv, oldval); 
      return; 
    } 

    if (terms.size() == 9 &&
        "factorExpression".equals(tag)  
       )
    { // integral with bounds
      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();
      ASTTerm var = (ASTTerm) terms.get(8); 
      String vname = var.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      Object oldval = ASTTerm.mathoclvars.get(vv); 
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put(vv, nullTerm); 
      ASTTerm ct = (ASTTerm) terms.get(7); 
      ct.checkMathOCL();
      ASTTerm.mathoclvars.put(vv, oldval); 
      return; 
    } 

    if (terms.size() == 8 &&
        "factorExpression".equals(tag)  
       )
    { // SUM _{ expr } ^{ expr } expr
      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ASTTerm ct3 = (ASTTerm) terms.get(7); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();  
      ct3.checkMathOCL(); 
      return; 
    } 

    if (terms.size() == 5 &&
        "factorExpression".equals(tag)  
       )
    { // PARTIALDIFF _{ id }  expr
      ASTTerm var = (ASTTerm) terms.get(2); 
      String vname = var.literalForm(); 
      Object oldvalue = ASTTerm.mathoclvars.get(vname);  
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put(vname, nullTerm); 
      ASTTerm ct = (ASTTerm) terms.get(4); 
      ct.checkMathOCL();
      ASTTerm.mathoclvars.put(vname,oldvalue); 
      return; 
    } 

    if (terms.size() == 7 &&
        "conditionalExpression".equals(tag)  
       )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      ASTTerm ct3 = (ASTTerm) terms.get(5); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();  
      ct3.checkMathOCL(); 
      return; 
    } 

    if (terms.size() == 6 &&
        "lambdaExpression".equals(tag)  
       )
    { // lambda id : typ in expr
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm(); 
      Object oldvalue = ASTTerm.mathoclvars.get(vname);  
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put(vname, nullTerm); 
      ASTTerm ct = (ASTTerm) terms.get(5); 
      ct.checkMathOCL();
      ASTTerm.mathoclvars.put(vname,oldvalue); 
      return; 
    } 

    if (terms.size() == 6 &&
        "letExpression".equals(tag)  
       )
    { // let v = expression in expr
      ASTTerm ct1 = (ASTTerm) terms.get(3); 
      ct1.checkMathOCL();
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm();
      Object oldvalue = ASTTerm.mathoclvars.get(vname);  
      ASTTerm.mathoclvars.put(vname, ct1); 
      ASTTerm ct = (ASTTerm) terms.get(5); 
      ct.checkMathOCL();
      ASTTerm.mathoclvars.put(vname,oldvalue); 
      return; 
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "logicalExpression".equals(tag)) && 
        terms.get(0) instanceof ASTSymbolTerm  
       )
    { // prefix unary expression
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ct1.checkMathOCL();
      return; 
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "factor2Expression".equals(tag)) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // postfix unary expression, expr'

      Object oldvalue = ASTTerm.mathoclvars.get("x");  
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put("x", nullTerm); 
      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ct1.checkMathOCL();
      ASTTerm.mathoclvars.put("x", oldvalue); 
      
      return; 
    } 

    if (terms.size() == 3 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + "")  
       )
    { // bracketed expression

      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ct1.checkMathOCL();
      return; 
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "(".equals(terms.get(2) + "") && 
        ")".equals(terms.get(4) + "")  
       )
    { // bracketed expression

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();
      return; 
    } 

    if (terms.size() == 4 &&
        "factor2Expression".equals(tag) && 
        "^{".equals(terms.get(1) + "") && 
        "}".equals(terms.get(3) + "")  
       )
    { // exponentiation

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();
      return; 
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "^".equals(terms.get(1) + "") && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + "")  
       )
    { // exponentiation

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      ct1.checkMathOCL();
      ct2.checkMathOCL();
      return; 
    } 

    if (terms.size() == 4 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "")  
       )
    { // op ( exprs )

      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ct1.checkMathOCL();
      return; 
    } 

    // Also, setExpression

    if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + "") && 
        terms.size() > 3)
    { // Define ID = expression or instruction
      ASTTerm expr = (ASTTerm) terms.get(3);
      expr.checkMathOCL(); 
      ASTTerm var = (ASTTerm) terms.get(1);
      String vname = var.literalForm();
      Object olddef = ASTTerm.mathoclvars.get(vname); 
      if (olddef != null) 
      { System.err.println("!! Warning: " + vname + " is being re-defined"); 
        // JOptionPane.showMessageDialog(null, 
        //   "!! Warning: " + vname + " is being re-defined", 
        //   "", 
        //   JOptionPane.WARNING_MESSAGE);
      } 
      ASTTerm.mathoclvars.put(vname, expr); 
      /* JOptionPane.showMessageDialog(null, 
               ">> " + vname + " now defined as " + 
               expr.literalFormSpaces(), 
               "", 
               JOptionPane.INFORMATION_MESSAGE); */
 
      System.out.println(">> " + vname + " now defined as " + 
               expr.literalFormSpaces()); 

      if (expr.getTag().equals("expression") && 
          "=".equals(terms.get(2) + ""))
      { Vector thm = new Vector(); 
        thm.add(var); 
        thm.add(expr); 
        ASTTerm.mathoclrewrites.add(thm);  
      } 
      return; 
    }
    else if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + ""))
    { ASTTerm var = (ASTTerm) terms.get(1);
      String vname = var.literalForm(); 
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  
      ASTTerm.mathoclvars.put(vname, nullTerm); 
      System.out.println(">> " + vname + " defined as arbitrary real number"); 
      // JOptionPane.showMessageDialog(null, 
      //   ">> " + vname + " defined as arbitrary real number", 
      //   "", 
      //   JOptionPane.INFORMATION_MESSAGE);
      return; 
    }

    if ("constraint".equals(tag) && 
        "Constraint".equals(terms.get(0) + "") &&
        terms.size() > 4)
    { // Constraint on vv | expr 
      
      // ASTTerm var = (ASTTerm) terms.get(1); 
      // String vname = var.literalForm(); 
      // ASTTerm.mathoclvars.put(vname, ""); 
      ASTTerm tcons = (ASTTerm) terms.get(4); 
      tcons.checkMathOCL();
      // ASTTerm.mathoclvars.remove(vname);
      Vector thm = new Vector(); 
      thm.add(tcons); 
      thm.add(new ASTBasicTerm("basicExpression", "true")); 
      ASTTerm.mathocltheorems.add(thm);  
      return; 
    }  

    if ("rewrite".equals(tag) && 
        "Rewrite".equals(terms.get(0) + "") && 
        terms.size() >= 4)
    { // Rewrite lhs as rhs
      ASTTerm lhs = (ASTTerm) terms.get(1); 
      ASTTerm rhs = (ASTTerm) terms.get(3); 
      rhs.checkMathOCL();
      
      Vector thm = new Vector(); 
      thm.add(lhs); 
      thm.add(rhs); 
      ASTTerm.mathoclrewrites.add(thm);  
    } 


    if ("simplify".equals(tag) && 
        "Simplify".equals(terms.get(0) + "") &&
        terms.size() > 1)
    { ASTTerm t1 = (ASTTerm) terms.get(1); 
      t1.checkMathOCL(); 
      return; 
    }  

    
    if ("identifier".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0);
      String vv = t1.literalForm(); 

      if ("e".equals(vv))
      { return; } 

      Object val = ASTTerm.mathoclvars.get(vv); 
      if (val == null) 
      { // JOptionPane.showMessageDialog(null, 
        //   "!! Warning!: variable " + vv + " does not have a definition",   "",
        //   JOptionPane.WARNING_MESSAGE);

        System.err.println("!! Warning!: variable " + vv + " does not have a definition"); 
 
      } 
      return; 
    } 

    if ("expressionList".equals(tag))
    { for (int i = 0; i < terms.size(); i++) 
      { ASTTerm expri = (ASTTerm) terms.get(i); 
        if (expri instanceof ASTSymbolTerm) { } 
        else 
        { expri.checkMathOCL(); } 
      } 
      return; 
    }

    if ("solve".equals(tag))
    { // Solve <expressionList> for <idList>
      ASTCompositeTerm exprs = (ASTCompositeTerm) terms.get(1);
      ASTTerm vars = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector varTerms = vars.getTerms();
      ASTBasicTerm nullTerm = 
        new ASTBasicTerm("basicExpression", "null");  

      java.util.Map oldvalues = 
           new java.util.HashMap(); 

      for (int i = 0; i < varTerms.size(); i++) 
      { ASTTerm vi = (ASTTerm) varTerms.get(i); 
        String vname = vi.literalForm();
        oldvalues.put(vname, ASTTerm.mathoclvars.get(vname));  
        ASTTerm.mathoclvars.put(vname, nullTerm); 
      } 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        expri.checkMathOCL(); 
      } 

      for (int i = 0; i < varTerms.size(); i++) 
      { ASTTerm vi = (ASTTerm) varTerms.get(i); 
        String vname = vi.literalForm(); 
        ASTTerm.mathoclvars.put(vname, 
                                oldvalues.get(vname)); 
      } // restore old values

      return; 
    }  

    if ("prove".equals(tag))
    { // Prove <expression> if <exprList>
      ASTTerm expr = (ASTTerm) terms.get(1);
      ASTTerm exprs = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        expri.checkMathOCL(); 
      } 

      expr.checkMathOCL(); 
      return; 
    }  

    if ("theorem".equals(tag) && 
        terms.size() >= 4)
    { // Theorem <expression> when <exprList>
      ASTTerm concl = (ASTTerm) terms.get(1);
      ASTTerm premise = (ASTTerm) terms.get(3);

      Vector thm = new Vector(); 
      thm.add(concl); 
      thm.add(premise); 

      ASTTerm.mathocltheorems.add(thm); 

      return; 
    }  

    if ("substituteIn".equals(tag) && terms.size() >= 4)
    { // Substitute v in expr|instr
      ASTTerm var = (ASTTerm) terms.get(1);
      ASTTerm expr = (ASTTerm) terms.get(3);
      
      String vname = var.literalForm(); 
      Object vx = ASTTerm.mathoclvars.get(vname); 
      if (vx == null)
      { JOptionPane.showMessageDialog(null, 
          "Warning!: variable " + vname + " does not have a definition to use for " + this,   "",
          JOptionPane.WARNING_MESSAGE); 
      } // also if it is (basicExpression null)

      expr.checkMathOCL(); 
      return; 
    } 

    if ("expandTo".equals(tag))
    { // Expand <expression> to N terms
      // ASTTerm expr = (ASTTerm) terms.get(1);

      // expr.checkMathOCL(); 
      return; 
    }  // No check

    if ("factorBy".equals(tag) || "cancelIn".equals(tag))
    { // Factor <expression> by <expression>
      // Cancel <expression> in <expression>

      ASTTerm expr1 = (ASTTerm) terms.get(1);
      ASTTerm expr2 = (ASTTerm) terms.get(3);

      expr1.checkMathOCL(); 
      expr2.checkMathOCL(); 
      return; 
    }  
  } 

  public Vector mathOCLVariables()
  { // System.out.println(">>> MathOCL term " + this); 
    
    if ("specification".equals(tag))
    { // specification ID _*

      Vector res = new Vector();   
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        Vector vars = trm.mathOCLVariables(); 
        res = VectorUtil.union(res,vars); 
      } 
      return res; 
    } 

    if ("part".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      return trm.mathOCLVariables(); 
    } 

    if ("instruction".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      return trm.mathOCLVariables(); 
    } 

    if (terms.size() == 1)
    { // one term
      ASTTerm ct = (ASTTerm) terms.get(0); 
      return ct.mathOCLVariables();  
    } 

    if (terms.size() == 3 &&
        ("logicalExpression".equals(tag) ||
         "additiveExpression".equals(tag) || 
         "equalityExpression".equals(tag))  
        )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();  
      return VectorUtil.union(res1, res2); 
    } 

    if (terms.size() == 6 &&
        "logicalExpression".equals(tag)  
        )
    { // FORALL id : typ . expr, EXISTS
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm(); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      Vector res = ct2.mathOCLVariables();
      res.remove(vname); 
      return res; 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();  
      return VectorUtil.union(res1,res2); 
    } 

    if (terms.size() == 6 &&
        "factorExpression".equals(tag) && 
        "C_{".equals(terms.get(1) + "")  
       )
    { // C_{ expr } ^{ expr }
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(4); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();  
      return VectorUtil.union(res1,res2); 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        "E[".equals(terms.get(1) + "")  
       )
    { // E_[ expr ]
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      return ct1.mathOCLVariables();
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) 
       )
    { // INTEGRAL expr id
      ASTTerm var = (ASTTerm) terms.get(2); 
      String vname = var.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      ASTTerm ct = (ASTTerm) terms.get(1); 
      Vector res = ct.mathOCLVariables();
      res.remove(vname); 
      return res; 
    } 

    if (terms.size() == 9 &&
        "factorExpression".equals(tag)  
       )
    { // INTEGRAL _{ lb } ^{ up } expr dv

      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();
      ASTTerm var = (ASTTerm) terms.get(8); 
      String vname = var.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      ASTTerm ct = (ASTTerm) terms.get(7); 
      Vector res3 = ct.mathOCLVariables();
      Vector res = VectorUtil.union(res1,res2); 
      res = VectorUtil.union(res,res3); 
      res.remove(vv); 
      return res; 
    } 

    if (terms.size() == 8 &&
        "factorExpression".equals(tag)  
       )
    { // SUM _{ expr } ^{ expr } expr
      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ASTTerm ct3 = (ASTTerm) terms.get(7); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();  
      Vector res3 = ct3.mathOCLVariables(); 
      Vector res = VectorUtil.union(res1,res2); 
      return VectorUtil.union(res,res3); 
    } 

    if (terms.size() == 5 &&
        "factorExpression".equals(tag)  
       )
    { // PARTIALDIFF _{ id }  expr
      ASTTerm var = (ASTTerm) terms.get(2); 
      String vname = var.literalForm(); 
      ASTTerm ct = (ASTTerm) terms.get(4); 
      Vector res = ct.mathOCLVariables();
      res.remove(vname); 
      return res; 
    } 

    if (terms.size() == 7 &&
        "conditionalExpression".equals(tag)  
       )
    { // binary expression
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      ASTTerm ct3 = (ASTTerm) terms.get(5); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();  
      Vector res3 = ct3.mathOCLVariables();
      Vector res = VectorUtil.union(res1,res2); 
 
      return VectorUtil.union(res,res3); 
    } 

    if (terms.size() == 6 &&
        "lambdaExpression".equals(tag)  
       )
    { // lambda id : typ in expr
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm(); 
      ASTTerm ct = (ASTTerm) terms.get(5); 
      Vector res = ct.mathOCLVariables();
      res.remove(vname); 
      return res; 
    } 

    if (terms.size() == 6 &&
        "letExpression".equals(tag)  
       )
    { // let v = expression in expr
      ASTTerm ct1 = (ASTTerm) terms.get(3); 
      Vector res1 = ct1.mathOCLVariables();
      ASTTerm var = (ASTTerm) terms.get(1); 
      String vname = var.literalForm();
      ASTTerm ct = (ASTTerm) terms.get(5); 
      Vector res = ct.mathOCLVariables();
      res.remove(vname); 
      return VectorUtil.union(res1,res); 
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "logicalExpression".equals(tag)) && 
        terms.get(0) instanceof ASTSymbolTerm  
       )
    { // prefix unary expression
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      return ct1.mathOCLVariables();
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "factor2Expression".equals(tag)) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // postfix unary expression, expr'

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      Vector res = ct1.mathOCLVariables();
      res.remove("x"); 
      
      return res; 
    } 

    if (terms.size() == 3 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + "")  
       )
    { // bracketed expression

      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      return ct1.mathOCLVariables();
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "(".equals(terms.get(2) + "") && 
        ")".equals(terms.get(4) + "")  
       )
    { // bracketed expression

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();
      return VectorUtil.union(res1,res2); 
    } 

    if (terms.size() == 4 &&
        "factor2Expression".equals(tag) && 
        "^{".equals(terms.get(1) + "") && 
        "}".equals(terms.get(3) + "")  
       )
    { // expr ^{ expr }

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();
      return VectorUtil.union(res1,res2); 
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "^".equals(terms.get(1) + "") &&
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + "")  
       )
    { // expr ^{ expr }

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      Vector res1 = ct1.mathOCLVariables();
      Vector res2 = ct2.mathOCLVariables();
      return VectorUtil.union(res1,res2); 
    } 

    if (terms.size() == 4 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "")  
       )
    { // op ( exprs )

      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      return ct1.mathOCLVariables();
    } 

    // Also, setExpression

    if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + "") && 
        terms.size() > 3)
    { // Define ID = expression or instruction
      return new Vector(); 
    } 
    else if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + ""))
    { return new Vector(); }

    if ("constraint".equals(tag) && 
        "Constraint".equals(terms.get(0) + "") &&
        terms.size() > 4)
    { // Constraint on vv | expr 
      
      ASTTerm tcons = (ASTTerm) terms.get(4); 
      return tcons.mathOCLVariables();
    }  

    if ("simplify".equals(tag) && 
        "Simplify".equals(terms.get(0) + "") &&
        terms.size() > 1)
    { ASTTerm t1 = (ASTTerm) terms.get(1); 
      return t1.mathOCLVariables(); 
    }  

    
    if ("identifier".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0);
      String vv = t1.literalForm(); 
      Vector res = new Vector(); 
      res.add(vv); 
      return res; 
    } 

    if ("expressionList".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm expri = (ASTTerm) terms.get(i); 
        if (expri instanceof ASTSymbolTerm) { } 
        else 
        { Vector vrs = expri.mathOCLVariables(); 
          res = VectorUtil.union(res,vrs); 
        } 
      } 
      return res; 
    }

    if ("solve".equals(tag))
    { // Solve <expressionList> for <idList>
      ASTCompositeTerm exprs = (ASTCompositeTerm) terms.get(1);
      ASTTerm vars = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector varTerms = vars.getTerms();

      Vector res = new Vector(); 
      Vector localVars = new Vector(); 

      for (int i = 0; i < varTerms.size(); i++) 
      { ASTTerm vi = (ASTTerm) varTerms.get(i); 
        String vname = vi.literalForm(); 
        localVars.add(vname); 
      } 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        Vector resi = expri.mathOCLVariables();
        res = VectorUtil.union(res,resi);  
      } 

      res.removeAll(localVars); 
      return res; 
    }  

    if ("prove".equals(tag))
    { // Prove <expression> if <exprList>
      ASTTerm expr = (ASTTerm) terms.get(1);
      ASTTerm exprs = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector res = new Vector(); 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        Vector resi = expri.mathOCLVariables();
        res = VectorUtil.union(res,resi);  
      } 

      Vector rese = expr.mathOCLVariables(); 
      return VectorUtil.union(res,rese); 
    }  

  /* 
    if ("substituteIn".equals(tag))
    { // Substitute v in expr|instr
      ASTTerm var = (ASTTerm) terms.get(1);
      ASTTerm expr = (ASTTerm) terms.get(3);
      
      String vname = var.literalForm(); 
      Object vx = ASTTerm.mathoclvars.get(vname); 
      if (vx == null)
      { JOptionPane.showMessageDialog(null, 
          "Warning!: variable " + vname + " does not have a definition to use for " + this,   "",
          JOptionPane.WARNING_MESSAGE); 
      } 

      expr.checkMathOCL(); 
      return; 
    } */  

    if ("expandTo".equals(tag))
    { // Expand <expression> to N terms
      ASTTerm expr = (ASTTerm) terms.get(1);

      return expr.mathOCLVariables(); 
    } 

    if ("factorBy".equals(tag) || "cancelIn".equals(tag))
    { // Factor <expression> by <expression>
      // Cancel <expression> in <expression>

      ASTTerm expr1 = (ASTTerm) terms.get(1);
      ASTTerm expr2 = (ASTTerm) terms.get(3);

      Vector res1 = expr1.mathOCLVariables(); 
      Vector res2 = expr2.mathOCLVariables(); 
      return VectorUtil.union(res1,res2); 
    } 

    return new Vector();  
  } 

  public ASTTerm mathOCLSubstitute(String var, ASTTerm repl)
  { // System.out.println(">>> MathOCL term " + this); 
    
    if ("specification".equals(tag))
    { // specification ID _*

      Vector res = new Vector(); 
      res.add(terms.get(0)); 
      res.add(terms.get(1));   
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        ASTTerm newtrm = trm.mathOCLSubstitute(var, repl); 
        res.add(newtrm); 
      } 
      return new ASTCompositeTerm(tag, res); 
    } 

    if ("part".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      ASTTerm newtrm = trm.mathOCLSubstitute(var,repl); 
      return new ASTCompositeTerm(tag, newtrm); 
    } 

    if ("instruction".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      ASTTerm newtrm = trm.mathOCLSubstitute(var,repl); 
      return new ASTCompositeTerm(tag, newtrm); 
    } 

    if (terms.size() == 1)
    { // one term
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct = (ASTTerm) terms.get(0); 
      ASTTerm newtrm = ct.mathOCLSubstitute(var,repl); 
      return new ASTCompositeTerm(tag, newtrm); 
    } 

    if (terms.size() == 3 &&
        ("logicalExpression".equals(tag) ||
         "additiveExpression".equals(tag) || 
         "equalityExpression".equals(tag))  
        )
    { // binary expression

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm ctop = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);
      Vector res = new Vector();  
      res.add(res1); res.add(ctop); res.add(res2);   
      return new ASTCompositeTerm(tag, res);
    } 

    if (terms.size() == 6 &&
        "logicalExpression".equals(tag)  
        )
    { // FORALL id : typ . expr, EXISTS

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm vart = (ASTTerm) terms.get(1); 
      ASTTerm sym2 = (ASTTerm) terms.get(2);
      ASTTerm typ = (ASTTerm) terms.get(3); 
      ASTTerm sym3 = (ASTTerm) terms.get(4); 

      String vname = vart.literalForm(); 
      if (var.equals(vname)) 
      { return this; } 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ASTTerm res = ct2.mathOCLSubstitute(var,repl);
      Vector newterms = new Vector(); 
      newterms.add(sym1); newterms.add(vart); 
      newterms.add(sym2); newterms.add(typ); 
      newterms.add(sym3); newterms.add(res); 
      return new ASTCompositeTerm(tag, newterms); 
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // binary expression

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm sym1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(res1); res.add(sym1); res.add(res2);   
      return new ASTCompositeTerm(tag,res); 
    } 

    if (terms.size() == 6 &&
        "factorExpression".equals(tag) && 
        "C_{".equals(terms.get(1) + "")  
       )
    { // C_{ expr } ^{ expr }

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 

      ASTTerm ct1 = (ASTTerm) terms.get(1);
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      ASTTerm sym3 = (ASTTerm) terms.get(3); 

      ASTTerm ct2 = (ASTTerm) terms.get(4);
      ASTTerm sym4 = (ASTTerm) terms.get(5); 
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);  
      Vector res = new Vector(); 
      res.add(sym1); res.add(res1); res.add(sym2); 
      res.add(sym3); res.add(res2); res.add(sym4); 
      return new ASTCompositeTerm(tag, res);  
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) && 
        "E[".equals(terms.get(1) + "")  
       )
    { // E_[ expr ]
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct0 = (ASTTerm) terms.get(0); 
      ASTTerm ct1 = (ASTTerm) terms.get(1);
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
 
      ASTTerm rt1 = ct1.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(ct0); res.add(rt1); res.add(ct2); 
      return new ASTCompositeTerm(tag, res);  
    } 

    if (terms.size() == 3 &&
        "factorExpression".equals(tag) 
       )
    { // INTEGRAL expr id
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 

      ASTTerm vart = (ASTTerm) terms.get(2); 
      String vname = vart.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      if (var.equals(vv)) 
      { return this; } 
      ASTTerm ct = (ASTTerm) terms.get(1); 
      ASTTerm res = ct.mathOCLSubstitute(var, repl);
      Vector newargs = new Vector(); 
      newargs.add(sym1); newargs.add(res); newargs.add(vart); 
      return new ASTCompositeTerm(tag, newargs);  
    } 

    if (terms.size() == 9 &&
        "factorExpression".equals(tag)  
       )
    { // INTEGRAL _{ lb } ^{ up } expr dv

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm sym2 = (ASTTerm) terms.get(1); 
      ASTTerm ct1 = (ASTTerm) terms.get(2);
      ASTTerm sym3 = (ASTTerm) terms.get(3); 
      ASTTerm sym4 = (ASTTerm) terms.get(4); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ASTTerm sym5 = (ASTTerm) terms.get(6); 
      ASTTerm ct = (ASTTerm) terms.get(7); 
      
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);

      ASTTerm vbl = (ASTTerm) terms.get(8); 
      String vname = vbl.literalForm(); // dx 
      String vv = vname.substring(1); // x 
      if (var.equals(vv))
      { Vector res = new Vector(); 
        res.add(sym1); res.add(sym2); res.add(res1); 
        res.add(sym3); res.add(sym4); res.add(res2); 
        res.add(sym5); res.add(ct); res.add(vbl); 
        return new ASTCompositeTerm(tag, res); 
      } 
      ASTTerm res3 = ct.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(sym1); res.add(sym2); res.add(res1); 
      res.add(sym3); res.add(sym4); res.add(res2); 
      res.add(sym5); res.add(res3); res.add(vbl); 
      return new ASTCompositeTerm(tag, res);
    } 

    if (terms.size() == 8 &&
        "factorExpression".equals(tag)  
       )
    { // SUM _{ expr } ^{ expr } expr

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm sym2 = (ASTTerm) terms.get(1); 
      ASTTerm ct1 = (ASTTerm) terms.get(2); 
      ASTTerm sym3 = (ASTTerm) terms.get(3); 
      ASTTerm sym4 = (ASTTerm) terms.get(4); 
      ASTTerm ct2 = (ASTTerm) terms.get(5); 
      ASTTerm sym5 = (ASTTerm) terms.get(6); 
      ASTTerm ct3 = (ASTTerm) terms.get(7);
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);  
      ASTTerm res3 = ct3.mathOCLSubstitute(var,repl);
 
      Vector res = new Vector(); 
      res.add(sym1); res.add(sym2); res.add(res1); 
      res.add(sym3); res.add(sym4); res.add(res2); 
      res.add(sym5); res.add(res3); 
      return new ASTCompositeTerm(tag, res); 
    } 

    if (terms.size() == 5 &&
        "factorExpression".equals(tag)  
       )
    { // PARTIALDIFF _{ id }  expr
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm sym2 = (ASTTerm) terms.get(1); 

      ASTTerm vbl = (ASTTerm) terms.get(2); 
      String vname = vbl.literalForm(); 
      if (var.equals(vname)) { return this; } 

      ASTTerm sym3 = (ASTTerm) terms.get(3); 
      ASTTerm ct = (ASTTerm) terms.get(4); 
      ASTTerm res1 = ct.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(sym1); res.add(sym2); res.add(vbl); 
      res.add(sym3); res.add(res1); 
      return new ASTCompositeTerm(tag,res); 
    } 

    if (terms.size() == 7 &&
        "conditionalExpression".equals(tag)  
       )
    { // if test then e1 else e2 endif

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(3);
      ASTTerm sym3 = (ASTTerm) terms.get(4); 
      ASTTerm ct3 = (ASTTerm) terms.get(5); 
      ASTTerm sym4 = (ASTTerm) terms.get(6); 

      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);  
      ASTTerm res3 = ct3.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(sym1); res.add(res1); res.add(sym2); 
      res.add(res2); res.add(sym3); res.add(res3); 
      res.add(sym4); 
      return new ASTCompositeTerm(tag,res); 
    } 

    if (terms.size() == 6 &&
        "lambdaExpression".equals(tag)  
       )
    { // lambda id : typ in expr
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm vbl = (ASTTerm) terms.get(1); 
      String vname = vbl.literalForm();
      if (var.equals(vname)) { return this; } 
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      ASTTerm typ = (ASTTerm) terms.get(3); 
      ASTTerm sym3 = (ASTTerm) terms.get(4); 

      ASTTerm ct = (ASTTerm) terms.get(5); 
      ASTTerm res1 = ct.mathOCLSubstitute(var,repl);
      Vector res = new Vector(); 
      res.add(sym1); res.add(vbl); res.add(sym2); 
      res.add(typ); res.add(sym3); res.add(res1); 
      return new ASTCompositeTerm(tag,res); 
    } 

    if (terms.size() == 6 &&
        "letExpression".equals(tag)  
       )
    { // let v = expression in expr
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm vbl = (ASTTerm) terms.get(1); 
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      String vname = vbl.literalForm();
      ASTTerm ct1 = (ASTTerm) terms.get(3); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm sym3 = (ASTTerm) terms.get(4); 
      ASTTerm ct = (ASTTerm) terms.get(5); 
      Vector res = new Vector();
      if (var.equals(vname))
      { res.add(sym1); res.add(vbl); res.add(sym2); 
        res.add(res1); res.add(sym3); res.add(ct); 
        return new ASTCompositeTerm(tag,res); 
      }
      ASTTerm res2 = ct.mathOCLSubstitute(var,repl);
      res.add(sym1); res.add(vbl); res.add(sym2); 
      res.add(res1); res.add(sym3); res.add(res2); 
      return new ASTCompositeTerm(tag,res); 
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "logicalExpression".equals(tag)) && 
        terms.get(0) instanceof ASTSymbolTerm  
       )
    { // prefix unary expression
      
      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm ct1 = (ASTTerm) terms.get(1); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      Vector args = new Vector(); 
      args.add(sym1); args.add(res1); 
      return new ASTCompositeTerm(tag, args); 
    } 

    if (terms.size() == 2 &&
        ("factorExpression".equals(tag) || 
         "factor2Expression".equals(tag)) && 
        terms.get(1) instanceof ASTSymbolTerm  
       )
    { // postfix unary expression, expr'

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm sym1 = (ASTTerm) terms.get(1); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      // res.remove("x"); 
      Vector args = new Vector(); 
      args.add(res1); args.add(sym1); 
      return new ASTCompositeTerm(tag, args); 
    } 

    if (terms.size() == 3 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(0) + "") && 
        ")".equals(terms.get(2) + "")  
       )
    { // bracketed expression

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm ct1 = (ASTTerm) terms.get(1);
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
 
      Vector args = new Vector(); 
      args.add(sym1); 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      args.add(res1); 
      args.add(sym2); 
      return new ASTCompositeTerm(tag,args); 
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "(".equals(terms.get(2) + "") && 
        ")".equals(terms.get(4) + "")  
       )
    { // bracketed expression

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm sym1 = (ASTTerm) terms.get(1); 
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(3);
      ASTTerm sym3 = (ASTTerm) terms.get(4); 
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);
      Vector args = new Vector();
      args.add(res1); args.add(sym1); args.add(sym2); 
      args.add(res2); args.add(sym3); 
      return new ASTCompositeTerm(tag, args);  
    } 

    if (terms.size() == 4 &&
        "factor2Expression".equals(tag) && 
        "^{".equals(terms.get(1) + "") && 
        "}".equals(terms.get(3) + "")  
       )
    { // expr ^{ expr }

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm sym1 = (ASTTerm) terms.get(1); 
      ASTTerm ct2 = (ASTTerm) terms.get(2); 
      ASTTerm sym2 = (ASTTerm) terms.get(3);
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);
      Vector args = new Vector(); 
      args.add(res1); args.add(sym1); args.add(res2); 
      args.add(sym2); 
      return new ASTCompositeTerm(tag, args); 
    } 

    if (terms.size() == 5 &&
        "factor2Expression".equals(tag) && 
        "^".equals(terms.get(1) + "") && 
        "{".equals(terms.get(2) + "") && 
        "}".equals(terms.get(4) + "")  
       )
    { // expr ^{ expr }

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm ct1 = (ASTTerm) terms.get(0); 
      ASTTerm sym1 = (ASTTerm) terms.get(1); 
      ASTTerm sym2 = (ASTTerm) terms.get(2); 
      ASTTerm ct2 = (ASTTerm) terms.get(3); 
      ASTTerm sym3 = (ASTTerm) terms.get(4);
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      ASTTerm res2 = ct2.mathOCLSubstitute(var,repl);
      Vector args = new Vector(); 
      args.add(res1); args.add(sym1); args.add(sym2); 
      args.add(res2); 
      args.add(sym3); 
      return new ASTCompositeTerm(tag, args); 
    } 

    if (terms.size() == 4 &&
        "basicExpression".equals(tag) && 
        "(".equals(terms.get(1) + "") && 
        ")".equals(terms.get(3) + "")  
       )
    { // op ( exprs )

      String lit = literalForm(); 
      if (lit.equals(var))
      { return repl; } 

      ASTTerm sym1 = (ASTTerm) terms.get(0); 
      ASTTerm sym2 = (ASTTerm) terms.get(1); 
      ASTTerm ct1 = (ASTTerm) terms.get(2);
      ASTTerm sym3 = (ASTTerm) terms.get(3); 
 
      ASTTerm res1 = ct1.mathOCLSubstitute(var,repl);
      Vector args = new Vector(); 

      args.add(sym1); args.add(sym2); args.add(res1); 
      args.add(sym3); 
      return new ASTCompositeTerm(tag, args);
    } 

    // Also, setExpression, and 
    // (basicExpression expr . ID) and lim_{ ... }

   /* 
    if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + "") && 
        terms.size() > 3)
    { // Define ID = expression or instruction
      return new Vector(); 
    } 
    else if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + ""))
    { return new Vector(); }

    if ("constraint".equals(tag) && 
        "Constraint".equals(terms.get(0) + "") &&
        terms.size() > 4)
    { // Constraint on vv | expr 
      
      ASTTerm tcons = (ASTTerm) terms.get(4); 
      return tcons.mathOCLVariables();
    }  */ 

    if ("simplify".equals(tag) && 
        "Simplify".equals(terms.get(0) + "") &&
        terms.size() > 1)
    { ASTTerm t1 = (ASTTerm) terms.get(1); 
      ASTTerm sub = t1.mathOCLSubstitute(var,repl);
      Vector args = new Vector(); 
      args.add(terms.get(0)); args.add(sub); 
      return new ASTCompositeTerm(tag, args);  
    }  

    
    if ("identifier".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0);
      String vv = t1.literalForm(); 
      if (var.equals(vv)) 
      { return repl; } 
      return new ASTCompositeTerm(tag, t1); 
    } 

    if ("expressionList".equals(tag))
    { Vector res = new Vector(); 
      for (int i = 0; i < terms.size(); i++) 
      { ASTTerm expri = (ASTTerm) terms.get(i); 
        if (expri instanceof ASTSymbolTerm)
        { res.add(expri); } 
        else 
        { ASTTerm subi = expri.mathOCLSubstitute(var,repl); 
          res.add(subi); 
        } 
      } 
      return new ASTCompositeTerm(tag, res); 
    }

   /* 
    if ("solve".equals(tag))
    { // Solve <expressionList> for <idList>
      ASTCompositeTerm exprs = (ASTCompositeTerm) terms.get(1);
      ASTTerm vars = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector varTerms = vars.getTerms();

      Vector res = new Vector(); 
      Vector localVars = new Vector(); 

      for (int i = 0; i < varTerms.size(); i++) 
      { ASTTerm vi = (ASTTerm) varTerms.get(i); 
        String vname = vi.literalForm(); 
        localVars.add(vname); 
      } 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        Vector resi = expri.mathOCLVariables();
        res = VectorUtil.union(res,resi);  
      } 

      res.removeAll(localVars); 
      return res; 
    }  

    if ("prove".equals(tag))
    { // Prove <expression> if <exprList>
      ASTTerm expr = (ASTTerm) terms.get(1);
      ASTTerm exprs = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector res = new Vector(); 

      for (int i = 0; i < exprTerms.size(); i++) 
      { ASTTerm expri = (ASTTerm) exprTerms.get(i); 
        Vector resi = expri.mathOCLVariables();
        res = VectorUtil.union(res,resi);  
      } 

      Vector rese = expr.mathOCLVariables(); 
      return VectorUtil.union(res,rese); 
    }  

  
    if ("substituteIn".equals(tag))
    { // Substitute v in expr|instr
      ASTTerm var = (ASTTerm) terms.get(1);
      ASTTerm expr = (ASTTerm) terms.get(3);
      
      String vname = var.literalForm(); 
      Object vx = ASTTerm.mathoclvars.get(vname); 
      if (vx == null)
      { JOptionPane.showMessageDialog(null, 
          "Warning!: variable " + vname + " does not have a definition to use for " + this,   "",
          JOptionPane.WARNING_MESSAGE); 
      } 

      expr.checkMathOCL(); 
      return; 
    } 

    if ("expandTo".equals(tag))
    { // Expand <expression> to N terms
      ASTTerm expr = (ASTTerm) terms.get(1);

      return expr.mathOCLVariables(); 
    } 

    if ("factorBy".equals(tag) || "cancelIn".equals(tag))
    { // Factor <expression> by <expression>
      // Cancel <expression> in <expression>

      ASTTerm expr1 = (ASTTerm) terms.get(1);
      ASTTerm expr2 = (ASTTerm) terms.get(3);

      Vector res1 = expr1.mathOCLVariables(); 
      Vector res2 = expr2.mathOCLVariables(); 
      return VectorUtil.union(res1,res2); 
    } */ 

    return new ASTCompositeTerm(tag, terms);  
  } 

  /* This has been replaced by ASTTerm::solveEquations */ 
  public String preprocessMathOCL()
  { System.out.println(">>> MathOCL term " + this); 
    
    String res = ""; 

    if ("specification".equals(tag))
    { // specification ID _*  
      for (int i = 2; i < terms.size(); i++) 
      { ASTTerm trm = (ASTTerm) terms.get(i); 
        if (trm instanceof ASTCompositeTerm) 
        { ASTCompositeTerm ct = (ASTCompositeTerm) trm; 
          res = res + ct.preprocessMathOCL(); 
        } 
      } 
    } 

    if ("part".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      if (trm instanceof ASTCompositeTerm) 
      { ASTCompositeTerm ct = (ASTCompositeTerm) trm; 
        res = res + ct.preprocessMathOCL(); 
      } 
    } 

    if ("instruction".equals(tag))
    { // one term
      ASTTerm trm = (ASTTerm) terms.get(0);
      if (trm instanceof ASTCompositeTerm) 
      { ASTCompositeTerm ct = (ASTCompositeTerm) trm; 
        res = res + ct.preprocessMathOCL(); 
      } 
    } 

    if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + "") && 
        terms.size() > 3)
    { // Define ID = expression or instruction
      if (terms.get(3) instanceof ASTCompositeTerm)
      { ASTCompositeTerm expr = (ASTCompositeTerm) terms.get(3);
        ASTTerm var = (ASTTerm) terms.get(1);

        if (expr.getTag().equals("expression"))
        { ASTTerm.mathoclvars.put(var + "", expr); 
        // JOptionPane.showMessageDialog(null, 
        //       ">> " + var + " = " + expr, 
        //       "", 
        //       JOptionPane.INFORMATION_MESSAGE);
        }
     /* else if (expr.getTag().equals("substituteIn"))
      { ASTTerm def = 
          (ASTTerm) expr.getTerm(3); 
        ASTTerm subvar = 
          (ASTTerm) expr.getTerm(1); 
        ASTTerm varTerm = 
          (ASTTerm) ASTTerm.mathoclvars.get(subvar + "");
        // JOptionPane.showMessageDialog(null, 
        //       ">> " + subvar + " = " + varTerm, 
        //       "", 
        //       JOptionPane.INFORMATION_MESSAGE);
        if (varTerm != null && def.getTag().equals("expression")) 
        { Vector bvterms = new Vector(); 
          bvterms.add(new ASTSymbolTerm("(")); 
          bvterms.add(varTerm); 
          bvterms.add(new ASTSymbolTerm(")")); 

          ASTTerm ct = 
            new ASTCompositeTerm("basicExpression", bvterms); 
          ASTTerm subTerm = 
            def.substituteEq(subvar + "", ct); 
          String vt = subTerm.literalForm(); 
          // JOptionPane.showMessageDialog(null, 
          //     ">> Substitution for " + subvar + " = " + varTerm + 
          //     " is " + subTerm, 
          //     "", 
          //     JOptionPane.INFORMATION_MESSAGE);
          res = res + 
            "  Define " + var + " = " + vt; 
        } 
      } */
      }     
    } 

  /*  if ("identifier".equals(tag))
    { ASTTerm t1 = (ASTTerm) terms.get(0);
      String vv = t1.literalForm(); 
      String val = ASTTerm.getTaggedValue(t1, "value"); 
      if (val == null) 
      { JOptionPane.showMessageDialog(null, 
          "Warning!: variable " + vv + " does not have a definition",   "",
          JOptionPane.INFORMATION_MESSAGE); 
      } 
    } */ 

    /* if ("formula".equals(tag) && 
        "Define".equals(terms.get(0) + "") && 
        terms.size() < 3 && terms.size() > 1)
    { ASTTerm var = (ASTTerm) terms.get(1);
      res = res + 
            "  Define " + var;
    }  */ 
    
    if ("solve".equals(tag))
    { // Solve <expressionList> for <idList>
      ASTCompositeTerm exprs = (ASTCompositeTerm) terms.get(1);
      ASTTerm vars = (ASTTerm) terms.get(3);

      Vector exprTerms = exprs.getTerms(); 
      Vector varTerms = vars.getTerms();

      Vector variables = new Vector();  
      java.util.Map varCoefficients = new java.util.HashMap(); 


      // find coefficients of each var in each expr

      if (varTerms.size() == 1 && exprTerms.size() == 1) 
      { // test what powers of var are present
        // It could be a quadratic, or differential eqn

        ASTTerm var0 = (ASTTerm) varTerms.get(0); 
        ASTTerm expr0 = (ASTTerm) exprTerms.get(0); 
        String vx0 = var0.literalForm(); 
          
        Vector powers = ASTTerm.powersOf(var0,expr0);

        double minp = VectorUtil.vectorMinimum(powers); 
        double maxp = VectorUtil.vectorMaximum(powers); 
 
        Vector diffs = ASTTerm.differentialsOf(var0,expr0);
        Vector diffsR = VectorUtil.removeDuplicates(diffs); 
        double maxdp = VectorUtil.vectorMaximum(diffsR); 
        double mindp = VectorUtil.vectorMinimum(diffsR); 
          
        JOptionPane.showMessageDialog(null, 
              ">>> Var powers of " + vx0 + " are: " +  
              powers + " from: " + minp + " to: " + maxp + 
              " Differentials: " + diffsR + " highest: " + maxdp, 
              "", 
              JOptionPane.INFORMATION_MESSAGE); 

        if (maxp == 2 && minp >= 0 && maxdp == 0) 
        { String coefsq = ASTTerm.coefficientOfSquare(var0, expr0); 
          String coefvar = ASTTerm.coefficientOf(var0, expr0); 
          String cnsts = 
              ASTTerm.constantTerms(varTerms,expr0);
          JOptionPane.showMessageDialog(null, 
            ">>> This is a quadratic formula, solving using quadratic solver " + coefsq + "; " + coefvar + "; " + cnsts, 
            "", 
            JOptionPane.INFORMATION_MESSAGE);

          String quadformula1 = 
            AuxMath.quadraticFormula1(coefsq, coefvar, cnsts); 
          String quadformula2 = 
            AuxMath.quadraticFormula2(coefsq, coefvar, cnsts); 
          
          return "  Define " + vx0 + "$1 = " + quadformula1 + "\n" + 
                 "  Define " + vx0 + "$2 = " + quadformula2 + "\n" + 
                 "  Define " + vx0 + "\n" + 
                 "  Constraint on " + vx0 + " | (" + vx0 + " = " + vx0 + "$1) or (" + vx0 + " = " + vx0 + "$2)"; 
        } 
        else if (maxp == 1 && minp == -1 && maxdp == 0) 
        { // multiply by var
          String newformula = 
            ASTTerm.symbolicMultiplication(vx0, expr0); 
          return "  Solve " + newformula + " for " + vx0 + "\n"; 
        } 
        else if (maxp == 1 && minp >= 0 && maxdp == 0) 
        // linear
        { } 
        else if (maxdp == 0 && 
                 maxp > 0 && 
                 minp == 0 && powers.size() == 2)
        { // direct solution vx0 = (coef0/coefmaxp)^{1/maxp} 
          ASTTerm vpow; 
          if (ASTTerm.isIntegerValued(maxp))
          { vpow = ASTTerm.constructNPower(((int) maxp) + "", var0); }
          else 
          { vpow = ASTTerm.constructNPower(maxp + "", var0); }

          String ncoef = ASTTerm.coefficientOf(vpow,expr0); 

          Vector dvars = new Vector(); 
          dvars.add(vpow); 
          String dcnst = ASTTerm.constantTerms(dvars,expr0);

          JOptionPane.showMessageDialog(null, 
              ">>> This is an explicit n-power equation: " + 
              vpow + 
              " " + ncoef + " " + dcnst, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);
           return "  Simplify " + vx0 + " = (-" + dcnst + "/" + 
                                   ncoef + ")^{1/" + maxp + "}\n"; 
        } 
        else if (maxdp == 0 && 
                 maxp == 0 && 
                 minp < 0 && powers.size() == 2)
        { // direct solution vx0 = (coef0/coefminp)^{1/minp} 
          ASTTerm vpow; 

          if (ASTTerm.isIntegerValued(minp))
          { vpow = ASTTerm.constructNPower(((int) minp) + "", var0); }
          else 
          { vpow = ASTTerm.constructNPower(minp + "", var0); }
 
          String ncoef = ASTTerm.coefficientOf(vpow,expr0); 

          Vector dvars = new Vector(); 
          dvars.add(vpow); 
          String dcnst = ASTTerm.constantTerms(dvars,expr0);

          JOptionPane.showMessageDialog(null, 
              ">>> This is an explicit n-power equation: " + 
              vpow + 
              " " + ncoef + " " + dcnst, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);
           return "  Simplify " + vx0 + " = (-" + dcnst + "/" + 
                                   ncoef + ")^{1/" + minp + "}\n"; 
        } 
        else if (maxdp > 0 && diffsR.size() <= 2 && 
                 (mindp == 0 || mindp == maxdp) && 
                 maxp == 0)
        { // Differential eqn with only one diff term

          ASTTerm vdiff =
            ASTTerm.constructNDifferential((int) maxdp, var0); 
 
          Vector dpowers = ASTTerm.powersOf(vdiff,expr0);
          String dcoef = ASTTerm.coefficientOf(vdiff,expr0); 

          Vector dvars = new Vector(); 
          dvars.add(vdiff); 
          String dcnst = ASTTerm.constantTerms(dvars,expr0);

          double mindpp = VectorUtil.vectorMinimum(dpowers); 
          double maxdpp = VectorUtil.vectorMaximum(dpowers); 

          JOptionPane.showMessageDialog(null, 
              ">>> This is a differential equation: " + diffsR + 
              " " + dpowers + " " + vdiff + 
              " " + dcoef + " " + dcnst + 
              " " + mindpp + " " + maxdpp, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);

          // Homogenous if dcnst does not have x

          if (maxdpp == 1 && mindpp >= 0) // linear
          { if (maxdp == 1) // f'
            { return "  Define " + vx0 + 
                     " = -  " + 
                     "((" + dcnst + ")/" + dcoef + ") dx\n";
            } 
            else // f'' or higher occurs
            { ASTTerm vdiffpar1 = vdiff.getTerm(0); 
              return "  Solve " + vdiffpar1.literalForm() + 
                     " = -  " + 
                     "((" + dcnst + ")/" + dcoef + 
                     ") dx for " + vx0 + "\n"; 
            }  
          }

          return "  Solve " + exprs.literalForm() + " for " + vars.literalForm() + "\n";
        }
        else if (maxdp > 0)
        { // Differential eqn with several diff terms
          Vector alldcoefs = new Vector(); 
          Vector vdiffs =
              ASTTerm.constructNDifferentials((int) maxdp, var0,
                                      expr0, alldcoefs); 
          
          JOptionPane.showMessageDialog(null, 
              ">>> General differential equation " + 
              vdiffs + " " + alldcoefs, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);

          if (maxdp == 2 && vdiffs.size() == 3) 
          { // Quadratic homogenous equation 

            String coeff = "" + alldcoefs.get(0); 
            String coefd1 = "" + alldcoefs.get(1); 
            String coefd2 = "" + alldcoefs.get(2); 

            String quadf1 = 
              AuxMath.quadraticFormula1(coefd2, coefd1, 
                                        coeff); 
            String quadf2 = 
              AuxMath.quadraticFormula2(coefd2, coefd1, 
                                        coeff); 
          
            if (quadf1.equals(quadf2))
            { return "  Define " + vx0 + " = (A + B*x)*e^{" + quadf1 + "*x}"; } 
            return "  Define " + vx0 + " = A*e^{" + quadf1 + "*x} + B*e^{" + quadf2 + "*x}"; 
          } 

          return "  Solve " + exprs.literalForm() + " for " + vars.literalForm() + "\n";
        } 
        else 
        { JOptionPane.showMessageDialog(null, 
              ">>> Unrecognised formula", 
              "", 
              JOptionPane.INFORMATION_MESSAGE);
          return "  Solve " + exprs.literalForm() + " for " + vars.literalForm() + "\n";
        } 
      }  

      for (int i = 0; i < varTerms.size(); i++) 
      { ASTTerm var = (ASTTerm) varTerms.get(i); 

        if (",".equals(var + "")) 
        { continue; } 

        variables.add(var + ""); 

        for (int j = 0; j < exprTerms.size(); j++)
        { ASTTerm expr = (ASTTerm) exprTerms.get(j); 

          if (",".equals(expr + "")) 
          { continue; } 
          
          String coef = ASTTerm.coefficientOf(var,expr); 
          System.out.println(">>> Coefficient of " + var + " in " + expr + " is " + coef); 

          Vector vcoeffs = 
               (Vector) varCoefficients.get(var + ""); 
          if (vcoeffs == null) 
          { vcoeffs = new Vector(); }
          vcoeffs.add(coef); 
          varCoefficients.put(var + "", vcoeffs); 

          System.out.println(">>> Var coefficients: " + 
                             varCoefficients); 
          /* JOptionPane.showMessageDialog(null, 
              ">>> Var coefficients: " + 
                             varCoefficients, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);
            */ 
        } 
      }

      Vector constantTerms = new Vector(); 

      for (int j = 0; j < exprTerms.size(); j++)
      { ASTTerm expr = (ASTTerm) exprTerms.get(j); 

        if (",".equals(expr + "")) 
        { continue; } 

        String cnst = ASTTerm.constantTerms(varTerms,expr);
        constantTerms.add(cnst); 
      } 
  /*
      JOptionPane.showMessageDialog(null, 
              ">>> Constant terms: " + 
                             constantTerms, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);  */ 

      // The determinant of the varCoefficients
      // is the divisor. One row for each equation
      // One column for each variable.

      Vector divisorMatrix = new Vector(); 
      for (int j = 0; j < constantTerms.size(); j++)
      { Vector vvrow = new Vector(); 
        for (int i = 0; i < variables.size(); i++) 
        { String var = (String) variables.get(i);
          Vector vcoefs = (Vector) varCoefficients.get(var); 
          vvrow.add(vcoefs.get(j)); 
        } 
        divisorMatrix.add(vvrow); 
      }

      int msize = divisorMatrix.size(); 

      String divisorString = "1"; 

      if (AuxMath.isNumericMatrix(divisorMatrix))
      { double commonDivisor = 
          Math.pow(-1,msize) *
          AuxMath.determinant(msize, divisorMatrix); 
        divisorString = "" + commonDivisor; 
      } 
      else if (msize % 2 == 0) 
      { divisorString = "(" + 
          AuxMath.symbolicDeterminant(msize, divisorMatrix) + ")"; 
      } 
      else  
      { divisorString = "-1*(" + 
          AuxMath.symbolicDeterminant(msize, divisorMatrix) + ")"; 
      } 

  /* 
      JOptionPane.showMessageDialog(null, 
              ">>> Divisor matrix: " + 
              divisorMatrix + " " + 
              divisorString, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);   */ 

      // The determinant of the varCoefficients
      // is the numerator for var. One row for each equation
      // One column for each variable except the var. 1st var
      // +ve, 2nd -ve, etc.

      int factor = 1; 

      for (int vind = 0; vind < variables.size(); vind++)
      { String vx = (String) variables.get(vind);

        Vector varMatrix = new Vector(); 
        for (int j = 0; j < constantTerms.size(); j++)
        { Vector vv1row = new Vector(); 
          for (int i = 0; i < variables.size(); i++) 
          { if (i != vind) 
            { String var = (String) variables.get(i);
              Vector vcoefs = 
                  (Vector) varCoefficients.get(var); 
              vv1row.add(vcoefs.get(j)); 
            } 
          } 
          vv1row.add(constantTerms.get(j)); 
          varMatrix.add(vv1row); 
        }

        String varNumeratorString = "1"; 

        if (AuxMath.isNumericMatrix(varMatrix))
        { 
          double varNumerator = 
            factor*AuxMath.determinant(msize, varMatrix); 
          varNumeratorString = "" + varNumerator; 
        } 
        else 
        { varNumeratorString = 
            factor + "*" + 
            AuxMath.symbolicDeterminant(msize, varMatrix);
        } 

      /* 
        JOptionPane.showMessageDialog(null, 
              "  Define " + vx + " = " + 
              varNumeratorString + "/" + divisorString, 
              "", 
              JOptionPane.INFORMATION_MESSAGE);  */ 
  
        factor = factor*-1;

        if (!("0".equals(divisorString)) && 
            AuxMath.isNumeric(varNumeratorString) && 
            AuxMath.isNumeric(divisorString))
        { Double numer = 
             Double.parseDouble(varNumeratorString); 
          Double denom = Double.parseDouble(divisorString); 
          res = res + "  Define " + vx + " = " +
                                               numer/denom; 
        } 
        else 
        { res = res + "  Define " + vx + " = " + 
              varNumeratorString + "/" + divisorString + "\n"; 
        }  
      } 

    } 

    return res; 
  }

   

/*    Statement stat = xx.cstatementToKM3(m1,m2,v1,v2);
    Entity fromC = new Entity("FromC"); 
    BehaviouralFeature bf = new BehaviouralFeature("op"); 
    bf.addStereotype("unsafe"); 
    bf.setActivity(stat);
    fromC.addOperation(bf);  
    v2.add(fromC); */ 
 
    /* Type t = xx.cdeclarationToType(m1,m2,v1,v2);
    if (t != null && t.isEntity())
    { v2.add(t.getEntity()); } */ 
 
    // System.out.println(xx.cdeclaratorToModelElement());
    
/*    ((ASTCompositeTerm) xx).identifyCFunctions(null,m1,m2,v1,v2);


    Vector mxs = ((ASTCompositeTerm) xx).cprogramToKM3(null,m1,m2,v1,v2); */ 
    // System.out.println(mx + "");    

/*    for (int i = 0; i < v1.size(); i++) 
    { Type tt = (Type) v1.get(i); 
      System.out.println(tt.getKM3()); 
    } 

    try 
    { 
      File outfile = new File("output/Program.cs"); 
      PrintWriter outcs = 
         new PrintWriter(new BufferedWriter(new FileWriter(outfile)));
    outcs.println("using System;"); 
    outcs.println("using System.Collections;"); 
    outcs.println("using System.IO;"); 
    outcs.println("using System.Text;"); 
    outcs.println("using System.Text.RegularExpressions;"); 
    outcs.println("using System.Linq;");
    outcs.println("using System.Diagnostics;"); 
    outcs.println("using System.Reflection;");
    outcs.println("using System.Threading;");
    outcs.println("using System.Threading.Tasks;");
    outcs.println("using System.Xml.Serialization;"); 
    outcs.println("using System.Text.Json;"); 
    outcs.println("using System.Text.Json.Serialization;"); 
 
    for (int i = 0; i < v1.size(); i++)
    { Type t = (Type) v1.get(i);
      t.generateDeclarationCSharp(outcs);
    }

      for (int i = 0; i < v2.size(); i++) 
      { Entity ent = (Entity) v2.get(i); 
        System.out.println(ent.getKM3()); 
        ent.generateCSharp(v2,v1,outcs); 
      } 
      outcs.close();
    } catch (Exception _e) 
      { System.err.println("!! Error in file output/Program.cs "); 
        _e.printStackTrace(); 
      }  
  } */ 

} 